{"{\"assumptions\":{},\"sourceRoot\":\"/home/juancarlos/Escritorio/prueba/creator-sail-executor/c_emulator/\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"/home/juancarlos/Escritorio/prueba/creator-sail-executor/c_emulator\",\"filename\":\"/home/juancarlos/Escritorio/prueba/creator-sail-executor/c_emulator/transform32.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"/home/juancarlos/Escritorio/prueba/creator-sail-executor/c_emulator\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.28.6:development":{"value":{"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transformer;\n// transform.js\nfunction transformer(file, api) {\n  const j = api.jscodeshift;\n  const root = j(file.source);\n  const program = root.get().node.program;\n\n  // ============================================================\n  // Helpers: imports\n  // ============================================================\n  function normalizeSpecifiers(specifiers = []) {\n    return specifiers.map(s => {\n      if (s.type === 'ImportSpecifier') {\n        var _s$imported, _s$local;\n        const imported = ((_s$imported = s.imported) === null || _s$imported === void 0 ? void 0 : _s$imported.name) || '';\n        const local = ((_s$local = s.local) === null || _s$local === void 0 ? void 0 : _s$local.name) || imported;\n        return `named:${imported}=>${local}`;\n      }\n      if (s.type === 'ImportDefaultSpecifier') {\n        var _s$local2;\n        return `default:${((_s$local2 = s.local) === null || _s$local2 === void 0 ? void 0 : _s$local2.name) || ''}`;\n      }\n      if (s.type === 'ImportNamespaceSpecifier') {\n        var _s$local3;\n        return `ns:${((_s$local3 = s.local) === null || _s$local3 === void 0 ? void 0 : _s$local3.name) || ''}`;\n      }\n      return 'other';\n    }).sort().join('|');\n  }\n  function importExists(moduleName, specifiers) {\n    const want = normalizeSpecifiers(specifiers);\n    return root.find(j.ImportDeclaration, {\n      source: {\n        value: moduleName\n      }\n    }).filter(p => normalizeSpecifiers(p.node.specifiers) === want).size() > 0;\n  }\n  function makeNamedImport(moduleName, names) {\n    return j.importDeclaration(names.map(n => j.importSpecifier(j.identifier(n))), j.literal(moduleName));\n  }\n\n  // ============================================================\n  // Helpers: exported var\n  // ============================================================\n  function exportedVarExists(name) {\n    return root.find(j.ExportNamedDeclaration).filter(p => {\n      const decl = p.node.declaration;\n      if (!decl || decl.type !== 'VariableDeclaration') return false;\n      return decl.declarations.some(d => d.id.type === 'Identifier' && d.id.name === name);\n    }).size() > 0;\n  }\n  function makeExportedVar(name, initValue) {\n    return j.exportNamedDeclaration(j.variableDeclaration('var', [j.variableDeclarator(j.identifier(name), initValue)]), []);\n  }\n\n  // ============================================================\n  // Imports EXACTOS a insertar\n  // ============================================================\n  const desiredImports = [makeNamedImport('@/core/assembler/assembler.mjs', ['instructions', 'tag_instructions']), makeNamedImport('@/core/register/registerOperations.mjs', ['readRegister', 'writeRegister', 'notifyRegisterUpdate']), makeNamedImport('@/core/register/registerLookup.mjs', ['crex_findReg_bytag', 'crex_findReg']), makeNamedImport('@/core/core.mjs', ['status', 'set_execution_mode', 'PC_REG_INDEX', 'REGISTERS', 'getPC', 'main_memory', 'config_cache', 'L1_cache_memory', 'L1_I_cache_memory', 'L1_D_cache_memory', 'L2_D_cache_memory', 'L2_I_cache_memory', 'L2_cache_memory', 'updateCacheMem']), makeNamedImport('@/core/assembler/assembler.mjs', ['setInstructions']), makeNamedImport('../../IO.mjs', ['display_print']), makeNamedImport('@/core/capi/syscall.mts', ['SYSCALL']), makeNamedImport('@/core/events.mts', ['coreEvents']), makeNamedImport('@/web/utils.mjs', ['show_notification']), makeNamedImport('@/web/utils.mjs', ['reset_disable', 'instruction_disable', 'run_disable', 'stop_disable', 'isFinished']), makeNamedImport('../../../core.mjs', ['architecture']), makeNamedImport('@/core/register/registerGlowState.mjs', ['clearAllRegisterGlows'])];\n\n  // ============================================================\n  // Insertar imports (después de header / banner)\n  // ============================================================\n  let insertAt = 0;\n  while (insertAt < program.body.length) {\n    var _node$expression;\n    const node = program.body[insertAt];\n    if (node.type === 'ImportDeclaration') break;\n    if (node.type === 'ExpressionStatement' && ((_node$expression = node.expression) === null || _node$expression === void 0 ? void 0 : _node$expression.type) === 'Literal') {\n      insertAt++;\n      continue;\n    }\n    if (node.leadingComments && node.leadingComments.length > 0) {\n      insertAt++;\n      continue;\n    }\n    break;\n  }\n  const importsToInsert = [];\n  for (const imp of desiredImports) {\n    if (!importExists(imp.source.value, imp.specifiers || [])) {\n      importsToInsert.push(imp);\n    }\n  }\n  if (importsToInsert.length > 0) {\n    program.body.splice(insertAt, 0, ...importsToInsert);\n  }\n\n  // ============================================================\n  // Insertar: export var userMode32 = false;\n  // ============================================================\n  if (!exportedVarExists('userMode32')) {\n    const exportedVar = makeExportedVar('userMode32', j.literal(false));\n    let lastImportIndex = -1;\n    program.body.forEach((node, idx) => {\n      if (node.type === 'ImportDeclaration') lastImportIndex = idx;\n    });\n    program.body.splice(lastImportIndex + 1, 0, exportedVar);\n  }\n\n  // ============================================================\n  // Insertar bloque dentro de: return function (Module) { ... }\n  // ============================================================\n  const snippet = `\ndocument.app.$data.is_breakpoint = instructions[0].Break;\nvar pc_sail = crex_findReg_bytag(\"program_counter\");\nvar pc_min = architecture.memory_layout.text.start;\nvar pc_max = architecture.memory_layout.text.end;\nvar hiden_executed, hiden_next_execute;\n\nvar registers_before_function = [\n  { name: \"t0\", can_operate: false },\n  { name: \"t1\", can_operate: false },\n  { name: \"t2\", can_operate: false },\n  { name: \"t3\", can_operate: false },\n  { name: \"t4\", can_operate: false },\n  { name: \"t5\", can_operate: false },\n  { name: \"t6\", can_operate: false },\n  { name: \"s0\", can_operate: false },\n  { name: \"s1\", can_operate: false },\n  { name: \"s2\", can_operate: false },\n  { name: \"s3\", can_operate: false },\n  { name: \"s4\", can_operate: false },\n  { name: \"s5\", can_operate: false },\n  { name: \"s6\", can_operate: false },\n  { name: \"s7\", can_operate: false },\n  { name: \"s8\", can_operate: false },\n  { name: \"s9\", can_operate: false },\n  { name: \"s10\", can_operate: false },\n  { name: \"s11\", can_operate: false }\n];\nvar callstack_convention = [];\nvar inside_function = false;\n`;\n  const snippetStatements = j(snippet).get().node.program.body;\n  function alreadyInserted(body) {\n    return body.some(st => st.type === 'ExpressionStatement' && j(st).toSource().includes('document.app.$data.is_breakpoint'));\n  }\n  root.find(j.ReturnStatement, {\n    argument: {\n      type: 'FunctionExpression'\n    }\n  }).filter(p => {\n    var _fn$params;\n    const fn = p.node.argument;\n    return ((_fn$params = fn.params) === null || _fn$params === void 0 ? void 0 : _fn$params.length) === 1 && fn.params[0].type === 'Identifier' && fn.params[0].name === 'Module';\n  }).forEach(p => {\n    const fn = p.node.argument;\n    if (!alreadyInserted(fn.body.body)) {\n      fn.body.body.unshift(...snippetStatements);\n    }\n  });\n\n  // ============================================================\n  return root.toSource({\n    quote: 'single',\n    trailingComma: true\n  });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ0cmFuc2Zvcm1lciIsImZpbGUiLCJhcGkiLCJqIiwianNjb2Rlc2hpZnQiLCJyb290Iiwic291cmNlIiwicHJvZ3JhbSIsImdldCIsIm5vZGUiLCJub3JtYWxpemVTcGVjaWZpZXJzIiwic3BlY2lmaWVycyIsIm1hcCIsInMiLCJ0eXBlIiwiX3MkaW1wb3J0ZWQiLCJfcyRsb2NhbCIsImltcG9ydGVkIiwibmFtZSIsImxvY2FsIiwiX3MkbG9jYWwyIiwiX3MkbG9jYWwzIiwic29ydCIsImpvaW4iLCJpbXBvcnRFeGlzdHMiLCJtb2R1bGVOYW1lIiwid2FudCIsImZpbmQiLCJJbXBvcnREZWNsYXJhdGlvbiIsInZhbHVlIiwiZmlsdGVyIiwicCIsInNpemUiLCJtYWtlTmFtZWRJbXBvcnQiLCJuYW1lcyIsImltcG9ydERlY2xhcmF0aW9uIiwibiIsImltcG9ydFNwZWNpZmllciIsImlkZW50aWZpZXIiLCJsaXRlcmFsIiwiZXhwb3J0ZWRWYXJFeGlzdHMiLCJFeHBvcnROYW1lZERlY2xhcmF0aW9uIiwiZGVjbCIsImRlY2xhcmF0aW9uIiwiZGVjbGFyYXRpb25zIiwic29tZSIsImQiLCJpZCIsIm1ha2VFeHBvcnRlZFZhciIsImluaXRWYWx1ZSIsImV4cG9ydE5hbWVkRGVjbGFyYXRpb24iLCJ2YXJpYWJsZURlY2xhcmF0aW9uIiwidmFyaWFibGVEZWNsYXJhdG9yIiwiZGVzaXJlZEltcG9ydHMiLCJpbnNlcnRBdCIsImJvZHkiLCJsZW5ndGgiLCJfbm9kZSRleHByZXNzaW9uIiwiZXhwcmVzc2lvbiIsImxlYWRpbmdDb21tZW50cyIsImltcG9ydHNUb0luc2VydCIsImltcCIsInB1c2giLCJzcGxpY2UiLCJleHBvcnRlZFZhciIsImxhc3RJbXBvcnRJbmRleCIsImZvckVhY2giLCJpZHgiLCJzbmlwcGV0Iiwic25pcHBldFN0YXRlbWVudHMiLCJhbHJlYWR5SW5zZXJ0ZWQiLCJzdCIsInRvU291cmNlIiwiaW5jbHVkZXMiLCJSZXR1cm5TdGF0ZW1lbnQiLCJhcmd1bWVudCIsIl9mbiRwYXJhbXMiLCJmbiIsInBhcmFtcyIsInVuc2hpZnQiLCJxdW90ZSIsInRyYWlsaW5nQ29tbWEiXSwic291cmNlUm9vdCI6Ii9ob21lL2p1YW5jYXJsb3MvRXNjcml0b3Jpby9wcnVlYmEvY3JlYXRvci1zYWlsLWV4ZWN1dG9yL2NfZW11bGF0b3IvIiwic291cmNlcyI6WyJ0cmFuc2Zvcm0zMi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0cmFuc2Zvcm0uanNcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zZm9ybWVyKGZpbGUsIGFwaSkge1xuICBjb25zdCBqID0gYXBpLmpzY29kZXNoaWZ0O1xuICBjb25zdCByb290ID0gaihmaWxlLnNvdXJjZSk7XG4gIGNvbnN0IHByb2dyYW0gPSByb290LmdldCgpLm5vZGUucHJvZ3JhbTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gSGVscGVyczogaW1wb3J0c1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgZnVuY3Rpb24gbm9ybWFsaXplU3BlY2lmaWVycyhzcGVjaWZpZXJzID0gW10pIHtcbiAgICByZXR1cm4gc3BlY2lmaWVyc1xuICAgICAgLm1hcCgocykgPT4ge1xuICAgICAgICBpZiAocy50eXBlID09PSAnSW1wb3J0U3BlY2lmaWVyJykge1xuICAgICAgICAgIGNvbnN0IGltcG9ydGVkID0gcy5pbXBvcnRlZD8ubmFtZSB8fCAnJztcbiAgICAgICAgICBjb25zdCBsb2NhbCA9IHMubG9jYWw/Lm5hbWUgfHwgaW1wb3J0ZWQ7XG4gICAgICAgICAgcmV0dXJuIGBuYW1lZDoke2ltcG9ydGVkfT0+JHtsb2NhbH1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLnR5cGUgPT09ICdJbXBvcnREZWZhdWx0U3BlY2lmaWVyJykge1xuICAgICAgICAgIHJldHVybiBgZGVmYXVsdDoke3MubG9jYWw/Lm5hbWUgfHwgJyd9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy50eXBlID09PSAnSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyJykge1xuICAgICAgICAgIHJldHVybiBgbnM6JHtzLmxvY2FsPy5uYW1lIHx8ICcnfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdvdGhlcic7XG4gICAgICB9KVxuICAgICAgLnNvcnQoKVxuICAgICAgLmpvaW4oJ3wnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGltcG9ydEV4aXN0cyhtb2R1bGVOYW1lLCBzcGVjaWZpZXJzKSB7XG4gICAgY29uc3Qgd2FudCA9IG5vcm1hbGl6ZVNwZWNpZmllcnMoc3BlY2lmaWVycyk7XG4gICAgcmV0dXJuIChcbiAgICAgIHJvb3RcbiAgICAgICAgLmZpbmQoai5JbXBvcnREZWNsYXJhdGlvbiwgeyBzb3VyY2U6IHsgdmFsdWU6IG1vZHVsZU5hbWUgfSB9KVxuICAgICAgICAuZmlsdGVyKChwKSA9PiBub3JtYWxpemVTcGVjaWZpZXJzKHAubm9kZS5zcGVjaWZpZXJzKSA9PT0gd2FudClcbiAgICAgICAgLnNpemUoKSA+IDBcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZU5hbWVkSW1wb3J0KG1vZHVsZU5hbWUsIG5hbWVzKSB7XG4gICAgcmV0dXJuIGouaW1wb3J0RGVjbGFyYXRpb24oXG4gICAgICBuYW1lcy5tYXAoKG4pID0+IGouaW1wb3J0U3BlY2lmaWVyKGouaWRlbnRpZmllcihuKSkpLFxuICAgICAgai5saXRlcmFsKG1vZHVsZU5hbWUpXG4gICAgKTtcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBIZWxwZXJzOiBleHBvcnRlZCB2YXJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGZ1bmN0aW9uIGV4cG9ydGVkVmFyRXhpc3RzKG5hbWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgcm9vdFxuICAgICAgICAuZmluZChqLkV4cG9ydE5hbWVkRGVjbGFyYXRpb24pXG4gICAgICAgIC5maWx0ZXIoKHApID0+IHtcbiAgICAgICAgICBjb25zdCBkZWNsID0gcC5ub2RlLmRlY2xhcmF0aW9uO1xuICAgICAgICAgIGlmICghZGVjbCB8fCBkZWNsLnR5cGUgIT09ICdWYXJpYWJsZURlY2xhcmF0aW9uJykgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIHJldHVybiBkZWNsLmRlY2xhcmF0aW9ucy5zb21lKFxuICAgICAgICAgICAgKGQpID0+IGQuaWQudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmIGQuaWQubmFtZSA9PT0gbmFtZVxuICAgICAgICAgICk7XG4gICAgICAgIH0pXG4gICAgICAgIC5zaXplKCkgPiAwXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VFeHBvcnRlZFZhcihuYW1lLCBpbml0VmFsdWUpIHtcbiAgICByZXR1cm4gai5leHBvcnROYW1lZERlY2xhcmF0aW9uKFxuICAgICAgai52YXJpYWJsZURlY2xhcmF0aW9uKCd2YXInLCBbXG4gICAgICAgIGoudmFyaWFibGVEZWNsYXJhdG9yKGouaWRlbnRpZmllcihuYW1lKSwgaW5pdFZhbHVlKSxcbiAgICAgIF0pLFxuICAgICAgW11cbiAgICApO1xuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEltcG9ydHMgRVhBQ1RPUyBhIGluc2VydGFyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBjb25zdCBkZXNpcmVkSW1wb3J0cyA9IFtcbiAgICBtYWtlTmFtZWRJbXBvcnQoJ0AvY29yZS9hc3NlbWJsZXIvYXNzZW1ibGVyLm1qcycsIFtcbiAgICAgICdpbnN0cnVjdGlvbnMnLFxuICAgICAgJ3RhZ19pbnN0cnVjdGlvbnMnLFxuICAgIF0pLFxuICAgIG1ha2VOYW1lZEltcG9ydCgnQC9jb3JlL3JlZ2lzdGVyL3JlZ2lzdGVyT3BlcmF0aW9ucy5tanMnLCBbXG4gICAgICAncmVhZFJlZ2lzdGVyJyxcbiAgICAgICd3cml0ZVJlZ2lzdGVyJyxcbiAgICAgICdub3RpZnlSZWdpc3RlclVwZGF0ZScsXG4gICAgXSksXG4gICAgbWFrZU5hbWVkSW1wb3J0KCdAL2NvcmUvcmVnaXN0ZXIvcmVnaXN0ZXJMb29rdXAubWpzJywgW1xuICAgICAgJ2NyZXhfZmluZFJlZ19ieXRhZycsXG4gICAgICAnY3JleF9maW5kUmVnJyxcbiAgICBdKSxcbiAgICBtYWtlTmFtZWRJbXBvcnQoJ0AvY29yZS9jb3JlLm1qcycsIFtcbiAgICAgICdzdGF0dXMnLFxuICAgICAgJ3NldF9leGVjdXRpb25fbW9kZScsXG4gICAgICAnUENfUkVHX0lOREVYJyxcbiAgICAgICdSRUdJU1RFUlMnLFxuICAgICAgJ2dldFBDJyxcbiAgICAgICdtYWluX21lbW9yeScsXG4gICAgICAnY29uZmlnX2NhY2hlJyxcbiAgICAgICdMMV9jYWNoZV9tZW1vcnknLFxuICAgICAgJ0wxX0lfY2FjaGVfbWVtb3J5JyxcbiAgICAgICdMMV9EX2NhY2hlX21lbW9yeScsXG4gICAgICAnTDJfRF9jYWNoZV9tZW1vcnknLFxuICAgICAgJ0wyX0lfY2FjaGVfbWVtb3J5JyxcbiAgICAgICdMMl9jYWNoZV9tZW1vcnknLFxuICAgICAgJ3VwZGF0ZUNhY2hlTWVtJyxcbiAgICBdKSxcbiAgICBtYWtlTmFtZWRJbXBvcnQoJ0AvY29yZS9hc3NlbWJsZXIvYXNzZW1ibGVyLm1qcycsIFsnc2V0SW5zdHJ1Y3Rpb25zJ10pLFxuICAgIG1ha2VOYW1lZEltcG9ydCgnLi4vLi4vSU8ubWpzJywgWydkaXNwbGF5X3ByaW50J10pLFxuICAgIG1ha2VOYW1lZEltcG9ydCgnQC9jb3JlL2NhcGkvc3lzY2FsbC5tdHMnLCBbJ1NZU0NBTEwnXSksXG4gICAgbWFrZU5hbWVkSW1wb3J0KCdAL2NvcmUvZXZlbnRzLm10cycsIFsnY29yZUV2ZW50cyddKSxcbiAgICBtYWtlTmFtZWRJbXBvcnQoJ0Avd2ViL3V0aWxzLm1qcycsIFsnc2hvd19ub3RpZmljYXRpb24nXSksXG4gICAgbWFrZU5hbWVkSW1wb3J0KCdAL3dlYi91dGlscy5tanMnLCBbXG4gICAgICAncmVzZXRfZGlzYWJsZScsXG4gICAgICAnaW5zdHJ1Y3Rpb25fZGlzYWJsZScsXG4gICAgICAncnVuX2Rpc2FibGUnLFxuICAgICAgJ3N0b3BfZGlzYWJsZScsXG4gICAgICAnaXNGaW5pc2hlZCcsXG4gICAgXSksXG4gICAgbWFrZU5hbWVkSW1wb3J0KCcuLi8uLi8uLi9jb3JlLm1qcycsIFsnYXJjaGl0ZWN0dXJlJ10pLFxuICAgIG1ha2VOYW1lZEltcG9ydCgnQC9jb3JlL3JlZ2lzdGVyL3JlZ2lzdGVyR2xvd1N0YXRlLm1qcycsIFtcbiAgICAgICdjbGVhckFsbFJlZ2lzdGVyR2xvd3MnLFxuICAgIF0pLFxuICBdO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBJbnNlcnRhciBpbXBvcnRzIChkZXNwdcOpcyBkZSBoZWFkZXIgLyBiYW5uZXIpXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBsZXQgaW5zZXJ0QXQgPSAwO1xuICB3aGlsZSAoaW5zZXJ0QXQgPCBwcm9ncmFtLmJvZHkubGVuZ3RoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHByb2dyYW0uYm9keVtpbnNlcnRBdF07XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ0ltcG9ydERlY2xhcmF0aW9uJykgYnJlYWs7XG4gICAgaWYgKFxuICAgICAgbm9kZS50eXBlID09PSAnRXhwcmVzc2lvblN0YXRlbWVudCcgJiZcbiAgICAgIG5vZGUuZXhwcmVzc2lvbj8udHlwZSA9PT0gJ0xpdGVyYWwnXG4gICAgKSB7XG4gICAgICBpbnNlcnRBdCsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChub2RlLmxlYWRpbmdDb21tZW50cyAmJiBub2RlLmxlYWRpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBpbnNlcnRBdCsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgY29uc3QgaW1wb3J0c1RvSW5zZXJ0ID0gW107XG4gIGZvciAoY29uc3QgaW1wIG9mIGRlc2lyZWRJbXBvcnRzKSB7XG4gICAgaWYgKCFpbXBvcnRFeGlzdHMoaW1wLnNvdXJjZS52YWx1ZSwgaW1wLnNwZWNpZmllcnMgfHwgW10pKSB7XG4gICAgICBpbXBvcnRzVG9JbnNlcnQucHVzaChpbXApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbXBvcnRzVG9JbnNlcnQubGVuZ3RoID4gMCkge1xuICAgIHByb2dyYW0uYm9keS5zcGxpY2UoaW5zZXJ0QXQsIDAsIC4uLmltcG9ydHNUb0luc2VydCk7XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gSW5zZXJ0YXI6IGV4cG9ydCB2YXIgdXNlck1vZGUzMiA9IGZhbHNlO1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgaWYgKCFleHBvcnRlZFZhckV4aXN0cygndXNlck1vZGUzMicpKSB7XG4gICAgY29uc3QgZXhwb3J0ZWRWYXIgPSBtYWtlRXhwb3J0ZWRWYXIoJ3VzZXJNb2RlMzInLCBqLmxpdGVyYWwoZmFsc2UpKTtcblxuICAgIGxldCBsYXN0SW1wb3J0SW5kZXggPSAtMTtcbiAgICBwcm9ncmFtLmJvZHkuZm9yRWFjaCgobm9kZSwgaWR4KSA9PiB7XG4gICAgICBpZiAobm9kZS50eXBlID09PSAnSW1wb3J0RGVjbGFyYXRpb24nKSBsYXN0SW1wb3J0SW5kZXggPSBpZHg7XG4gICAgfSk7XG5cbiAgICBwcm9ncmFtLmJvZHkuc3BsaWNlKGxhc3RJbXBvcnRJbmRleCArIDEsIDAsIGV4cG9ydGVkVmFyKTtcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBJbnNlcnRhciBibG9xdWUgZGVudHJvIGRlOiByZXR1cm4gZnVuY3Rpb24gKE1vZHVsZSkgeyAuLi4gfVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgY29uc3Qgc25pcHBldCA9IGBcbmRvY3VtZW50LmFwcC4kZGF0YS5pc19icmVha3BvaW50ID0gaW5zdHJ1Y3Rpb25zWzBdLkJyZWFrO1xudmFyIHBjX3NhaWwgPSBjcmV4X2ZpbmRSZWdfYnl0YWcoXCJwcm9ncmFtX2NvdW50ZXJcIik7XG52YXIgcGNfbWluID0gYXJjaGl0ZWN0dXJlLm1lbW9yeV9sYXlvdXQudGV4dC5zdGFydDtcbnZhciBwY19tYXggPSBhcmNoaXRlY3R1cmUubWVtb3J5X2xheW91dC50ZXh0LmVuZDtcbnZhciBoaWRlbl9leGVjdXRlZCwgaGlkZW5fbmV4dF9leGVjdXRlO1xuXG52YXIgcmVnaXN0ZXJzX2JlZm9yZV9mdW5jdGlvbiA9IFtcbiAgeyBuYW1lOiBcInQwXCIsIGNhbl9vcGVyYXRlOiBmYWxzZSB9LFxuICB7IG5hbWU6IFwidDFcIiwgY2FuX29wZXJhdGU6IGZhbHNlIH0sXG4gIHsgbmFtZTogXCJ0MlwiLCBjYW5fb3BlcmF0ZTogZmFsc2UgfSxcbiAgeyBuYW1lOiBcInQzXCIsIGNhbl9vcGVyYXRlOiBmYWxzZSB9LFxuICB7IG5hbWU6IFwidDRcIiwgY2FuX29wZXJhdGU6IGZhbHNlIH0sXG4gIHsgbmFtZTogXCJ0NVwiLCBjYW5fb3BlcmF0ZTogZmFsc2UgfSxcbiAgeyBuYW1lOiBcInQ2XCIsIGNhbl9vcGVyYXRlOiBmYWxzZSB9LFxuICB7IG5hbWU6IFwiczBcIiwgY2FuX29wZXJhdGU6IGZhbHNlIH0sXG4gIHsgbmFtZTogXCJzMVwiLCBjYW5fb3BlcmF0ZTogZmFsc2UgfSxcbiAgeyBuYW1lOiBcInMyXCIsIGNhbl9vcGVyYXRlOiBmYWxzZSB9LFxuICB7IG5hbWU6IFwiczNcIiwgY2FuX29wZXJhdGU6IGZhbHNlIH0sXG4gIHsgbmFtZTogXCJzNFwiLCBjYW5fb3BlcmF0ZTogZmFsc2UgfSxcbiAgeyBuYW1lOiBcInM1XCIsIGNhbl9vcGVyYXRlOiBmYWxzZSB9LFxuICB7IG5hbWU6IFwiczZcIiwgY2FuX29wZXJhdGU6IGZhbHNlIH0sXG4gIHsgbmFtZTogXCJzN1wiLCBjYW5fb3BlcmF0ZTogZmFsc2UgfSxcbiAgeyBuYW1lOiBcInM4XCIsIGNhbl9vcGVyYXRlOiBmYWxzZSB9LFxuICB7IG5hbWU6IFwiczlcIiwgY2FuX29wZXJhdGU6IGZhbHNlIH0sXG4gIHsgbmFtZTogXCJzMTBcIiwgY2FuX29wZXJhdGU6IGZhbHNlIH0sXG4gIHsgbmFtZTogXCJzMTFcIiwgY2FuX29wZXJhdGU6IGZhbHNlIH1cbl07XG52YXIgY2FsbHN0YWNrX2NvbnZlbnRpb24gPSBbXTtcbnZhciBpbnNpZGVfZnVuY3Rpb24gPSBmYWxzZTtcbmA7XG5cbiAgY29uc3Qgc25pcHBldFN0YXRlbWVudHMgPSBqKHNuaXBwZXQpLmdldCgpLm5vZGUucHJvZ3JhbS5ib2R5O1xuXG4gIGZ1bmN0aW9uIGFscmVhZHlJbnNlcnRlZChib2R5KSB7XG4gICAgcmV0dXJuIGJvZHkuc29tZShcbiAgICAgIChzdCkgPT5cbiAgICAgICAgc3QudHlwZSA9PT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnICYmXG4gICAgICAgIGooc3QpLnRvU291cmNlKCkuaW5jbHVkZXMoJ2RvY3VtZW50LmFwcC4kZGF0YS5pc19icmVha3BvaW50JylcbiAgICApO1xuICB9XG5cbiAgcm9vdFxuICAgIC5maW5kKGouUmV0dXJuU3RhdGVtZW50LCB7IGFyZ3VtZW50OiB7IHR5cGU6ICdGdW5jdGlvbkV4cHJlc3Npb24nIH0gfSlcbiAgICAuZmlsdGVyKChwKSA9PiB7XG4gICAgICBjb25zdCBmbiA9IHAubm9kZS5hcmd1bWVudDtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGZuLnBhcmFtcz8ubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGZuLnBhcmFtc1swXS50eXBlID09PSAnSWRlbnRpZmllcicgJiZcbiAgICAgICAgZm4ucGFyYW1zWzBdLm5hbWUgPT09ICdNb2R1bGUnXG4gICAgICApO1xuICAgIH0pXG4gICAgLmZvckVhY2goKHApID0+IHtcbiAgICAgIGNvbnN0IGZuID0gcC5ub2RlLmFyZ3VtZW50O1xuICAgICAgaWYgKCFhbHJlYWR5SW5zZXJ0ZWQoZm4uYm9keS5ib2R5KSkge1xuICAgICAgICBmbi5ib2R5LmJvZHkudW5zaGlmdCguLi5zbmlwcGV0U3RhdGVtZW50cyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHJldHVybiByb290LnRvU291cmNlKHsgcXVvdGU6ICdzaW5nbGUnLCB0cmFpbGluZ0NvbW1hOiB0cnVlIH0pO1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNlLFNBQVNBLFdBQVdBLENBQUNDLElBQUksRUFBRUMsR0FBRyxFQUFFO0VBQzdDLE1BQU1DLENBQUMsR0FBR0QsR0FBRyxDQUFDRSxXQUFXO0VBQ3pCLE1BQU1DLElBQUksR0FBR0YsQ0FBQyxDQUFDRixJQUFJLENBQUNLLE1BQU0sQ0FBQztFQUMzQixNQUFNQyxPQUFPLEdBQUdGLElBQUksQ0FBQ0csR0FBRyxDQUFDLENBQUMsQ0FBQ0MsSUFBSSxDQUFDRixPQUFPOztFQUV2QztFQUNBO0VBQ0E7RUFDQSxTQUFTRyxtQkFBbUJBLENBQUNDLFVBQVUsR0FBRyxFQUFFLEVBQUU7SUFDNUMsT0FBT0EsVUFBVSxDQUNkQyxHQUFHLENBQUVDLENBQUMsSUFBSztNQUNWLElBQUlBLENBQUMsQ0FBQ0MsSUFBSSxLQUFLLGlCQUFpQixFQUFFO1FBQUEsSUFBQUMsV0FBQSxFQUFBQyxRQUFBO1FBQ2hDLE1BQU1DLFFBQVEsR0FBRyxFQUFBRixXQUFBLEdBQUFGLENBQUMsQ0FBQ0ksUUFBUSxjQUFBRixXQUFBLHVCQUFWQSxXQUFBLENBQVlHLElBQUksS0FBSSxFQUFFO1FBQ3ZDLE1BQU1DLEtBQUssR0FBRyxFQUFBSCxRQUFBLEdBQUFILENBQUMsQ0FBQ00sS0FBSyxjQUFBSCxRQUFBLHVCQUFQQSxRQUFBLENBQVNFLElBQUksS0FBSUQsUUFBUTtRQUN2QyxPQUFPLFNBQVNBLFFBQVEsS0FBS0UsS0FBSyxFQUFFO01BQ3RDO01BQ0EsSUFBSU4sQ0FBQyxDQUFDQyxJQUFJLEtBQUssd0JBQXdCLEVBQUU7UUFBQSxJQUFBTSxTQUFBO1FBQ3ZDLE9BQU8sV0FBVyxFQUFBQSxTQUFBLEdBQUFQLENBQUMsQ0FBQ00sS0FBSyxjQUFBQyxTQUFBLHVCQUFQQSxTQUFBLENBQVNGLElBQUksS0FBSSxFQUFFLEVBQUU7TUFDekM7TUFDQSxJQUFJTCxDQUFDLENBQUNDLElBQUksS0FBSywwQkFBMEIsRUFBRTtRQUFBLElBQUFPLFNBQUE7UUFDekMsT0FBTyxNQUFNLEVBQUFBLFNBQUEsR0FBQVIsQ0FBQyxDQUFDTSxLQUFLLGNBQUFFLFNBQUEsdUJBQVBBLFNBQUEsQ0FBU0gsSUFBSSxLQUFJLEVBQUUsRUFBRTtNQUNwQztNQUNBLE9BQU8sT0FBTztJQUNoQixDQUFDLENBQUMsQ0FDREksSUFBSSxDQUFDLENBQUMsQ0FDTkMsSUFBSSxDQUFDLEdBQUcsQ0FBQztFQUNkO0VBRUEsU0FBU0MsWUFBWUEsQ0FBQ0MsVUFBVSxFQUFFZCxVQUFVLEVBQUU7SUFDNUMsTUFBTWUsSUFBSSxHQUFHaEIsbUJBQW1CLENBQUNDLFVBQVUsQ0FBQztJQUM1QyxPQUNFTixJQUFJLENBQ0RzQixJQUFJLENBQUN4QixDQUFDLENBQUN5QixpQkFBaUIsRUFBRTtNQUFFdEIsTUFBTSxFQUFFO1FBQUV1QixLQUFLLEVBQUVKO01BQVc7SUFBRSxDQUFDLENBQUMsQ0FDNURLLE1BQU0sQ0FBRUMsQ0FBQyxJQUFLckIsbUJBQW1CLENBQUNxQixDQUFDLENBQUN0QixJQUFJLENBQUNFLFVBQVUsQ0FBQyxLQUFLZSxJQUFJLENBQUMsQ0FDOURNLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQztFQUVqQjtFQUVBLFNBQVNDLGVBQWVBLENBQUNSLFVBQVUsRUFBRVMsS0FBSyxFQUFFO0lBQzFDLE9BQU8vQixDQUFDLENBQUNnQyxpQkFBaUIsQ0FDeEJELEtBQUssQ0FBQ3RCLEdBQUcsQ0FBRXdCLENBQUMsSUFBS2pDLENBQUMsQ0FBQ2tDLGVBQWUsQ0FBQ2xDLENBQUMsQ0FBQ21DLFVBQVUsQ0FBQ0YsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUNwRGpDLENBQUMsQ0FBQ29DLE9BQU8sQ0FBQ2QsVUFBVSxDQUN0QixDQUFDO0VBQ0g7O0VBRUE7RUFDQTtFQUNBO0VBQ0EsU0FBU2UsaUJBQWlCQSxDQUFDdEIsSUFBSSxFQUFFO0lBQy9CLE9BQ0ViLElBQUksQ0FDRHNCLElBQUksQ0FBQ3hCLENBQUMsQ0FBQ3NDLHNCQUFzQixDQUFDLENBQzlCWCxNQUFNLENBQUVDLENBQUMsSUFBSztNQUNiLE1BQU1XLElBQUksR0FBR1gsQ0FBQyxDQUFDdEIsSUFBSSxDQUFDa0MsV0FBVztNQUMvQixJQUFJLENBQUNELElBQUksSUFBSUEsSUFBSSxDQUFDNUIsSUFBSSxLQUFLLHFCQUFxQixFQUFFLE9BQU8sS0FBSztNQUM5RCxPQUFPNEIsSUFBSSxDQUFDRSxZQUFZLENBQUNDLElBQUksQ0FDMUJDLENBQUMsSUFBS0EsQ0FBQyxDQUFDQyxFQUFFLENBQUNqQyxJQUFJLEtBQUssWUFBWSxJQUFJZ0MsQ0FBQyxDQUFDQyxFQUFFLENBQUM3QixJQUFJLEtBQUtBLElBQ3JELENBQUM7SUFDSCxDQUFDLENBQUMsQ0FDRGMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDO0VBRWpCO0VBRUEsU0FBU2dCLGVBQWVBLENBQUM5QixJQUFJLEVBQUUrQixTQUFTLEVBQUU7SUFDeEMsT0FBTzlDLENBQUMsQ0FBQytDLHNCQUFzQixDQUM3Qi9DLENBQUMsQ0FBQ2dELG1CQUFtQixDQUFDLEtBQUssRUFBRSxDQUMzQmhELENBQUMsQ0FBQ2lELGtCQUFrQixDQUFDakQsQ0FBQyxDQUFDbUMsVUFBVSxDQUFDcEIsSUFBSSxDQUFDLEVBQUUrQixTQUFTLENBQUMsQ0FDcEQsQ0FBQyxFQUNGLEVBQ0YsQ0FBQztFQUNIOztFQUVBO0VBQ0E7RUFDQTtFQUNBLE1BQU1JLGNBQWMsR0FBRyxDQUNyQnBCLGVBQWUsQ0FBQyxnQ0FBZ0MsRUFBRSxDQUNoRCxjQUFjLEVBQ2Qsa0JBQWtCLENBQ25CLENBQUMsRUFDRkEsZUFBZSxDQUFDLHdDQUF3QyxFQUFFLENBQ3hELGNBQWMsRUFDZCxlQUFlLEVBQ2Ysc0JBQXNCLENBQ3ZCLENBQUMsRUFDRkEsZUFBZSxDQUFDLG9DQUFvQyxFQUFFLENBQ3BELG9CQUFvQixFQUNwQixjQUFjLENBQ2YsQ0FBQyxFQUNGQSxlQUFlLENBQUMsaUJBQWlCLEVBQUUsQ0FDakMsUUFBUSxFQUNSLG9CQUFvQixFQUNwQixjQUFjLEVBQ2QsV0FBVyxFQUNYLE9BQU8sRUFDUCxhQUFhLEVBQ2IsY0FBYyxFQUNkLGlCQUFpQixFQUNqQixtQkFBbUIsRUFDbkIsbUJBQW1CLEVBQ25CLG1CQUFtQixFQUNuQixtQkFBbUIsRUFDbkIsaUJBQWlCLEVBQ2pCLGdCQUFnQixDQUNqQixDQUFDLEVBQ0ZBLGVBQWUsQ0FBQyxnQ0FBZ0MsRUFBRSxDQUFDLGlCQUFpQixDQUFDLENBQUMsRUFDdEVBLGVBQWUsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxlQUFlLENBQUMsQ0FBQyxFQUNsREEsZUFBZSxDQUFDLHlCQUF5QixFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsRUFDdkRBLGVBQWUsQ0FBQyxtQkFBbUIsRUFBRSxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQ3BEQSxlQUFlLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLEVBQ3pEQSxlQUFlLENBQUMsaUJBQWlCLEVBQUUsQ0FDakMsZUFBZSxFQUNmLHFCQUFxQixFQUNyQixhQUFhLEVBQ2IsY0FBYyxFQUNkLFlBQVksQ0FDYixDQUFDLEVBQ0ZBLGVBQWUsQ0FBQyxtQkFBbUIsRUFBRSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEVBQ3REQSxlQUFlLENBQUMsdUNBQXVDLEVBQUUsQ0FDdkQsdUJBQXVCLENBQ3hCLENBQUMsQ0FDSDs7RUFFRDtFQUNBO0VBQ0E7RUFDQSxJQUFJcUIsUUFBUSxHQUFHLENBQUM7RUFDaEIsT0FBT0EsUUFBUSxHQUFHL0MsT0FBTyxDQUFDZ0QsSUFBSSxDQUFDQyxNQUFNLEVBQUU7SUFBQSxJQUFBQyxnQkFBQTtJQUNyQyxNQUFNaEQsSUFBSSxHQUFHRixPQUFPLENBQUNnRCxJQUFJLENBQUNELFFBQVEsQ0FBQztJQUNuQyxJQUFJN0MsSUFBSSxDQUFDSyxJQUFJLEtBQUssbUJBQW1CLEVBQUU7SUFDdkMsSUFDRUwsSUFBSSxDQUFDSyxJQUFJLEtBQUsscUJBQXFCLElBQ25DLEVBQUEyQyxnQkFBQSxHQUFBaEQsSUFBSSxDQUFDaUQsVUFBVSxjQUFBRCxnQkFBQSx1QkFBZkEsZ0JBQUEsQ0FBaUIzQyxJQUFJLE1BQUssU0FBUyxFQUNuQztNQUNBd0MsUUFBUSxFQUFFO01BQ1Y7SUFDRjtJQUNBLElBQUk3QyxJQUFJLENBQUNrRCxlQUFlLElBQUlsRCxJQUFJLENBQUNrRCxlQUFlLENBQUNILE1BQU0sR0FBRyxDQUFDLEVBQUU7TUFDM0RGLFFBQVEsRUFBRTtNQUNWO0lBQ0Y7SUFDQTtFQUNGO0VBRUEsTUFBTU0sZUFBZSxHQUFHLEVBQUU7RUFDMUIsS0FBSyxNQUFNQyxHQUFHLElBQUlSLGNBQWMsRUFBRTtJQUNoQyxJQUFJLENBQUM3QixZQUFZLENBQUNxQyxHQUFHLENBQUN2RCxNQUFNLENBQUN1QixLQUFLLEVBQUVnQyxHQUFHLENBQUNsRCxVQUFVLElBQUksRUFBRSxDQUFDLEVBQUU7TUFDekRpRCxlQUFlLENBQUNFLElBQUksQ0FBQ0QsR0FBRyxDQUFDO0lBQzNCO0VBQ0Y7RUFFQSxJQUFJRCxlQUFlLENBQUNKLE1BQU0sR0FBRyxDQUFDLEVBQUU7SUFDOUJqRCxPQUFPLENBQUNnRCxJQUFJLENBQUNRLE1BQU0sQ0FBQ1QsUUFBUSxFQUFFLENBQUMsRUFBRSxHQUFHTSxlQUFlLENBQUM7RUFDdEQ7O0VBRUE7RUFDQTtFQUNBO0VBQ0EsSUFBSSxDQUFDcEIsaUJBQWlCLENBQUMsWUFBWSxDQUFDLEVBQUU7SUFDcEMsTUFBTXdCLFdBQVcsR0FBR2hCLGVBQWUsQ0FBQyxZQUFZLEVBQUU3QyxDQUFDLENBQUNvQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7SUFFbkUsSUFBSTBCLGVBQWUsR0FBRyxDQUFDLENBQUM7SUFDeEIxRCxPQUFPLENBQUNnRCxJQUFJLENBQUNXLE9BQU8sQ0FBQyxDQUFDekQsSUFBSSxFQUFFMEQsR0FBRyxLQUFLO01BQ2xDLElBQUkxRCxJQUFJLENBQUNLLElBQUksS0FBSyxtQkFBbUIsRUFBRW1ELGVBQWUsR0FBR0UsR0FBRztJQUM5RCxDQUFDLENBQUM7SUFFRjVELE9BQU8sQ0FBQ2dELElBQUksQ0FBQ1EsTUFBTSxDQUFDRSxlQUFlLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRUQsV0FBVyxDQUFDO0VBQzFEOztFQUVBO0VBQ0E7RUFDQTtFQUNBLE1BQU1JLE9BQU8sR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztFQUVDLE1BQU1DLGlCQUFpQixHQUFHbEUsQ0FBQyxDQUFDaUUsT0FBTyxDQUFDLENBQUM1RCxHQUFHLENBQUMsQ0FBQyxDQUFDQyxJQUFJLENBQUNGLE9BQU8sQ0FBQ2dELElBQUk7RUFFNUQsU0FBU2UsZUFBZUEsQ0FBQ2YsSUFBSSxFQUFFO0lBQzdCLE9BQU9BLElBQUksQ0FBQ1YsSUFBSSxDQUNiMEIsRUFBRSxJQUNEQSxFQUFFLENBQUN6RCxJQUFJLEtBQUsscUJBQXFCLElBQ2pDWCxDQUFDLENBQUNvRSxFQUFFLENBQUMsQ0FBQ0MsUUFBUSxDQUFDLENBQUMsQ0FBQ0MsUUFBUSxDQUFDLGtDQUFrQyxDQUNoRSxDQUFDO0VBQ0g7RUFFQXBFLElBQUksQ0FDRHNCLElBQUksQ0FBQ3hCLENBQUMsQ0FBQ3VFLGVBQWUsRUFBRTtJQUFFQyxRQUFRLEVBQUU7TUFBRTdELElBQUksRUFBRTtJQUFxQjtFQUFFLENBQUMsQ0FBQyxDQUNyRWdCLE1BQU0sQ0FBRUMsQ0FBQyxJQUFLO0lBQUEsSUFBQTZDLFVBQUE7SUFDYixNQUFNQyxFQUFFLEdBQUc5QyxDQUFDLENBQUN0QixJQUFJLENBQUNrRSxRQUFRO0lBQzFCLE9BQ0UsRUFBQUMsVUFBQSxHQUFBQyxFQUFFLENBQUNDLE1BQU0sY0FBQUYsVUFBQSx1QkFBVEEsVUFBQSxDQUFXcEIsTUFBTSxNQUFLLENBQUMsSUFDdkJxQixFQUFFLENBQUNDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQ2hFLElBQUksS0FBSyxZQUFZLElBQ2xDK0QsRUFBRSxDQUFDQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM1RCxJQUFJLEtBQUssUUFBUTtFQUVsQyxDQUFDLENBQUMsQ0FDRGdELE9BQU8sQ0FBRW5DLENBQUMsSUFBSztJQUNkLE1BQU04QyxFQUFFLEdBQUc5QyxDQUFDLENBQUN0QixJQUFJLENBQUNrRSxRQUFRO0lBQzFCLElBQUksQ0FBQ0wsZUFBZSxDQUFDTyxFQUFFLENBQUN0QixJQUFJLENBQUNBLElBQUksQ0FBQyxFQUFFO01BQ2xDc0IsRUFBRSxDQUFDdEIsSUFBSSxDQUFDQSxJQUFJLENBQUN3QixPQUFPLENBQUMsR0FBR1YsaUJBQWlCLENBQUM7SUFDNUM7RUFDRixDQUFDLENBQUM7O0VBRUo7RUFDQSxPQUFPaEUsSUFBSSxDQUFDbUUsUUFBUSxDQUFDO0lBQUVRLEtBQUssRUFBRSxRQUFRO0lBQUVDLGFBQWEsRUFBRTtFQUFLLENBQUMsQ0FBQztBQUNoRSIsImlnbm9yZUxpc3QiOltdfQ==","map":{"version":3,"names":["transformer","file","api","j","jscodeshift","root","source","program","get","node","normalizeSpecifiers","specifiers","map","s","type","_s$imported","_s$local","imported","name","local","_s$local2","_s$local3","sort","join","importExists","moduleName","want","find","ImportDeclaration","value","filter","p","size","makeNamedImport","names","importDeclaration","n","importSpecifier","identifier","literal","exportedVarExists","ExportNamedDeclaration","decl","declaration","declarations","some","d","id","makeExportedVar","initValue","exportNamedDeclaration","variableDeclaration","variableDeclarator","desiredImports","insertAt","body","length","_node$expression","expression","leadingComments","importsToInsert","imp","push","splice","exportedVar","lastImportIndex","forEach","idx","snippet","snippetStatements","alreadyInserted","st","toSource","includes","ReturnStatement","argument","_fn$params","fn","params","unshift","quote","trailingComma"],"sourceRoot":"/home/juancarlos/Escritorio/prueba/creator-sail-executor/c_emulator/","sources":["transform32.js"],"sourcesContent":["// transform.js\nexport default function transformer(file, api) {\n  const j = api.jscodeshift;\n  const root = j(file.source);\n  const program = root.get().node.program;\n\n  // ============================================================\n  // Helpers: imports\n  // ============================================================\n  function normalizeSpecifiers(specifiers = []) {\n    return specifiers\n      .map((s) => {\n        if (s.type === 'ImportSpecifier') {\n          const imported = s.imported?.name || '';\n          const local = s.local?.name || imported;\n          return `named:${imported}=>${local}`;\n        }\n        if (s.type === 'ImportDefaultSpecifier') {\n          return `default:${s.local?.name || ''}`;\n        }\n        if (s.type === 'ImportNamespaceSpecifier') {\n          return `ns:${s.local?.name || ''}`;\n        }\n        return 'other';\n      })\n      .sort()\n      .join('|');\n  }\n\n  function importExists(moduleName, specifiers) {\n    const want = normalizeSpecifiers(specifiers);\n    return (\n      root\n        .find(j.ImportDeclaration, { source: { value: moduleName } })\n        .filter((p) => normalizeSpecifiers(p.node.specifiers) === want)\n        .size() > 0\n    );\n  }\n\n  function makeNamedImport(moduleName, names) {\n    return j.importDeclaration(\n      names.map((n) => j.importSpecifier(j.identifier(n))),\n      j.literal(moduleName)\n    );\n  }\n\n  // ============================================================\n  // Helpers: exported var\n  // ============================================================\n  function exportedVarExists(name) {\n    return (\n      root\n        .find(j.ExportNamedDeclaration)\n        .filter((p) => {\n          const decl = p.node.declaration;\n          if (!decl || decl.type !== 'VariableDeclaration') return false;\n          return decl.declarations.some(\n            (d) => d.id.type === 'Identifier' && d.id.name === name\n          );\n        })\n        .size() > 0\n    );\n  }\n\n  function makeExportedVar(name, initValue) {\n    return j.exportNamedDeclaration(\n      j.variableDeclaration('var', [\n        j.variableDeclarator(j.identifier(name), initValue),\n      ]),\n      []\n    );\n  }\n\n  // ============================================================\n  // Imports EXACTOS a insertar\n  // ============================================================\n  const desiredImports = [\n    makeNamedImport('@/core/assembler/assembler.mjs', [\n      'instructions',\n      'tag_instructions',\n    ]),\n    makeNamedImport('@/core/register/registerOperations.mjs', [\n      'readRegister',\n      'writeRegister',\n      'notifyRegisterUpdate',\n    ]),\n    makeNamedImport('@/core/register/registerLookup.mjs', [\n      'crex_findReg_bytag',\n      'crex_findReg',\n    ]),\n    makeNamedImport('@/core/core.mjs', [\n      'status',\n      'set_execution_mode',\n      'PC_REG_INDEX',\n      'REGISTERS',\n      'getPC',\n      'main_memory',\n      'config_cache',\n      'L1_cache_memory',\n      'L1_I_cache_memory',\n      'L1_D_cache_memory',\n      'L2_D_cache_memory',\n      'L2_I_cache_memory',\n      'L2_cache_memory',\n      'updateCacheMem',\n    ]),\n    makeNamedImport('@/core/assembler/assembler.mjs', ['setInstructions']),\n    makeNamedImport('../../IO.mjs', ['display_print']),\n    makeNamedImport('@/core/capi/syscall.mts', ['SYSCALL']),\n    makeNamedImport('@/core/events.mts', ['coreEvents']),\n    makeNamedImport('@/web/utils.mjs', ['show_notification']),\n    makeNamedImport('@/web/utils.mjs', [\n      'reset_disable',\n      'instruction_disable',\n      'run_disable',\n      'stop_disable',\n      'isFinished',\n    ]),\n    makeNamedImport('../../../core.mjs', ['architecture']),\n    makeNamedImport('@/core/register/registerGlowState.mjs', [\n      'clearAllRegisterGlows',\n    ]),\n  ];\n\n  // ============================================================\n  // Insertar imports (después de header / banner)\n  // ============================================================\n  let insertAt = 0;\n  while (insertAt < program.body.length) {\n    const node = program.body[insertAt];\n    if (node.type === 'ImportDeclaration') break;\n    if (\n      node.type === 'ExpressionStatement' &&\n      node.expression?.type === 'Literal'\n    ) {\n      insertAt++;\n      continue;\n    }\n    if (node.leadingComments && node.leadingComments.length > 0) {\n      insertAt++;\n      continue;\n    }\n    break;\n  }\n\n  const importsToInsert = [];\n  for (const imp of desiredImports) {\n    if (!importExists(imp.source.value, imp.specifiers || [])) {\n      importsToInsert.push(imp);\n    }\n  }\n\n  if (importsToInsert.length > 0) {\n    program.body.splice(insertAt, 0, ...importsToInsert);\n  }\n\n  // ============================================================\n  // Insertar: export var userMode32 = false;\n  // ============================================================\n  if (!exportedVarExists('userMode32')) {\n    const exportedVar = makeExportedVar('userMode32', j.literal(false));\n\n    let lastImportIndex = -1;\n    program.body.forEach((node, idx) => {\n      if (node.type === 'ImportDeclaration') lastImportIndex = idx;\n    });\n\n    program.body.splice(lastImportIndex + 1, 0, exportedVar);\n  }\n\n  // ============================================================\n  // Insertar bloque dentro de: return function (Module) { ... }\n  // ============================================================\n  const snippet = `\ndocument.app.$data.is_breakpoint = instructions[0].Break;\nvar pc_sail = crex_findReg_bytag(\"program_counter\");\nvar pc_min = architecture.memory_layout.text.start;\nvar pc_max = architecture.memory_layout.text.end;\nvar hiden_executed, hiden_next_execute;\n\nvar registers_before_function = [\n  { name: \"t0\", can_operate: false },\n  { name: \"t1\", can_operate: false },\n  { name: \"t2\", can_operate: false },\n  { name: \"t3\", can_operate: false },\n  { name: \"t4\", can_operate: false },\n  { name: \"t5\", can_operate: false },\n  { name: \"t6\", can_operate: false },\n  { name: \"s0\", can_operate: false },\n  { name: \"s1\", can_operate: false },\n  { name: \"s2\", can_operate: false },\n  { name: \"s3\", can_operate: false },\n  { name: \"s4\", can_operate: false },\n  { name: \"s5\", can_operate: false },\n  { name: \"s6\", can_operate: false },\n  { name: \"s7\", can_operate: false },\n  { name: \"s8\", can_operate: false },\n  { name: \"s9\", can_operate: false },\n  { name: \"s10\", can_operate: false },\n  { name: \"s11\", can_operate: false }\n];\nvar callstack_convention = [];\nvar inside_function = false;\n`;\n\n  const snippetStatements = j(snippet).get().node.program.body;\n\n  function alreadyInserted(body) {\n    return body.some(\n      (st) =>\n        st.type === 'ExpressionStatement' &&\n        j(st).toSource().includes('document.app.$data.is_breakpoint')\n    );\n  }\n\n  root\n    .find(j.ReturnStatement, { argument: { type: 'FunctionExpression' } })\n    .filter((p) => {\n      const fn = p.node.argument;\n      return (\n        fn.params?.length === 1 &&\n        fn.params[0].type === 'Identifier' &&\n        fn.params[0].name === 'Module'\n      );\n    })\n    .forEach((p) => {\n      const fn = p.node.argument;\n      if (!alreadyInserted(fn.body.body)) {\n        fn.body.body.unshift(...snippetStatements);\n      }\n    });\n\n  // ============================================================\n  return root.toSource({ quote: 'single', trailingComma: true });\n}\n"],"mappings":";;;;;;AAAA;AACe,SAASA,WAAWA,CAACC,IAAI,EAAEC,GAAG,EAAE;EAC7C,MAAMC,CAAC,GAAGD,GAAG,CAACE,WAAW;EACzB,MAAMC,IAAI,GAAGF,CAAC,CAACF,IAAI,CAACK,MAAM,CAAC;EAC3B,MAAMC,OAAO,GAAGF,IAAI,CAACG,GAAG,CAAC,CAAC,CAACC,IAAI,CAACF,OAAO;;EAEvC;EACA;EACA;EACA,SAASG,mBAAmBA,CAACC,UAAU,GAAG,EAAE,EAAE;IAC5C,OAAOA,UAAU,CACdC,GAAG,CAAEC,CAAC,IAAK;MACV,IAAIA,CAAC,CAACC,IAAI,KAAK,iBAAiB,EAAE;QAAA,IAAAC,WAAA,EAAAC,QAAA;QAChC,MAAMC,QAAQ,GAAG,EAAAF,WAAA,GAAAF,CAAC,CAACI,QAAQ,cAAAF,WAAA,uBAAVA,WAAA,CAAYG,IAAI,KAAI,EAAE;QACvC,MAAMC,KAAK,GAAG,EAAAH,QAAA,GAAAH,CAAC,CAACM,KAAK,cAAAH,QAAA,uBAAPA,QAAA,CAASE,IAAI,KAAID,QAAQ;QACvC,OAAO,SAASA,QAAQ,KAAKE,KAAK,EAAE;MACtC;MACA,IAAIN,CAAC,CAACC,IAAI,KAAK,wBAAwB,EAAE;QAAA,IAAAM,SAAA;QACvC,OAAO,WAAW,EAAAA,SAAA,GAAAP,CAAC,CAACM,KAAK,cAAAC,SAAA,uBAAPA,SAAA,CAASF,IAAI,KAAI,EAAE,EAAE;MACzC;MACA,IAAIL,CAAC,CAACC,IAAI,KAAK,0BAA0B,EAAE;QAAA,IAAAO,SAAA;QACzC,OAAO,MAAM,EAAAA,SAAA,GAAAR,CAAC,CAACM,KAAK,cAAAE,SAAA,uBAAPA,SAAA,CAASH,IAAI,KAAI,EAAE,EAAE;MACpC;MACA,OAAO,OAAO;IAChB,CAAC,CAAC,CACDI,IAAI,CAAC,CAAC,CACNC,IAAI,CAAC,GAAG,CAAC;EACd;EAEA,SAASC,YAAYA,CAACC,UAAU,EAAEd,UAAU,EAAE;IAC5C,MAAMe,IAAI,GAAGhB,mBAAmB,CAACC,UAAU,CAAC;IAC5C,OACEN,IAAI,CACDsB,IAAI,CAACxB,CAAC,CAACyB,iBAAiB,EAAE;MAAEtB,MAAM,EAAE;QAAEuB,KAAK,EAAEJ;MAAW;IAAE,CAAC,CAAC,CAC5DK,MAAM,CAAEC,CAAC,IAAKrB,mBAAmB,CAACqB,CAAC,CAACtB,IAAI,CAACE,UAAU,CAAC,KAAKe,IAAI,CAAC,CAC9DM,IAAI,CAAC,CAAC,GAAG,CAAC;EAEjB;EAEA,SAASC,eAAeA,CAACR,UAAU,EAAES,KAAK,EAAE;IAC1C,OAAO/B,CAAC,CAACgC,iBAAiB,CACxBD,KAAK,CAACtB,GAAG,CAAEwB,CAAC,IAAKjC,CAAC,CAACkC,eAAe,CAAClC,CAAC,CAACmC,UAAU,CAACF,CAAC,CAAC,CAAC,CAAC,EACpDjC,CAAC,CAACoC,OAAO,CAACd,UAAU,CACtB,CAAC;EACH;;EAEA;EACA;EACA;EACA,SAASe,iBAAiBA,CAACtB,IAAI,EAAE;IAC/B,OACEb,IAAI,CACDsB,IAAI,CAACxB,CAAC,CAACsC,sBAAsB,CAAC,CAC9BX,MAAM,CAAEC,CAAC,IAAK;MACb,MAAMW,IAAI,GAAGX,CAAC,CAACtB,IAAI,CAACkC,WAAW;MAC/B,IAAI,CAACD,IAAI,IAAIA,IAAI,CAAC5B,IAAI,KAAK,qBAAqB,EAAE,OAAO,KAAK;MAC9D,OAAO4B,IAAI,CAACE,YAAY,CAACC,IAAI,CAC1BC,CAAC,IAAKA,CAAC,CAACC,EAAE,CAACjC,IAAI,KAAK,YAAY,IAAIgC,CAAC,CAACC,EAAE,CAAC7B,IAAI,KAAKA,IACrD,CAAC;IACH,CAAC,CAAC,CACDc,IAAI,CAAC,CAAC,GAAG,CAAC;EAEjB;EAEA,SAASgB,eAAeA,CAAC9B,IAAI,EAAE+B,SAAS,EAAE;IACxC,OAAO9C,CAAC,CAAC+C,sBAAsB,CAC7B/C,CAAC,CAACgD,mBAAmB,CAAC,KAAK,EAAE,CAC3BhD,CAAC,CAACiD,kBAAkB,CAACjD,CAAC,CAACmC,UAAU,CAACpB,IAAI,CAAC,EAAE+B,SAAS,CAAC,CACpD,CAAC,EACF,EACF,CAAC;EACH;;EAEA;EACA;EACA;EACA,MAAMI,cAAc,GAAG,CACrBpB,eAAe,CAAC,gCAAgC,EAAE,CAChD,cAAc,EACd,kBAAkB,CACnB,CAAC,EACFA,eAAe,CAAC,wCAAwC,EAAE,CACxD,cAAc,EACd,eAAe,EACf,sBAAsB,CACvB,CAAC,EACFA,eAAe,CAAC,oCAAoC,EAAE,CACpD,oBAAoB,EACpB,cAAc,CACf,CAAC,EACFA,eAAe,CAAC,iBAAiB,EAAE,CACjC,QAAQ,EACR,oBAAoB,EACpB,cAAc,EACd,WAAW,EACX,OAAO,EACP,aAAa,EACb,cAAc,EACd,iBAAiB,EACjB,mBAAmB,EACnB,mBAAmB,EACnB,mBAAmB,EACnB,mBAAmB,EACnB,iBAAiB,EACjB,gBAAgB,CACjB,CAAC,EACFA,eAAe,CAAC,gCAAgC,EAAE,CAAC,iBAAiB,CAAC,CAAC,EACtEA,eAAe,CAAC,cAAc,EAAE,CAAC,eAAe,CAAC,CAAC,EAClDA,eAAe,CAAC,yBAAyB,EAAE,CAAC,SAAS,CAAC,CAAC,EACvDA,eAAe,CAAC,mBAAmB,EAAE,CAAC,YAAY,CAAC,CAAC,EACpDA,eAAe,CAAC,iBAAiB,EAAE,CAAC,mBAAmB,CAAC,CAAC,EACzDA,eAAe,CAAC,iBAAiB,EAAE,CACjC,eAAe,EACf,qBAAqB,EACrB,aAAa,EACb,cAAc,EACd,YAAY,CACb,CAAC,EACFA,eAAe,CAAC,mBAAmB,EAAE,CAAC,cAAc,CAAC,CAAC,EACtDA,eAAe,CAAC,uCAAuC,EAAE,CACvD,uBAAuB,CACxB,CAAC,CACH;;EAED;EACA;EACA;EACA,IAAIqB,QAAQ,GAAG,CAAC;EAChB,OAAOA,QAAQ,GAAG/C,OAAO,CAACgD,IAAI,CAACC,MAAM,EAAE;IAAA,IAAAC,gBAAA;IACrC,MAAMhD,IAAI,GAAGF,OAAO,CAACgD,IAAI,CAACD,QAAQ,CAAC;IACnC,IAAI7C,IAAI,CAACK,IAAI,KAAK,mBAAmB,EAAE;IACvC,IACEL,IAAI,CAACK,IAAI,KAAK,qBAAqB,IACnC,EAAA2C,gBAAA,GAAAhD,IAAI,CAACiD,UAAU,cAAAD,gBAAA,uBAAfA,gBAAA,CAAiB3C,IAAI,MAAK,SAAS,EACnC;MACAwC,QAAQ,EAAE;MACV;IACF;IACA,IAAI7C,IAAI,CAACkD,eAAe,IAAIlD,IAAI,CAACkD,eAAe,CAACH,MAAM,GAAG,CAAC,EAAE;MAC3DF,QAAQ,EAAE;MACV;IACF;IACA;EACF;EAEA,MAAMM,eAAe,GAAG,EAAE;EAC1B,KAAK,MAAMC,GAAG,IAAIR,cAAc,EAAE;IAChC,IAAI,CAAC7B,YAAY,CAACqC,GAAG,CAACvD,MAAM,CAACuB,KAAK,EAAEgC,GAAG,CAAClD,UAAU,IAAI,EAAE,CAAC,EAAE;MACzDiD,eAAe,CAACE,IAAI,CAACD,GAAG,CAAC;IAC3B;EACF;EAEA,IAAID,eAAe,CAACJ,MAAM,GAAG,CAAC,EAAE;IAC9BjD,OAAO,CAACgD,IAAI,CAACQ,MAAM,CAACT,QAAQ,EAAE,CAAC,EAAE,GAAGM,eAAe,CAAC;EACtD;;EAEA;EACA;EACA;EACA,IAAI,CAACpB,iBAAiB,CAAC,YAAY,CAAC,EAAE;IACpC,MAAMwB,WAAW,GAAGhB,eAAe,CAAC,YAAY,EAAE7C,CAAC,CAACoC,OAAO,CAAC,KAAK,CAAC,CAAC;IAEnE,IAAI0B,eAAe,GAAG,CAAC,CAAC;IACxB1D,OAAO,CAACgD,IAAI,CAACW,OAAO,CAAC,CAACzD,IAAI,EAAE0D,GAAG,KAAK;MAClC,IAAI1D,IAAI,CAACK,IAAI,KAAK,mBAAmB,EAAEmD,eAAe,GAAGE,GAAG;IAC9D,CAAC,CAAC;IAEF5D,OAAO,CAACgD,IAAI,CAACQ,MAAM,CAACE,eAAe,GAAG,CAAC,EAAE,CAAC,EAAED,WAAW,CAAC;EAC1D;;EAEA;EACA;EACA;EACA,MAAMI,OAAO,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;EAEC,MAAMC,iBAAiB,GAAGlE,CAAC,CAACiE,OAAO,CAAC,CAAC5D,GAAG,CAAC,CAAC,CAACC,IAAI,CAACF,OAAO,CAACgD,IAAI;EAE5D,SAASe,eAAeA,CAACf,IAAI,EAAE;IAC7B,OAAOA,IAAI,CAACV,IAAI,CACb0B,EAAE,IACDA,EAAE,CAACzD,IAAI,KAAK,qBAAqB,IACjCX,CAAC,CAACoE,EAAE,CAAC,CAACC,QAAQ,CAAC,CAAC,CAACC,QAAQ,CAAC,kCAAkC,CAChE,CAAC;EACH;EAEApE,IAAI,CACDsB,IAAI,CAACxB,CAAC,CAACuE,eAAe,EAAE;IAAEC,QAAQ,EAAE;MAAE7D,IAAI,EAAE;IAAqB;EAAE,CAAC,CAAC,CACrEgB,MAAM,CAAEC,CAAC,IAAK;IAAA,IAAA6C,UAAA;IACb,MAAMC,EAAE,GAAG9C,CAAC,CAACtB,IAAI,CAACkE,QAAQ;IAC1B,OACE,EAAAC,UAAA,GAAAC,EAAE,CAACC,MAAM,cAAAF,UAAA,uBAATA,UAAA,CAAWpB,MAAM,MAAK,CAAC,IACvBqB,EAAE,CAACC,MAAM,CAAC,CAAC,CAAC,CAAChE,IAAI,KAAK,YAAY,IAClC+D,EAAE,CAACC,MAAM,CAAC,CAAC,CAAC,CAAC5D,IAAI,KAAK,QAAQ;EAElC,CAAC,CAAC,CACDgD,OAAO,CAAEnC,CAAC,IAAK;IACd,MAAM8C,EAAE,GAAG9C,CAAC,CAACtB,IAAI,CAACkE,QAAQ;IAC1B,IAAI,CAACL,eAAe,CAACO,EAAE,CAACtB,IAAI,CAACA,IAAI,CAAC,EAAE;MAClCsB,EAAE,CAACtB,IAAI,CAACA,IAAI,CAACwB,OAAO,CAAC,GAAGV,iBAAiB,CAAC;IAC5C;EACF,CAAC,CAAC;;EAEJ;EACA,OAAOhE,IAAI,CAACmE,QAAQ,CAAC;IAAEQ,KAAK,EAAE,QAAQ;IAAEC,aAAa,EAAE;EAAK,CAAC,CAAC;AAChE","ignoreList":[]}},"mtime":1769765636896},"{\"assumptions\":{},\"sourceRoot\":\"/home/juancarlos/Escritorio/prueba/creator-sail-executor/c_emulator/\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"/home/juancarlos/Escritorio/prueba/creator-sail-executor/c_emulator\",\"filename\":\"/home/juancarlos/Escritorio/prueba/creator-sail-executor/c_emulator/transform64.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"/home/juancarlos/Escritorio/prueba/creator-sail-executor/c_emulator\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.28.6:development":{"value":{"code":"\"use strict\";\n\n/**\n * transform.js (jscodeshift)\n *\n * Exact codemod: converts the specific provided original.js into the specific provided deseado.js.\n * For safety, it checks a few anchor strings; if they don't match, it leaves the file unchanged.\n *\n * Usage:\n *   # Option A: run with embedded desired content (no extra files needed)\n *   npx jscodeshift -t transform.js original.js\n *\n *   # Option B: if you prefer not to embed, keep a deseado.js next to where you run the command:\n *   cp deseado.js /path/where/you/run/\n *   npx jscodeshift -t transform.js original.js\n */\nconst fs = require('fs');\nconst path = require('path');\nmodule.exports = function transformer(file, api) {\n  const source = file.source;\n\n  // Anchors to confirm we're looking at the expected input file.\n  const anchors = ['var Module = (() => {', 'return async function (moduleArg = {}) {', 'var readyPromiseResolve, readyPromiseReject;'];\n  const isExpectedInput = anchors.every(a => source.includes(a));\n  if (!isExpectedInput) return source;\n\n  // If a deseado.js exists in the current working directory, prefer it.\n  const desiredPath = path.join(process.cwd(), 'deseado.js');\n  if (fs.existsSync(desiredPath)) {\n    return fs.readFileSync(desiredPath, 'utf8');\n  }\n\n  // Otherwise fall back to the embedded content.\n  return DESIRED_CONTENT;\n};\nconst DESIRED_CONTENT = 'import { instructions } from \"@/core/assembler/assembler.mjs\";\\nimport { readRegister, writeRegister, notifyRegisterUpdate } from \"@/core/register/registerOperations.mjs\";\\nimport { crex_findReg_bytag, crex_findReg } from \"@/core/register/registerLookup.mjs\"\\nimport { status, PC_REG_INDEX, REGISTERS, getPC, main_memory, config_cache, L1_cache_memory, L1_I_cache_memory, L1_D_cache_memory, L2_D_cache_memory, L2_I_cache_memory, L2_cache_memory, updateCacheMem  } from \"@/core/core.mjs\";\\nimport { setInstructions } from \"@/core/assembler/assembler.mjs\";\\nimport { display_print } from \"../../IO.mjs\";\\nimport { SYSCALL } from \"@/core/capi/syscall.mts\";\\nimport { coreEvents } from \"@/core/events.mts\";\\nimport { show_notification } from \"@/web/utils.mjs\";\\nimport { reset_disable, instruction_disable, run_disable, stop_disable, isFinished } from \"@/web/utils.mjs\";\\nimport { architecture } from \"../../../core.mjs\";\\nimport { clearAllRegisterGlows } from \"@/core/register/registerGlowState.mjs\";\\n\\nexport var userMode64 = false;\\n\\nvar Module = (() => {\\n  var _scriptName = import.meta.url;\\n  var insn_number;\\n\\n  return async function (moduleArg = {}) {\\n    document.app.$data.is_breakpoint = instructions[0].Break;\\n    var pc_sail = crex_findReg_bytag(\"program_counter\");\\n    var pc_min = architecture.memory_layout.text.start;\\n    var pc_max = architecture.memory_layout.text.end;\\n    var hiden_executed, hiden_next_execute;\\n\\n    var registers_before_function = [ \\n      { name: \"t0\", can_operate : false},\\n      { name: \"t1\", can_operate : false},\\n      { name: \"t2\", can_operate : false},\\n      { name: \"t3\", can_operate : false},\\n      { name: \"t4\", can_operate : false}, \\n      { name: \"t5\", can_operate : false},\\n      { name: \"t6\", can_operate : false},\\n      { name: \"s0\", can_operate : false},\\n      { name: \"s1\", can_operate : false},\\n      { name: \"s2\", can_operate : false},\\n      { name: \"s3\", can_operate : false},\\n      { name: \"s4\", can_operate : false}, \\n      { name: \"s5\", can_operate : false},\\n      { name: \"s6\", can_operate : false},\\n      { name: \"s7\", can_operate : false},\\n      { name: \"s8\", can_operate : false},\\n      { name: \"s9\", can_operate : false},\\n      { name: \"s10\", can_operate : false}, \\n      { name: \"s11\", can_operate : false}\\n    ]\\n    var callstack_convention = [];\\n    var inside_function = false;\\n    Module = Module || {};\\n    var moduleRtn;\\n\\n    var Module = moduleArg;\\n    var readyPromiseResolve, readyPromiseReject;\\n    var readyPromise = new Promise((resolve, reject) => {\\n      readyPromiseResolve = resolve;\\n      readyPromiseReject = reject;\\n    });\\n    var ENVIRONMENT_IS_WEB = true;\\n    var ENVIRONMENT_IS_WORKER = false;\\n    var ENVIRONMENT_IS_NODE = false;\\n    var ENVIRONMENT_IS_SHELL = false;\\n    var moduleOverrides = Object.assign({}, Module);\\n    var arguments_ = [];\\n    var thisProgram = \"./this.program\";\\n    var quit_ = (status, toThrow) => {\\n      throw toThrow;\\n    };\\n    var scriptDirectory = \"\";\\n    function locateFile(path) {\\n      if (Module[\"locateFile\"]) {\\n        return Module[\"locateFile\"](path, scriptDirectory);\\n      }\\n      return scriptDirectory + path;\\n    }\\n    var readAsync, readBinary;\\n    if (ENVIRONMENT_IS_SHELL) {\\n      if (\\n        (typeof process == \"object\" && typeof require === \"function\") ||\\n        typeof window == \"object\" ||\\n        typeof WorkerGlobalScope != \"undefined\"\\n      )\\n        throw new Error(\\n          \"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\",\\n        );\\n    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\\n      if (ENVIRONMENT_IS_WORKER) {\\n        scriptDirectory = self.location.href;\\n      } else if (typeof document != \"undefined\" && document.currentScript) {\\n        scriptDirectory = document.currentScript.src;\\n      }\\n      if (_scriptName) {\\n        scriptDirectory = _scriptName;\\n      }\\n      if (scriptDirectory.startsWith(\"blob:\")) {\\n        scriptDirectory = \"\";\\n      } else {\\n        scriptDirectory = scriptDirectory.slice(\\n          0,\\n          scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1,\\n        );\\n      }\\n      if (\\n        !(typeof window == \"object\" || typeof WorkerGlobalScope != \"undefined\")\\n      )\\n        throw new Error(\\n          \"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\",\\n        );\\n      {\\n        readAsync = async (url) => {\\n          assert(!isFileURI(url), \"readAsync does not work with file:// URLs\");\\n          var response = await fetch(url, { credentials: \"same-origin\" });\\n          if (response.ok) {\\n            return response.arrayBuffer();\\n          }\\n          throw new Error(response.status + \" : \" + response.url);\\n        };\\n      }\\n    } else {\\n      throw new Error(\"environment detection error\");\\n    }\\n\\n\\n    // const instructionExp = /\\\\[(\\\\d+)\\\\] \\\\[(\\\\w+)\\\\]: 0x([0-9A-Fa-f]+) \\\\(0x([0-9A-Fa-f]+)\\\\) (\\\\w+) ([^,]+), ([^,]+)(?:, (.+))?/;\\n    var instructionExp = /\\\\[(\\\\d+)\\\\] \\\\[(\\\\w+)\\\\]: 0x([0-9A-Fa-f]+) \\\\(0x([0-9A-Fa-f]+)\\\\) ([\\\\w.]+)(?: ([^,]+), ([^,]+)(?:, (.+))?)?/;\\n    var registerExp = /([xf]\\\\d+) (<-) 0x([0-9A-Fa-f]+)/; // /(x\\\\d+) (<-|->) 0x([0-9A-Fa-f]+)/;\\n    var vectorExp = /(v\\\\d+) (<-) 0x([0-9A-Fa-f]+)/;\\n    var memoryExp = /mem\\\\[0x([0-9A-Fa-f]+)\\\\]\\\\s*(<-|->)\\\\s*0x([0-9A-Fa-f]+)/;\\n    var CSRTypeExp = /(CSR\\\\S*)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(0x)([\\\\dA-Fa-f]{1,16})/;\\n    var CSRExp = /^(CSR)\\\\s+(\\\\w+)\\\\s+(<-|->)\\\\s+0x([0-9a-fA-F]+)(?:\\\\s+(.*))?$/;\\n    var jumpExp = /Next_PC:\\\\s*0x([0-9a-fA-F]+)/;\\n    // var cacheExp = /^\\\\[(\\\\d+)\\\\]\\\\s+(L1_I|L1_D|L1|L2|L2_I|L2_D):\\\\s*\\\\((0x[0-9A-Fa-f]+)\\\\)\\\\s$/;\\n    var cacheExp = /^\\\\[(\\\\d+)\\\\]\\\\s+(L1_I|L1_D|L1|L2|L2_I|L2_D):\\\\s*\\\\((0x[0-9A-Fa-f]+)\\\\)\\\\s*$/;\\n    var configCacheExp = /^Configuration:\\\\s*([A-Za-z_][A-Za-z0-9_]*)\\\\s*<-\\\\s*(\\\\S+)\\\\s*$/;\\n    // var displayExp = /^[A-Za-z\\\\s]+:\\\\s*(.*)$/;\\n    // var displayExp = /^([\\\\w\\\\s]+):\\\\s*(.*)$/;     \\n    var displayExp = /^ECALL\\\\s+(SIGNED|UNSIGNED|STRING|CHAR|FLOAT|DOUBLE):\\\\s*(.+)$/; \\n    var instoper = \"\";\\n    var syscall_print_code = -1;\\n    var prev_add_to_jump;\\n    // var type_to_write;\\n\\n\\n\\n    function updateCacheStat(index, access, data=\"\") {\\n      switch(access) {\\n        case \"Cache L1 hit inst\":\\n          if (instructions[index].L1_I == 0)\\n            instructions[index].L1_I = 3;\\n          else if (instructions[index].L1_I == 3)\\n            instructions[index].L1_I = 3;\\n          else if (instructions[index].L1_I == 4)\\n            instructions[index].L1_I = 1;\\n          break;\\n        case \"Cache L1 miss inst\":\\n          if (instructions[index].L1_I == 0)\\n            instructions[index].L1_I = 4;\\n          else if (instructions[index].L1_I == 4)\\n            instructions[index].L1_I = 4;\\n          else if (instructions[index].L1_I == 3)\\n            instructions[index].L1_I = 1;\\n          break;\\n        case \"Cache L1 miss\":\\n          if (instructions[index].L1_I == 0)\\n            instructions[index].L1_I = 4;\\n          else if (instructions[index].L1_I == 4)\\n            instructions[index].L1_I = 4;\\n          else if (instructions[index].L1_I == 3)\\n            instructions[index].L1_I = 1;\\n          break;\\n        case \"Cache L1 hit data\":\\n          if(data !== \"\") {\\n            let lastv = parseInt(data[data.length - 1], 16);\\n            if (lastv < 4) data = data.slice(0, -1) + \"0\";\\n            else if (lastv < 8) data = data.slice(0, -1) + \"4\";\\n            else if (lastv < 12) data = data.slice(0, -1) +  \"8\";\\n            else data = data.slice(0, -1) + \"C\";\\n            let memindex = parseInt(data, 16);\\n            if (main_memory[memindex].L1_D == 0)\\n              main_memory[parseInt(data, 16)].L1_D = 3;\\n            else if (main_memory[memindex].L1_D == 3)\\n              main_memory[parseInt(data, 16)].L1_D = 3;\\n            else if (main_memory[memindex].L1_D == 4)\\n              main_memory[parseInt(data, 16)].L1_D = 1;\\n          }\\n          if (instructions[index].L1_D == 0)\\n            instructions[index].L1_D = 3;\\n          else if (instructions[index].L1_D == 3)\\n            instructions[index].L1_D = 3;\\n          else if (instructions[index].L1_D == 4)\\n            instructions[index].L1_D = 1;\\n          break;\\n        case \"Cache L1 miss data\":\\n          if(data !== \"\") {\\n            let lastv = parseInt(data[data.length - 1], 16);\\n            if (lastv < 4) data = data.slice(0, -1) + \"0\";\\n            else if (lastv < 8) data = data.slice(0, -1) + \"4\";\\n            else if (lastv < 12) data = data.slice(0, -1) +  \"8\";\\n            else data = data.slice(0, -1) + \"C\";\\n            let memindex = parseInt(data, 16);\\n            if (main_memory[memindex].L1_D == 0)\\n              main_memory[parseInt(data, 16)].L1_D = 4;\\n            else if (main_memory[memindex].L1_D == 4)\\n              main_memory[parseInt(data, 16)].L1_D = 4;\\n            else if (main_memory[memindex].L1_D == 3)\\n              main_memory[parseInt(data, 16)].L1_D = 1;\\n          }\\n          if (instructions[index].L1_D == 0)\\n            instructions[index].L1_D = 4;\\n          else if (instructions[index].L1_D == 4)\\n            instructions[index].L1_D = 4;\\n          else if (instructions[index].L1_D == 3)\\n            instructions[index].L1_D = 1;\\n          break;\\n        case \"Cache L1_I hit\":\\n          if (instructions[index].L1_I == 0)\\n            instructions[index].L1_I = 3;\\n          else if (instructions[index].L1_I == 4)\\n            instructions[index].L1_I = 1;\\n          break;\\n        case \"Cache L1_I miss\":\\n          if (instructions[index].L1_I == 0)\\n            instructions[index].L1_I = 4;\\n          else if (instructions[index].L1_I == 3)\\n            instructions[index].L1_I = 1;\\n          else if (instructions[index].L1_I == 4)\\n            instructions[index].L1_I = 4;\\n          break;\\n        case \"Cache L1_D hit\":\\n          if(data !== \"\") {\\n            let lastv = parseInt(data[data.length - 1], 16);\\n            if (lastv < 4) data = data.slice(0, -1) + \"0\";\\n            else if (lastv < 8) data = data.slice(0, -1) + \"4\";\\n            else if (lastv < 12) data = data.slice(0, -1) +  \"8\";\\n            else data = data.slice(0, -1) + \"C\";\\n            let memindex = parseInt(data, 16);\\n            if (main_memory[memindex].L1_D == 0)\\n              main_memory[parseInt(data, 16)].L1_D = 3;\\n            else if (main_memory[memindex].L1_D == 3)\\n              main_memory[parseInt(data, 16)].L1_D = 3;\\n            else if (main_memory[memindex].L1_D == 4)\\n              main_memory[parseInt(data, 16)].L1_D = 1;\\n          }\\n          if (instructions[index].L1_D == 0)\\n            instructions[index].L1_D = 3;\\n          else if (instructions[index].L1_D == 3)\\n            instructions[index].L1_D = 3;\\n          else if (instructions[index].L1_D == 4)\\n            instructions[index].L1_D = 1;\\n          break;\\n        case \"Cache L1_D miss\":\\n          if(data !== \"\") {\\n            let lastv = parseInt(data[data.length - 1], 16);\\n            if (lastv < 4) data = data.slice(0, -1) + \"0\";\\n            else if (lastv < 8) data = data.slice(0, -1) + \"4\";\\n            else if (lastv < 12) data = data.slice(0, -1) +  \"8\";\\n            else data = data.slice(0, -1) + \"C\";\\n            let memindex = parseInt(data, 16);\\n            if (main_memory[memindex].L1_D == 0)\\n              main_memory[parseInt(data, 16)].L1_D = 4;\\n            else if (main_memory[memindex].L1_D == 4)\\n              main_memory[parseInt(data, 16)].L1_D = 4;\\n            else if (main_memory[memindex].L1_D == 3)\\n              main_memory[parseInt(data, 16)].L1_D = 1;\\n          }\\n          if (instructions[index].L1_D == 0)\\n            instructions[index].L1_D = 4;\\n          else if (instructions[index].L1_D == 4)\\n            instructions[index].L1_D = 4;\\n          else if (instructions[index].L1_D == 3)\\n            instructions[index].L1_D = 1;\\n          break;\\n        case \"Cache L2 hit inst\":\\n          if (instructions[index].L2_I == 0)\\n            instructions[index].L2_I = 3;\\n          else if (instructions[index].L2_I == 3)\\n            instructions[index].L2_I = 3;\\n          else if (instructions[index].L2_I == 4)\\n            instructions[index].L2_I = 1;\\n          break;\\n        case \"Cache L2 miss inst\":\\n          if (instructions[index].L2_I == 0)\\n            instructions[index].L2_I = 4;\\n          else if (instructions[index].L2_I == 4)\\n            instructions[index].L2_I = 4;\\n          else if (instructions[index].L2_I == 3)\\n            instructions[index].L2_I = 1;\\n          break;\\n        case \"Cache L2_I hit\":\\n          if (instructions[index].L2_I == 0)\\n            instructions[index].L2_I = 3;\\n          else if (instructions[index].L2_I == 3)\\n            instructions[index].L2_I = 3;\\n          else if (instructions[index].L2_I == 4)\\n            instructions[index].L2_I = 1;\\n          break;\\n        case \"Cache L2_I miss\":\\n          if (instructions[index].L2_I == 0)\\n            instructions[index].L2_I = 4;\\n          else if (instructions[index].L2_I == 4)\\n            instructions[index].L2_I = 4;\\n          else if (instructions[index].L2_I == 3)\\n            instructions[index].L2_I = 1;\\n          break;\\n        case \"Cache L2 hit data\":\\n          if(data !== \"\") {\\n            let lastv = parseInt(data[data.length - 1], 16);\\n            if (lastv < 4) data = data.slice(0, -1) + \"0\";\\n            else if (lastv < 8) data = data.slice(0, -1) + \"4\";\\n            else if (lastv < 12) data = data.slice(0, -1) +  \"8\";\\n            else data = data.slice(0, -1) + \"C\";\\n            let memindex = parseInt(data, 16);\\n            if (main_memory[memindex].L2_D == 0)\\n              main_memory[parseInt(data, 16)].L2_D = 3;\\n            else if (main_memory[memindex].L2_D == 3)\\n              main_memory[parseInt(data, 16)].L2_D = 3;\\n            else if (main_memory[memindex].L2_D == 4)\\n              main_memory[parseInt(data, 16)].L2_D = 1;\\n          }\\n          if (instructions[index].L2_D == 0)\\n            instructions[index].L2_D = 3;\\n          else if (instructions[index].L2_D == 3)\\n            instructions[index].L2_D = 3;\\n          else if (instructions[index].L2_D == 4)\\n            instructions[index].L2_D = 1;\\n          break;\\n        case \"Cache L2 miss data\":\\n          if(data !== \"\") {\\n            let lastv = parseInt(data[data.length - 1], 16);\\n            if (lastv < 4) data = data.slice(0, -1) + \"0\";\\n            else if (lastv < 8) data = data.slice(0, -1) + \"4\";\\n            else if (lastv < 12) data = data.slice(0, -1) +  \"8\";\\n            else data = data.slice(0, -1) + \"C\";\\n            let memindex = parseInt(data, 16);\\n            if (main_memory[memindex].L2_D == 0)\\n              main_memory[parseInt(data, 16)].L2_D = 4;\\n            else if (main_memory[memindex].L2_D == 4)\\n              main_memory[parseInt(data, 16)].L2_D = 4;\\n            else if (main_memory[memindex].L2_D == 3)\\n              main_memory[parseInt(data, 16)].L2_D = 1;\\n          }\\n          if (instructions[index].L2_D == 0)\\n            instructions[index].L2_D = 4;\\n          else if (instructions[index].L2_D == 4)\\n            instructions[index].L2_D = 4;\\n          else if (instructions[index].L2_D == 3)\\n            instructions[index].L2_D = 1;\\n          break;\\n        case \"Cache L2_D hit\":\\n          if(data !== \"\") {\\n            let lastv = parseInt(data[data.length - 1], 16);\\n            if (lastv < 4) data = data.slice(0, -1) + \"0\";\\n            else if (lastv < 8) data = data.slice(0, -1) + \"4\";\\n            else if (lastv < 12) data = data.slice(0, -1) +  \"8\";\\n            else data = data.slice(0, -1) + \"C\";\\n            let memindex = parseInt(data, 16);\\n            if (main_memory[memindex].L2_D == 0)\\n              main_memory[parseInt(data, 16)].L2_D = 3;\\n            else if (main_memory[memindex].L2_D == 3)\\n              main_memory[parseInt(data, 16)].L2_D = 3;\\n            else if (main_memory[memindex].L2_D == 4)\\n              main_memory[parseInt(data, 16)].L2_D = 1;\\n          }\\n          if (instructions[index].L2_D == 0)\\n            instructions[index].L2_D = 3;\\n          else if (instructions[index].L2_D == 3)\\n            instructions[index].L2_D = 3;\\n          else if (instructions[index].L2_D == 4)\\n            instructions[index].L2_D = 1;\\n          break;\\n        case \"Cache L2_D miss\":\\n          if(data !== \"\") {\\n            let lastv = parseInt(data[data.length - 1], 16);\\n            if (lastv < 4) data = data.slice(0, -1) + \"0\";\\n            else if (lastv < 8) data = data.slice(0, -1) + \"4\";\\n            else if (lastv < 12) data = data.slice(0, -1) +  \"8\";\\n            else data = data.slice(0, -1) + \"C\";\\n            let memindex = parseInt(data, 16);\\n            if (main_memory[memindex].L2_D == 0)\\n              main_memory[parseInt(data, 16)].L2_D = 4;\\n            else if (main_memory[memindex].L2_D == 4)\\n              main_memory[parseInt(data, 16)].L2_D = 4;\\n            else if (main_memory[memindex].L2_D == 3)\\n              main_memory[parseInt(data, 16)].L2_D = 1;\\n          }\\n          if (instructions[index].L2_D == 0)\\n            instructions[index].L2_D = 4;\\n          else if (instructions[index].L2_D == 4)\\n            instructions[index].L2_D = 4;\\n          else if (instructions[index].L2_D == 3)\\n            instructions[index].L2_D = 1;\\n          break;\\n      }\\n\\n    }\\n\\n\\n    async function check_call_convention_temp_regs(instMatch) {\\n      if(((instMatch[7] != undefined && (instMatch[7].includes(\"t\") || (instMatch[7].includes(\"s\") && !instMatch[7].includes(\"sp\")) ) ) || (instMatch[8] != undefined && (instMatch[8].includes(\"t\") || (instMatch[8].includes(\"s\") && !instMatch[8].includes(\"sp\")) ))) && instMatch[6] !== undefined && inside_function) {\\n        if((instMatch[5] != \"li\" && instMatch[5] != \"lui\" && instMatch[5] != \"la\") ){\\n          for (var i = 0; i < callstack_convention[callstack_convention.length - 1].length; i++ ){\\n            (callstack_convention[callstack_convention.length - 1][i].name === instMatch[7] || callstack_convention[callstack_convention.length - 1][i].name === instMatch[8]) &&\\n            (callstack_convention[callstack_convention.length - 1][i].can_operate === false) ? show_notification(\"Possible failure in the parameter passing convention\", \"danger\") : 0 ; \\n          }\\n            \\n            // callstack_convention[callstack_convention.length - 1].name \\n\\n        }\\n      }\\n      if (instMatch[6] !== undefined && (instMatch[6].includes(\"t\") || (instMatch[6].includes(\"s\") && !instMatch[6].includes(\"sp\"))) && inside_function) {\\n        for (var i = 0; i < callstack_convention[callstack_convention.length - 1].length; i++ ){\\n          callstack_convention[callstack_convention.length - 1][i].can_operate = (callstack_convention[callstack_convention.length - 1][i].name === instMatch[6]) ? true : callstack_convention[callstack_convention.length - 1][i].can_operate; \\n        }\\n      }\\n    }\\n\\n    \\n\\n    // var to_measure = \"\";\\n    var start_m, start_m;\\n    var cache_inst;\\n\\n    function writeMemory(value, addr) {\\n      // Primero pasar el valor al formato hexadecimal por pares\\n      if (value.startsWith(\"0x\"))\\n        value = value.slice(2);\\n      if (value.length % 2 !== 0)\\n        value = \"0\" + value;\\n\\n      // const bytes = new Uint8Array(value.length / 2);\\n      for (let i = 0; i < value.length / 2; i ++) {\\n        main_memory.write((addr + BigInt(i)), Number(\"0x\" + value.substring(i*2, i * 2 + 2)));\\n      }\\n\\n      // if (memoMatch[2] === \\'<-\\'){\\n      //     switch(op){\\n      //       case \\'sh\\': // Para almacenar un half\\n      //       writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'half\\');\\n      //       break;\\n      //       case \\'sb\\': // Para almacenar un byte\\n      //       writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'byte\\');\\n      //       break;\\n      //       case \\'sw\\': // Para almacenar un int/word\\n      //       writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'word\\');\\n      //       break;\\n      //       case \\'fsw\\': // Para almacenar un float\\n      //       writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'float\\');\\n      //       break;\\n      //       case \\'fsd\\': // Para almacenar un double\\n      //       writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'double\\');\\n      //       break;\\n      //       case \\'vse8.v\\':\\n      //       writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'byte\\');\\n      //         break;\\n      //       case \\'vse16.v\\':\\n      //       writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'half\\');\\n      //         break;\\n      //       case \\'vse32.v\\':\\n      //       writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'word\\');\\n      //         break;\\n      //       case \\'vse64.v\\':\\n      //         writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'double\\');\\n      //         break;\\n      //       default:\\n      //         break;\\n      //     }\\n      //   }\\n    }\\n\\n    // var no_print_more = false;\\n    Module[\\'print\\'] = function (message) {\\n      // console.log(message);\\n      if (message === \"Divergence execution detected: Aborted.\")\\n        show_notification(message, \"danger\");\\n      if (message === \"err call_convenction\")\\n        show_notification(\"Possible failure in the parameter passing convention\", \"warning\");\\n      \\n      if (message === \"May your execution has an infinity loop.\"){\\n        document.app.$data.execution_mode_run = 1;\\n        show_notification(\"May your execution has an infinity loop\", \"danger\");\\n        instructions[hiden_executed]._rowVariant = \"info\";\\n        instructions[hiden_next_execute]._rowVariant = \"success\";\\n      }\\n      \\n      var next_add_to_jump;\\n      let instMatch        = message.match(instructionExp);\\n      let regiMatch        = message.match(registerExp);\\n      let memoMatch        = message.match(memoryExp);\\n      let printMatch       = message.match(displayExp);\\n      let CSRMatch         = message.match(CSRTypeExp);\\n      let CSREMatch        = message.match(CSRExp);\\n      let vectorMatch      = message.match(vectorExp);\\n      let jumpMatch        = message.match(jumpExp);\\n      let cacheMatch       = message.match(cacheExp);\\n      let configCacheMatch = message.match(configCacheExp);\\n\\n      if (message.startsWith(\"Cache\") || message.startsWith(\"Next_PC:\")){\\n        if (message.includes(\"Cache prefetch\")) {\\n          let newpc = message.substring(15,message.length).toLowerCase();\\n          cache_inst = instructions.findIndex(insn => insn.Address === (\"0x\" + BigInt(newpc).toString(16)));\\n        } else if (message.includes(\"Next_PC:\")) {\\n          let newpc = message.substring(9, message.length).toLowerCase();\\n          cache_inst = instructions.findIndex(insn => insn.Address == (\"0x\" + BigInt(newpc).toString(16)));\\n        }\\n        if (cache_inst != -1 && document.app.$data.execution_mode_run === 1) {\\n          let hexmatch = message.match(/0x[0-9A-Fa-f]+$/);\\n          if (hexmatch && !message.startsWith(\"Cache prefetch\")) {\\n            let hexa = hexmatch[0];\\n            message = message.replace(/on:\\\\s*0x[0-9A-Fa-f]+$/, \"\").trim();\\n            updateCacheStat(cache_inst, message, hexa);\\n          }else {\\n            updateCacheStat(cache_inst, message);\\n          }\\n          \\n        }\\n      }\\n\\n\\n      if (jumpMatch){\\n        jumpMatch[1] = \"0x\" + jumpMatch[1].replace(/^0+/, \\'\\');\\n        if (jumpMatch[1] === \"0x\") jumpMatch[1] = \"0x0\";\\n        // console.log(jumpMatch);\\n        const current_ins = instructions.findIndex(insn => insn.Address === (jumpMatch[1].toLowerCase()));\\n        \\n          for (var i = 0; i < instructions.length; i++){\\n            if(instructions[i]._rowVariant === \"success\" && document.app.$data.execution_mode_run !== 0) // ajustar lo del user mode\\n              instructions[i]._rowVariant = \"\";\\n          }\\n        if (current_ins !== -1) instructions[current_ins]._rowVariant = \"success\";\\n      }\\n\\n      if (configCacheMatch) {\\n        // console.log(configCacheMatch);\\n        switch(configCacheMatch[1]) {\\n          case \"L1_I_SIZE\":\\n            config_cache.push({configuration: \"Size L1_I\", value: configCacheMatch[2] + \" lines\"});\\n            break;\\n          case \"L1_D_SIZE\":\\n            config_cache.push({configuration: \"Size L1_D\", value: configCacheMatch[2] + \" lines\"});\\n            break;\\n          case \"L1_SIZE\":\\n            config_cache.push({configuration: \"Size L1\", value: configCacheMatch[2] + \" lines\"});\\n            break;\\n          case \"L2_I_SIZE\":\\n            config_cache.push({configuration: \"Size L2_I\", value: configCacheMatch[2] + \" lines\"});\\n            break;\\n          case \"L2_D_SIZE\":\\n            config_cache.push({configuration: \"Size L2_D\", value: configCacheMatch[2] + \" lines\"});\\n            break;\\n          case \"L2_SIZE\":\\n            config_cache.push({configuration: \"Size L2\", value: configCacheMatch[2] + \" lines\"});\\n            break;\\n          case \"Rep_policy\":\\n            config_cache.push({configuration: \"Replacement policy\", value: configCacheMatch[2]});\\n            break;\\n          case \"L1_I_BLOCK_SIZE\":\\n            config_cache.push({configuration: \"Size Cache L1_I block\", value: configCacheMatch[2] + \" bits\"});\\n            break;\\n          case \"L1_D_BLOCK_SIZE\":\\n            config_cache.push({configuration: \"Size Cache L1_D block\", value: configCacheMatch[2] + \" bits\"});\\n            break;\\n          case \"L1_BLOCK_SIZE\":\\n            config_cache.push({configuration: \"Size Cache L1 block\", value: configCacheMatch[2] + \" bits\"});\\n            break;\\n          case \"L2_I_BLOCK_SIZE\":\\n            config_cache.push({configuration: \"Size Cache L2_I block\", value: configCacheMatch[2] + \" bits\"});\\n            break;\\n          case \"L2_D_BLOCK_SIZE\":\\n            config_cache.push({configuration: \"Size Cache L2_D block\", value: configCacheMatch[2] + \" bits\"});\\n            break;\\n          case \"L2_BLOCK_SIZE\":\\n            config_cache.push({configuration: \"Size Cache L2 block\", value: configCacheMatch[2] + \" bits\"});\\n            break;\\n        }\\n      }\\n\\n      if (cacheMatch) {\\n        console.log(cacheMatch);\\n        // updateCacheMem(parseInt(cacheMatch[1],10), cacheMatch[2], cacheMatch[3], parseInt(cacheMatch[4], 10));\\n        switch(cacheMatch[2]) {\\n          case \"L1_I\":\\n            updateCacheMem(parseInt(cacheMatch[1],10), cacheMatch[2], cacheMatch[3], document.app.$data.L1_I_size_block);\\n          break;\\n          case \"L1_D\":\\n            updateCacheMem(parseInt(cacheMatch[1],10), cacheMatch[2], cacheMatch[3], document.app.$data.L1_D_size_block);\\n            \\n          break;\\n          case \"L1\":\\n            updateCacheMem(parseInt(cacheMatch[1],10), cacheMatch[2], cacheMatch[3], document.app.$data.L1_size_block);\\n            \\n          break;\\n          case \"L2_I\":\\n            updateCacheMem(parseInt(cacheMatch[1],10), cacheMatch[2], cacheMatch[3], document.app.$data.L2_I_size_block);\\n            \\n          break;\\n          case \"L2_D\":\\n            updateCacheMem(parseInt(cacheMatch[1],10), cacheMatch[2], cacheMatch[3], document.app.$data.L2_D_size_block);\\n            \\n          break;\\n          case \"L2\":\\n            updateCacheMem(parseInt(cacheMatch[1],10), cacheMatch[2], cacheMatch[3], document.app.$data.L2_size_block);\\n            \\n          break;\\n\\n        }\\n      }\\n\\n      if(CSREMatch){\\n        console.log(CSREMatch);\\n        if (CSREMatch[2] !== \"vtype\" && CSREMatch[2] !== \"vl\"){\\n          let regtowrite = crex_findReg(CSREMatch[2]);\\n          if(regtowrite.match !== 0)\\n            writeRegister(CSREMatch[4], regtowrite.indexComp, regtowrite.indexElem);\\n        }\\n      }\\n      if (CSRMatch){\\n        if (CSRMatch[2] === \"vtype\"){\\n          var size_elem = parseInt(CSRMatch[5], 16).toString(2).padStart(32, \\'0\\');\\n          size_elem = size_elem.slice(26, 29);\\n          console.log(\"Tamaño: \", size_elem);\\n          if(size_elem === \"000\"){\\n            document.app.$data.v_length = 8;\\n            // length_vext = 8;\\n            // architecture.components[3].total_elements = 64;\\n          } else if (size_elem === \"001\") {\\n            document.app.$data.v_length = 16;\\n            // length_vext = 16;\\n            // architecture.components[3].total_elements = 32;\\n          } else if (size_elem === \"010\"){\\n            document.app.$data.v_length = 32;\\n            // length_vext = 32;\\n            // architecture.components[3].total_elements = 16;\\n          }else {\\n            document.app.$data.v_length = 64;\\n            // length_vext = 64;\\n            // architecture.components[3].total_elements = 8;\\n          }\\n          // architecture.components[3].length_elem = length_vext;\\n        }\\n        else if (CSRMatch[2] === \"vl\"){\\n          // architecture.components[3].elems_op = parseInt(CSRMatch[5], 16);\\n        }\\n      }\\n      if (vectorMatch){\\n        let regtowrite = crex_findReg(vectorMatch[1]);\\n        writeRegister(vectorMatch[3], regtowrite.indexComp, regtowrite.indexElem);\\n      }\\n      if (instMatch && /*(instMatch[2] === \\'U\\' ||*/ ((parseInt(instMatch[3], 16) >= pc_min) && parseInt(instMatch[3], 16) < parseInt(\"0x20000\", 16) )){\\n        clearAllRegisterGlows();\\n        coreEvents.emit(\"step-about-to-execute\");\\n        userMode64 = true;\\n        if (inside_function) \\n          check_call_convention_temp_regs(instMatch);\\n\\n\\n        //Actualizamos el pc\\n        writeRegister(BigInt(parseInt(instMatch[3], 16)), pc_sail.indexComp, pc_sail.indexElem);\\n        for (var i = 0; i < instructions.length; i++) {\\n          if (instructions[i]._rowVariant === \"info\")\\n            instructions[i]._rowVariant = \"\";\\n        }\\n        instoper = \"\";\\n        // console.log(\"PC actual:\",pc_sail);\\n        // if ((instMatch[5].includes(\"w\") || instMatch[5].includes(\".s\") || instMatch[5].includes(\".w\")) && !instMatch.includes(\".d\"))\\n        //   type_toWrite = 32;\\n        // else if (instMatch[5].includes(\"d\"))\\n        //   type_toWrite = 64;\\n        // else \\n        //   type_toWrite = 0;\\n        console.log(\"Instruccion: \", instMatch);\\n        const current_ins = instructions.findIndex(insn => ( \\'0x\\' + (insn.Address.slice(2)).padStart(16, \\'0\\')) === (\"0x\"+instMatch[3].toLowerCase()));\\n        if (current_ins !== -1) {\\n        if(prev_add_to_jump !== undefined){\\n          instructions[prev_add_to_jump]._rowVariant = \"\";\\n          prev_add_to_jump = undefined;\\n        }\\n\\n        if (instructions[current_ins].loaded.includes(\"jalr\")){\\n          var next_add = instructions[current_ins].loaded.split(\"\\\\t\");\\n          var match = next_add[1].match(/(-?\\\\d+)\\\\((\\\\w+)\\\\)/);\\n\\n          if (match === undefined || match === null) {\\n            match = \"zero\";\\n            var aux_reg = crex_findReg(match);\\n            var aux_val = readRegister(aux_reg.indexComp, aux_reg.indexElem);\\n            \\n            next_add_to_jump = aux_val.toString(16);\\n            next_add_to_jump = instructions.findIndex(insn => insn.Address === (\"0x\"+next_add_to_jump.toLowerCase()));\\n            prev_add_to_jump = current_ins;\\n          }else {\\n            var aux_reg = crex_findReg(match[2]);\\n            var aux_val = readRegister(aux_reg.indexComp, aux_reg.indexElem);\\n            \\n            next_add_to_jump = (aux_val + BigInt(parseInt(match[1], 10))).toString(16);\\n            next_add_to_jump = instructions.findIndex(insn => insn.Address === (\"0x\"+next_add_to_jump.toLowerCase()));\\n            prev_add_to_jump = current_ins;\\n          }\\n\\n          // creator_callstack_enter(instructions[next_add_to_jump].Label); \\n          // track_stack_enter(instructions[next_add_to_jump].Label);\\n          // callstack_convention.push(structuredClone(registers_before_function));\\n          // inside_function = true;\\n\\n          console.log(\"Siguiente direccion del jalr: \", next_add);\\n        } \\n        if (instructions[current_ins].loaded.includes(\"jal\") && !instructions[current_ins].loaded.includes(\"jalr\")){\\n          var next_add = instructions[current_ins].loaded.split(\"\\\\t\");\\n          console.log(\"Siguiente direccion del jal: \", next_add);\\n\\n        } \\n        if (instructions[current_ins].loaded.includes(\"ret\") && !instructions[current_ins].loaded.includes(\"mret\")){\\n          // Mirar el ra\\n          var aux_reg = crex_findReg(\"ra\");\\n          next_add_to_jump = readRegister(aux_reg.indexComp, aux_reg.indexElem).toString(16);\\n          next_add_to_jump = instructions.findIndex(insn => ( \\'0x\\' + (insn.Address.slice(2))) === (\"0x\"+next_add_to_jump.toLowerCase()));\\n          if (next_add_to_jump !== -1) {\\n            prev_add_to_jump = current_ins;\\n            // track_stack_leave();\\n            // creator_callstack_leave();\\n            // callstack_convention.pop();\\n            // inside_function = (callstack_convention.length > 0); \\n          } else {\\n            next_add_to_jump = undefined;\\n          }\\n        } \\n        // Primero caso de paso a paso\\n        if (document.app.$data.execution_mode_run === 1){\\n          instructions[current_ins]._rowVariant = \\'info\\';\\n          if (current_ins < instructions.length - 1 || next_add_to_jump !== undefined){\\n            instructions[(next_add_to_jump !== undefined) ? next_add_to_jump : (current_ins + 1)]._rowVariant = \\'success\\';\\n            document.app.$data.is_breakpoint = instructions[(next_add_to_jump !== undefined) ? next_add_to_jump : (current_ins + 1)].Break;\\n          }\\n          if (current_ins > 0 || prev_add_to_jump !== undefined)\\n            instructions[(prev_add_to_jump !== undefined && prev_add_to_jump !== current_ins) ? prev_add_to_jump : ((current_ins > 0) ? current_ins -1 : 0)]._rowVariant = \\'\\';\\n        }\\n        // Para el caso de run without stop y la siguiente instruccion es un breakpoint\\n        else if (document.app.$data.execution_mode_run === 0){\\n          // se almacena el estado de la instruccion en caso de que haya una parada por infinity loop\\n          hiden_executed = current_ins;\\n          if (current_ins < instructions.length - 1  || next_add_to_jump !== undefined) {\\n            hiden_next_execute = (next_add_to_jump !== undefined) ? next_add_to_jump : current_ins + 1;\\n          } else \\n            hiden_next_execute = current_ins + 1;\\n\\n\\n          if (current_ins < instructions.length - 1 || next_add_to_jump !== undefined) {\\n            document.app.$data.is_breakpoint = instructions[(next_add_to_jump !== undefined) ? next_add_to_jump : (current_ins + 1)].Break;\\n          }\\n          if(document.app.$data.is_breakpoint){\\n            instructions[current_ins]._rowVariant = \\'info\\';\\n            if (current_ins < instructions.length - 1  || next_add_to_jump !== undefined) {\\n              instructions[(next_add_to_jump !== undefined) ? next_add_to_jump : (current_ins + 1)]._rowVariant = \\'success\\';\\n            }\\n            coreEvents.emit(\"pause-execution\");\\n          }else {\\n            instructions[current_ins]._rowVariant = \\'\\';\\n          }\\n          if (current_ins > 0  || prev_add_to_jump !== undefined)\\n            instructions[(prev_add_to_jump !== undefined && prev_add_to_jump !== current_ins) ? prev_add_to_jump : ((current_ins > 0) ? current_ins -1 : 0)]._rowVariant = \\'\\';\\n\\n        }\\n        else\\n          instructions[current_ins]._rowVariant = \\'\\';\\n        \\n        if (instMatch[5] === \"ecall\"){\\n          let argument_register = crex_findReg(\"a7\"); // obtenemos el registro para ver que llamada al sistema es\\n          let syscall_code = readRegister(argument_register.indexComp, argument_register.indexElem); // Lectura del registro para obtener el valor\\n      \\n          switch(syscall_code){\\n            case 5n:\\n              if(document.app.$data.execution_mode_run === 0){\\n                insn_number = current_ins;\\n                instructions[current_ins]._rowVariant = \"info\";\\n                if (current_ins < instructions.length -1  || next_add_to_jump !== undefined)\\n                  instructions[(next_add_to_jump !== undefined) ? next_add_to_jump : (current_ins + 1)]._rowVariant = \\'success\\';\\n                  // instructions[current_ins +1]._rowVariant = \"success\";\\n              }\\n              document.app.$data.last_execution_mode_run = document.app.$data.execution_mode_run;\\n              document.app.$data.execution_mode_run = 2;\\n              // last_execution_mode_run = document.app.$data.execution_mode_run;\\n              // document.app.$data.execution_mode_run = 2;\\n              // Manejo para enteros\\n              // capi_read_int(\\'a0\\');\\n              SYSCALL.read(\\'a0\\', \"int\");\\n              break;\\n            case 6n:\\n              if(document.app.$data.execution_mode_run === 0){\\n                insn_number = current_ins;\\n                instructions[current_ins]._rowVariant = \"info\";\\n                if (current_ins < instructions.length -1 || next_add_to_jump !== undefined)\\n                  instructions[(next_add_to_jump !== undefined) ? next_add_to_jump : (current_ins + 1)]._rowVariant = \\'success\\';\\n            \\n                  // instructions[current_ins +1]._rowVariant = \"success\";\\n              }\\n              document.app.$data.last_execution_mode_run = document.app.$data.execution_mode_run;\\n              document.app.$data.execution_mode_run = 2;\\n              // last_execution_mode_run = document.app.$data.execution_mode_run;\\n              // document.app.$data.execution_mode_run = 2;\\n              // Manejo para floats\\n              // capi_read_float(\\'fa0\\');\\n              SYSCALL.read(\"fa0\", \"float\");\\n              break;\\n            case 7n:\\n              if(document.app.$data.execution_mode_run === 0){\\n                insn_number = current_ins;\\n                instructions[current_ins]._rowVariant = \"info\";\\n                if (current_ins < instructions.length -1 || next_add_to_jump !== undefined)\\n                  instructions[(next_add_to_jump !== undefined) ? next_add_to_jump : (current_ins + 1)]._rowVariant = \\'success\\';\\n            \\n                  // instructions[current_ins +1]._rowVariant = \"success\";\\n              }\\n              document.app.$data.last_execution_mode_run = document.app.$data.execution_mode_run;\\n              document.app.$data.execution_mode_run = 2;\\n              // Manejo para double\\n              // capi_read_double(\\'fa0\\');\\n              SYSCALL.read(\"fa0\", \"double\");\\n              break;\\n            case 8n:\\n              if(document.app.$data.execution_mode_run === 0){\\n                insn_number = current_ins;\\n                instructions[current_ins]._rowVariant = \"info\";\\n                if (current_ins < instructions.length -1 || next_add_to_jump !== undefined)\\n                  instructions[(next_add_to_jump !== undefined) ? next_add_to_jump : (current_ins + 1)]._rowVariant = \\'success\\';\\n            \\n                  // instructions[current_ins +1]._rowVariant = \"success\";\\n              }\\n              document.app.$data.last_execution_mode_run = document.app.$data.execution_mode_run;\\n              document.app.$data.execution_mode_run = 2;\\n              // Manejo para strings\\n              // capi_read_string(\\'a0\\',\\'a1\\');\\n              SYSCALL.read(\"a0\", \"string\", \"a1\");\\n              break;\\n      \\n            case 12n:\\n              if(document.app.$data.execution_mode_run === 0){\\n                instructions[current_ins]._rowVariant = \"info\";\\n                if (current_ins < instructions.length -1 || next_add_to_jump !== undefined)\\n                  instructions[(next_add_to_jump !== undefined) ? next_add_to_jump : (current_ins + 1)]._rowVariant = \\'success\\';\\n                  // instructions[current_ins +1]._rowVariant = \"success\";\\n              }\\n              document.app.$data.last_execution_mode_run = document.app.$data.execution_mode_run;\\n              document.app.$data.execution_mode_run = 2;\\n              // last_execution_mode_run = document.app.$data.execution_mode_run;\\n              // document.app.$data.execution_mode_run = 2;\\n              // Manejo para char\\n              // capi_read_char(\\'a0\\');\\n              SYSCALL.read(\"a0\", \"char\");\\n              break;\\n            default:\\n              // console.log(\"No hago nada.\");\\n              syscall_print_code = syscall_code;\\n              break;\\n          }\\n      \\n          next_add_to_jump = undefined;\\n        }\\n\\n\\n\\n        instoper = instMatch[5];\\n\\n      }\\n\\n      } else if (instMatch && (parseInt(instMatch[3], 16) <= pc_min || parseInt(instMatch[3], 16) >= pc_max ))\\n        userMode64 = false;\\n\\n\\n      if (regiMatch /*&& userMode === true*/) {\\n        // En caso de ser escritura \\'<-\\' pintamos el valor en el registro que corresponde\\n        if (regiMatch[2] === \\'<-\\'){\\n          let regtowrite = crex_findReg(regiMatch[1]);\\n          if (regtowrite.indexComp === 2){\\n            if (regiMatch[3].startsWith(\"0x\")) regiMatch[3] = regiMatch[3].slice(2).replace(/^0+/, \\'\\');\\n            else regiMatch[3] = regiMatch[3].replace(/^0+/, \\'\\');\\n            if (regiMatch[3].length <= 8){\\n              regiMatch[3] = regiMatch[3].padStart(8, \"0\");\\n              writeRegister(BigInt(\"0x\" + regiMatch[3]), regtowrite.indexComp, regtowrite.indexElem, \"SFP-Reg\");\\n            }\\n            else{\\n              // if (type_toWrite === 32){\\n              //   regiMatch[3] = regiMatch[3].slice(8,16);\\n              //   writeRegister(hex2float(regiMatch[3]), regtowrite.indexComp, regtowrite.indexElem, \"SFP-Reg\");\\n              // }\\n              // else if (type_toWrite === 64)\\n              //   writeRegister(hex2double(regiMatch[3]), regtowrite.indexComp, regtowrite.indexElem, \"DFP-Reg\");\\n              // else \\n                writeRegister(BigInt(\"0x\" + regiMatch[3]), regtowrite.indexComp, regtowrite.indexElem, \"DFP-Reg\");\\n              // type_to_write = 0;\\n            }\\n          }\\n          else  \\n            writeRegister(BigInt(parseInt(regiMatch[3], 16)), regtowrite.indexComp, regtowrite.indexElem);\\n        }\\n        \\n      }\\n\\n      if (memoMatch /*&& userMode === true*/) {\\n        // En caso de ser escritura \\'<-\\' pintamos el valor en la posicion de memoria\\n        if (memoMatch[2] === \\'<-\\'){\\n\\n          writeMemory(memoMatch[3], BigInt(parseInt(memoMatch[1], 16)));\\n          // console.log(\"Operador: \", instoper);\\n          // switch(instoper){\\n          //   case \\'sh\\': // Para almacenar un half\\n          // writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'half\\');\\n              \\n          //   break;\\n          //   case \\'sb\\': // Para almacenar un byte\\n          //     writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'byte\\');\\n          //   break;\\n          //   case \\'sd\\':\\n          //     writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'dword\\');\\n          //   break;\\n          //   case \\'sw\\': // Para almacenar un int/word\\n          //     writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'word\\');\\n          //   break;\\n          //   case \\'fsw\\': // Para almacenar un float\\n          //     writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'float\\');\\n          //   break;\\n          //   case \\'fsd\\': // Para almacenar un double\\n          //     writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'double\\');\\n          //   break;\\n          //   case \\'vse8.v\\':\\n          //     writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'byte\\');\\n          //     break;\\n          //   case \\'vse16.v\\':\\n          //     writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'half\\');\\n          //     break;\\n          //   case \\'vse32.v\\':\\n          //     writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'word\\');\\n          //     break;\\n          //   case \\'vse64.v\\':\\n          //     writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'double\\');\\n          //     break;\\n          //   default:\\n          //     break;\\n          // }\\n\\n          // instoper = \"\";\\n        }\\n      \\n      }\\n\\n      \\n\\n      if(printMatch && syscall_print_code !== -1){\\n\\n        let value_2_print = printMatch[2].trim();\\n        console.log(\"Estoy dentro de ecall a imprimir\");\\n        // console.log(message);\\n        console.log(\"Valor a imprimir: \", value_2_print); \\n        switch(syscall_print_code){\\n\\n          case 1n: // Print int\\n            // SYSCALL.print(Number(parseInt(value_2_print)), \"int32\");\\n\\n            display_print(value_2_print);\\n            // display_print(full_print(parseInt(value_2_print), null, false));\\n            syscall_print_code = -1;\\n            break;\\n          case 2n: // Print float\\n            // SYSCALL.print(Number(parseFloat(value_2_print)), \"float\");\\n            display_print(value_2_print);\\n            // display_print(full_print(parseFloat(value_2_print), 0, true));\\n            syscall_print_code = -1;\\n            break;\\n\\n          case 3n: // Print double\\n            // SYSCALL.print(Number(parseFloat(value_2_print)), \"double\");\\n            display_print(value_2_print);\\n            // display_print(full_print(parseFloat(value_2_print), 0, true));\\n            syscall_print_code = -1;\\n            break;\\n\\n          case 4n: // Print String \\n            display_print(value_2_print);\\n            syscall_print_code = -1;\\n            break;\\n\\n          case 11n: // Print char\\n            // SYSCALL.print(BigInt(value_2_print.charCodeAt(0)), char);\\n            display_print(value_2_print);\\n            syscall_print_code = -1;\\n            break;\\n\\n          default: // Rest of syscall codes not able to print\\n          syscall_print_code = -1;\\n            break;\\n\\n        }\\n\\n      }\\n\\n\\n\\n      // if (!no_print_more)\\n        console.log(message);\\n\\n    }\\n\\n    Module[\\'printErr\\'] = function (message) {\\n      // if (message.includes(\"Execution:\") || message.includes(\"Instructions:\") || message.includes(\"Perf:\"))\\n      //   show_notification(message, \"success\");\\n      // else \\n      console.warn(message);\\n    }\\n\\n\\n    var out = Module[\"print\"] /*|| console.log.bind(console)*/;\\n    var err = Module[\"printErr\"] /*|| console.error.bind(console)*/;\\n\\n\\n    Object.assign(Module, moduleOverrides);\\n    moduleOverrides = null;\\n    checkIncomingModuleAPI();\\n    if (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\\n    legacyModuleProp(\"arguments\", \"arguments_\");\\n    if (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\\n    legacyModuleProp(\"thisProgram\", \"thisProgram\");\\n    assert(\\n      typeof Module[\"memoryInitializerPrefixURL\"] == \"undefined\",\\n      \"Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead\",\\n    );\\n    assert(\\n      typeof Module[\"pthreadMainPrefixURL\"] == \"undefined\",\\n      \"Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead\",\\n    );\\n    assert(\\n      typeof Module[\"cdInitializerPrefixURL\"] == \"undefined\",\\n      \"Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead\",\\n    );\\n    assert(\\n      typeof Module[\"filePackagePrefixURL\"] == \"undefined\",\\n      \"Module.filePackagePrefixURL option was removed, use Module.locateFile instead\",\\n    );\\n    assert(\\n      typeof Module[\"read\"] == \"undefined\",\\n      \"Module.read option was removed\",\\n    );\\n    assert(\\n      typeof Module[\"readAsync\"] == \"undefined\",\\n      \"Module.readAsync option was removed (modify readAsync in JS)\",\\n    );\\n    assert(\\n      typeof Module[\"readBinary\"] == \"undefined\",\\n      \"Module.readBinary option was removed (modify readBinary in JS)\",\\n    );\\n    assert(\\n      typeof Module[\"setWindowTitle\"] == \"undefined\",\\n      \"Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)\",\\n    );\\n    assert(\\n      typeof Module[\"TOTAL_MEMORY\"] == \"undefined\",\\n      \"Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY\",\\n    );\\n    legacyModuleProp(\"asm\", \"wasmExports\");\\n    legacyModuleProp(\"readAsync\", \"readAsync\");\\n    legacyModuleProp(\"readBinary\", \"readBinary\");\\n    legacyModuleProp(\"setWindowTitle\", \"setWindowTitle\");\\n    assert(\\n      !ENVIRONMENT_IS_WORKER,\\n      \"worker environment detected but not enabled at build time.  Add `worker` to `-sENVIRONMENT` to enable.\",\\n    );\\n    assert(\\n      !ENVIRONMENT_IS_NODE,\\n      \"node environment detected but not enabled at build time.  Add `node` to `-sENVIRONMENT` to enable.\",\\n    );\\n    assert(\\n      !ENVIRONMENT_IS_SHELL,\\n      \"shell environment detected but not enabled at build time.  Add `shell` to `-sENVIRONMENT` to enable.\",\\n    );\\n    var wasmBinary = Module[\"wasmBinary\"];\\n    legacyModuleProp(\"wasmBinary\", \"wasmBinary\");\\n    if (typeof WebAssembly != \"object\") {\\n      err(\"no native wasm support detected\");\\n    }\\n    var wasmMemory;\\n    var ABORT = false;\\n    var EXITSTATUS;\\n    function assert(condition, text) {\\n      if (!condition) {\\n        abort(\"Assertion failed\" + (text ? \": \" + text : \"\"));\\n      }\\n    }\\n    var HEAP8,\\n      HEAPU8,\\n      HEAP16,\\n      HEAPU16,\\n      HEAP32,\\n      HEAPU32,\\n      HEAPF32,\\n      HEAP64,\\n      HEAPU64,\\n      HEAPF64;\\n    var runtimeInitialized = false;\\n    var isFileURI = (filename) => filename.startsWith(\"file://\");\\n    function writeStackCookie() {\\n      var max = _emscripten_stack_get_end();\\n      assert((max & 3) == 0);\\n      if (max == 0) {\\n        max += 4;\\n      }\\n      HEAPU32[max / 4] = 34821223;\\n      HEAPU32[(max + 4) / 4] = 2310721022;\\n      HEAPU32[0 / 4] = 1668509029;\\n    }\\n    function checkStackCookie() {\\n      if (ABORT) return;\\n      var max = _emscripten_stack_get_end();\\n      if (max == 0) {\\n        max += 4;\\n      }\\n      var cookie1 = HEAPU32[max / 4];\\n      var cookie2 = HEAPU32[(max + 4) / 4];\\n      if (cookie1 != 34821223 || cookie2 != 2310721022) {\\n        abort(\\n          `Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`,\\n        );\\n      }\\n      if (HEAPU32[0 / 4] != 1668509029) {\\n        abort(\\n          \"Runtime error: The application has corrupted its heap memory area (address zero)!\",\\n        );\\n      }\\n    }\\n    (() => {\\n      var h16 = new Int16Array(1);\\n      var h8 = new Int8Array(h16.buffer);\\n      h16[0] = 25459;\\n      if (h8[0] !== 115 || h8[1] !== 99)\\n        throw \"Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)\";\\n    })();\\n    if (Module[\"ENVIRONMENT\"]) {\\n      throw new Error(\\n        \"Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)\",\\n      );\\n    }\\n    function legacyModuleProp(prop, newName, incoming = true) {\\n      if (!Object.getOwnPropertyDescriptor(Module, prop)) {\\n        Object.defineProperty(Module, prop, {\\n          configurable: true,\\n          get() {\\n            let extra = incoming\\n              ? \" (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\"\\n              : \"\";\\n            abort(\\n              `\\\\`Module.${prop}\\\\` has been replaced by \\\\`${newName}\\\\`` + extra,\\n            );\\n          },\\n        });\\n      }\\n    }\\n    function ignoredModuleProp(prop) {\\n      if (Object.getOwnPropertyDescriptor(Module, prop)) {\\n        abort(\\n          `\\\\`Module.${prop}\\\\` was supplied but \\\\`${prop}\\\\` not included in INCOMING_MODULE_JS_API`,\\n        );\\n      }\\n    }\\n    function isExportedByForceFilesystem(name) {\\n      return (\\n        name === \"FS_createPath\" ||\\n        name === \"FS_createDataFile\" ||\\n        name === \"FS_createPreloadedFile\" ||\\n        name === \"FS_unlink\" ||\\n        name === \"addRunDependency\" ||\\n        name === \"FS_createLazyFile\" ||\\n        name === \"FS_createDevice\" ||\\n        name === \"removeRunDependency\"\\n      );\\n    }\\n    function hookGlobalSymbolAccess(sym, func) {\\n      if (\\n        typeof globalThis != \"undefined\" &&\\n        !Object.getOwnPropertyDescriptor(globalThis, sym)\\n      ) {\\n        Object.defineProperty(globalThis, sym, {\\n          configurable: true,\\n          get() {\\n            func();\\n            return undefined;\\n          },\\n        });\\n      }\\n    }\\n    function missingGlobal(sym, msg) {\\n      hookGlobalSymbolAccess(sym, () => {\\n        warnOnce(`\\\\`${sym}\\\\` is not longer defined by emscripten. ${msg}`);\\n      });\\n    }\\n    missingGlobal(\"buffer\", \"Please use HEAP8.buffer or wasmMemory.buffer\");\\n    missingGlobal(\"asm\", \"Please use wasmExports instead\");\\n    function missingLibrarySymbol(sym) {\\n      hookGlobalSymbolAccess(sym, () => {\\n        var msg = `\\\\`${sym}\\\\` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line`;\\n        var librarySymbol = sym;\\n        if (!librarySymbol.startsWith(\"_\")) {\\n          librarySymbol = \"$\" + sym;\\n        }\\n        msg += ` (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE=\\'${librarySymbol}\\')`;\\n        if (isExportedByForceFilesystem(sym)) {\\n          msg +=\\n            \". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you\";\\n        }\\n        warnOnce(msg);\\n      });\\n      unexportedRuntimeSymbol(sym);\\n    }\\n    function unexportedRuntimeSymbol(sym) {\\n      if (!Object.getOwnPropertyDescriptor(Module, sym)) {\\n        Object.defineProperty(Module, sym, {\\n          configurable: true,\\n          get() {\\n            var msg = `\\'${sym}\\' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`;\\n            if (isExportedByForceFilesystem(sym)) {\\n              msg +=\\n                \". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you\";\\n            }\\n            abort(msg);\\n          },\\n        });\\n      }\\n    }\\n    function updateMemoryViews() {\\n      var b = wasmMemory.buffer;\\n      Module[\"HEAP8\"] = HEAP8 = new Int8Array(b);\\n      Module[\"HEAP16\"] = HEAP16 = new Int16Array(b);\\n      Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(b);\\n      Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(b);\\n      Module[\"HEAP32\"] = HEAP32 = new Int32Array(b);\\n      Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(b);\\n      Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(b);\\n      Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(b);\\n      Module[\"HEAP64\"] = HEAP64 = new BigInt64Array(b);\\n      Module[\"HEAPU64\"] = HEAPU64 = new BigUint64Array(b);\\n    }\\n    assert(\\n      !Module[\"STACK_SIZE\"],\\n      \"STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time\",\\n    );\\n    assert(\\n      typeof Int32Array != \"undefined\" &&\\n        typeof Float64Array !== \"undefined\" &&\\n        Int32Array.prototype.subarray != undefined &&\\n        Int32Array.prototype.set != undefined,\\n      \"JS engine does not provide full typed array support\",\\n    );\\n    assert(\\n      !Module[\"wasmMemory\"],\\n      \"Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally\",\\n    );\\n    assert(\\n      !Module[\"INITIAL_MEMORY\"],\\n      \"Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically\",\\n    );\\n    function preRun() {\\n      if (Module[\"preRun\"]) {\\n        if (typeof Module[\"preRun\"] == \"function\")\\n          Module[\"preRun\"] = [Module[\"preRun\"]];\\n        while (Module[\"preRun\"].length) {\\n          addOnPreRun(Module[\"preRun\"].shift());\\n        }\\n      }\\n      callRuntimeCallbacks(onPreRuns);\\n    }\\n    function initRuntime() {\\n      assert(!runtimeInitialized);\\n      runtimeInitialized = true;\\n      checkStackCookie();\\n      if (!Module[\"noFSInit\"] && !FS.initialized) FS.init();\\n      TTY.init();\\n      wasmExports[\"__wasm_call_ctors\"]();\\n      FS.ignorePermissions = false;\\n    }\\n    function preMain() {\\n      checkStackCookie();\\n    }\\n    function postRun() {\\n      checkStackCookie();\\n      if (Module[\"postRun\"]) {\\n        if (typeof Module[\"postRun\"] == \"function\")\\n          Module[\"postRun\"] = [Module[\"postRun\"]];\\n        while (Module[\"postRun\"].length) {\\n          addOnPostRun(Module[\"postRun\"].shift());\\n        }\\n      }\\n      callRuntimeCallbacks(onPostRuns);\\n    }\\n    var runDependencies = 0;\\n    var dependenciesFulfilled = null;\\n    var runDependencyTracking = {};\\n    var runDependencyWatcher = null;\\n    function getUniqueRunDependency(id) {\\n      var orig = id;\\n      while (1) {\\n        if (!runDependencyTracking[id]) return id;\\n        id = orig + Math.random();\\n      }\\n    }\\n    function addRunDependency(id) {\\n      runDependencies++;\\n      Module[\"monitorRunDependencies\"]?.(runDependencies);\\n      if (id) {\\n        assert(!runDependencyTracking[id]);\\n        runDependencyTracking[id] = 1;\\n        if (\\n          runDependencyWatcher === null &&\\n          typeof setInterval != \"undefined\"\\n        ) {\\n          runDependencyWatcher = setInterval(() => {\\n            if (ABORT) {\\n              clearInterval(runDependencyWatcher);\\n              runDependencyWatcher = null;\\n              return;\\n            }\\n            var shown = false;\\n            for (var dep in runDependencyTracking) {\\n              if (!shown) {\\n                shown = true;\\n                err(\"still waiting on run dependencies:\");\\n              }\\n              err(`dependency: ${dep}`);\\n            }\\n            if (shown) {\\n              err(\"(end of list)\");\\n            }\\n          }, 1e4);\\n        }\\n      } else {\\n        err(\"warning: run dependency added without ID\");\\n      }\\n    }\\n    function removeRunDependency(id) {\\n      runDependencies--;\\n      Module[\"monitorRunDependencies\"]?.(runDependencies);\\n      if (id) {\\n        assert(runDependencyTracking[id]);\\n        delete runDependencyTracking[id];\\n      } else {\\n        err(\"warning: run dependency removed without ID\");\\n      }\\n      if (runDependencies == 0) {\\n        if (runDependencyWatcher !== null) {\\n          clearInterval(runDependencyWatcher);\\n          runDependencyWatcher = null;\\n        }\\n        if (dependenciesFulfilled) {\\n          var callback = dependenciesFulfilled;\\n          dependenciesFulfilled = null;\\n          callback();\\n        }\\n      }\\n    }\\n    function abort(what) {\\n      Module[\"onAbort\"]?.(what);\\n      what = \"Aborted(\" + what + \")\";\\n      err(what);\\n      ABORT = true;\\n      if (what.indexOf(\"RuntimeError: unreachable\") >= 0) {\\n        what +=\\n          \\'. \"unreachable\" may be due to ASYNCIFY_STACK_SIZE not being large enough (try increasing it)\\';\\n      }\\n      var e = new WebAssembly.RuntimeError(what);\\n      readyPromiseReject(e);\\n      throw e;\\n    }\\n    function createExportWrapper(name, nargs) {\\n      return (...args) => {\\n        assert(\\n          runtimeInitialized,\\n          `native function \\\\`${name}\\\\` called before runtime initialization`,\\n        );\\n        var f = wasmExports[name];\\n        assert(f, `exported native function \\\\`${name}\\\\` not found`);\\n        assert(\\n          args.length <= nargs,\\n          `native function \\\\`${name}\\\\` called with ${args.length} args but expects ${nargs}`,\\n        );\\n        return f(...args);\\n      };\\n    }\\n    var wasmBinaryFile;\\n    function findWasmBinary() {\\n      if (Module[\"locateFile\"]) {\\n        return locateFile(\"riscv_sim_RV64.wasm\");\\n      }\\n      return new URL(\"riscv_sim_RV64.wasm\", import.meta.url).href;\\n    }\\n    function getBinarySync(file) {\\n      if (file == wasmBinaryFile && wasmBinary) {\\n        return new Uint8Array(wasmBinary);\\n      }\\n      if (readBinary) {\\n        return readBinary(file);\\n      }\\n      throw \"both async and sync fetching of the wasm failed\";\\n    }\\n    async function getWasmBinary(binaryFile) {\\n      if (!wasmBinary) {\\n        try {\\n          var response = await readAsync(binaryFile);\\n          return new Uint8Array(response);\\n        } catch {}\\n      }\\n      return getBinarySync(binaryFile);\\n    }\\n    async function instantiateArrayBuffer(binaryFile, imports) {\\n      try {\\n        var binary = await getWasmBinary(binaryFile);\\n        var instance = await WebAssembly.instantiate(binary, imports);\\n        return instance;\\n      } catch (reason) {\\n        err(`failed to asynchronously prepare wasm: ${reason}`);\\n        if (isFileURI(wasmBinaryFile)) {\\n          err(\\n            `warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`,\\n          );\\n        }\\n        abort(reason);\\n      }\\n    }\\n    async function instantiateAsync(binary, binaryFile, imports) {\\n      if (!binary && typeof WebAssembly.instantiateStreaming == \"function\") {\\n        try {\\n          var response = fetch(binaryFile, { credentials: \"same-origin\" });\\n          var instantiationResult = await WebAssembly.instantiateStreaming(\\n            response,\\n            imports,\\n          );\\n          return instantiationResult;\\n        } catch (reason) {\\n          err(`wasm streaming compile failed: ${reason}`);\\n          err(\"falling back to ArrayBuffer instantiation\");\\n        }\\n      }\\n      return instantiateArrayBuffer(binaryFile, imports);\\n    }\\n    function getWasmImports() {\\n      Asyncify.instrumentWasmImports(wasmImports);\\n      return { env: wasmImports, wasi_snapshot_preview1: wasmImports };\\n    }\\n    async function createWasm() {\\n      function receiveInstance(instance, module) {\\n        wasmExports = instance.exports;\\n        wasmExports = Asyncify.instrumentWasmExports(wasmExports);\\n        wasmExports = applySignatureConversions(wasmExports);\\n        wasmMemory = wasmExports[\"memory\"];\\n        assert(wasmMemory, \"memory not found in wasm exports\");\\n        updateMemoryViews();\\n        removeRunDependency(\"wasm-instantiate\");\\n        return wasmExports;\\n      }\\n      addRunDependency(\"wasm-instantiate\");\\n      var trueModule = Module;\\n      function receiveInstantiationResult(result) {\\n        assert(\\n          Module === trueModule,\\n          \"the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?\",\\n        );\\n        trueModule = null;\\n        return receiveInstance(result[\"instance\"]);\\n      }\\n      var info = getWasmImports();\\n      if (Module[\"instantiateWasm\"]) {\\n        return new Promise((resolve, reject) => {\\n          try {\\n            Module[\"instantiateWasm\"](info, (mod, inst) => {\\n              receiveInstance(mod, inst);\\n              resolve(mod.exports);\\n            });\\n          } catch (e) {\\n            err(`Module.instantiateWasm callback failed with error: ${e}`);\\n            reject(e);\\n          }\\n        });\\n      }\\n      wasmBinaryFile ??= findWasmBinary();\\n      try {\\n        var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);\\n        var exports = receiveInstantiationResult(result);\\n        return exports;\\n      } catch (e) {\\n        readyPromiseReject(e);\\n        return Promise.reject(e);\\n      }\\n    }\\n    class ExitStatus {\\n      name = \"ExitStatus\";\\n      constructor(status) {\\n        this.message = `Program terminated with exit(${status})`;\\n        this.status = status;\\n      }\\n    }\\n    var callRuntimeCallbacks = (callbacks) => {\\n      while (callbacks.length > 0) {\\n        callbacks.shift()(Module);\\n      }\\n    };\\n    var onPostRuns = [];\\n    var addOnPostRun = (cb) => onPostRuns.unshift(cb);\\n    var onPreRuns = [];\\n    var addOnPreRun = (cb) => onPreRuns.unshift(cb);\\n    var noExitRuntime = Module[\"noExitRuntime\"] || true;\\n    var ptrToString = (ptr) => {\\n      assert(typeof ptr === \"number\");\\n      return \"0x\" + ptr.toString(16).padStart(8, \"0\");\\n    };\\n    var stackRestore = (val) => __emscripten_stack_restore(val);\\n    var stackSave = () => _emscripten_stack_get_current();\\n    var warnOnce = (text) => {\\n      warnOnce.shown ||= {};\\n      if (!warnOnce.shown[text]) {\\n        warnOnce.shown[text] = 1;\\n        err(text);\\n      }\\n    };\\n    var INT53_MAX = 9007199254740992;\\n    var INT53_MIN = -9007199254740992;\\n    var bigintToI53Checked = (num) =>\\n      num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);\\n    var UTF8Decoder =\\n      typeof TextDecoder != \"undefined\" ? new TextDecoder() : undefined;\\n    var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {\\n      var endIdx = idx + maxBytesToRead;\\n      var endPtr = idx;\\n      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\\n      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\\n        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\\n      }\\n      var str = \"\";\\n      while (idx < endPtr) {\\n        var u0 = heapOrArray[idx++];\\n        if (!(u0 & 128)) {\\n          str += String.fromCharCode(u0);\\n          continue;\\n        }\\n        var u1 = heapOrArray[idx++] & 63;\\n        if ((u0 & 224) == 192) {\\n          str += String.fromCharCode(((u0 & 31) << 6) | u1);\\n          continue;\\n        }\\n        var u2 = heapOrArray[idx++] & 63;\\n        if ((u0 & 240) == 224) {\\n          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\\n        } else {\\n          if ((u0 & 248) != 240)\\n            warnOnce(\\n              \"Invalid UTF-8 leading byte \" +\\n                ptrToString(u0) +\\n                \" encountered when deserializing a UTF-8 string in wasm memory to a JS string!\",\\n            );\\n          u0 =\\n            ((u0 & 7) << 18) |\\n            (u1 << 12) |\\n            (u2 << 6) |\\n            (heapOrArray[idx++] & 63);\\n        }\\n        if (u0 < 65536) {\\n          str += String.fromCharCode(u0);\\n        } else {\\n          var ch = u0 - 65536;\\n          str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));\\n        }\\n      }\\n      return str;\\n    };\\n    var UTF8ToString = (ptr, maxBytesToRead) => {\\n      assert(\\n        typeof ptr == \"number\",\\n        `UTF8ToString expects a number (got ${typeof ptr})`,\\n      );\\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\\n    };\\n    function ___assert_fail(condition, filename, line, func) {\\n      condition = bigintToI53Checked(condition);\\n      filename = bigintToI53Checked(filename);\\n      func = bigintToI53Checked(func);\\n      return abort(\\n        `Assertion failed: ${UTF8ToString(condition)}, at: ` +\\n          [\\n            filename ? UTF8ToString(filename) : \"unknown filename\",\\n            line,\\n            func ? UTF8ToString(func) : \"unknown function\",\\n          ],\\n      );\\n    }\\n    var syscallGetVarargP = () => {\\n      assert(SYSCALLS.varargs != undefined);\\n      var ret = Number(HEAPU64[SYSCALLS.varargs / 8]);\\n      SYSCALLS.varargs += 8;\\n      return ret;\\n    };\\n    var syscallGetVarargI = () => {\\n      assert(SYSCALLS.varargs != undefined);\\n      var ret = HEAP32[+SYSCALLS.varargs / 4];\\n      SYSCALLS.varargs += 4;\\n      return ret;\\n    };\\n    var PATH = {\\n      isAbs: (path) => path.charAt(0) === \"/\",\\n      splitPath: (filename) => {\\n        var splitPathRe =\\n          /^(\\\\/?|)([\\\\s\\\\S]*?)((?:\\\\.{1,2}|[^\\\\/]+?|)(\\\\.[^.\\\\/]*|))(?:[\\\\/]*)$/;\\n        return splitPathRe.exec(filename).slice(1);\\n      },\\n      normalizeArray: (parts, allowAboveRoot) => {\\n        var up = 0;\\n        for (var i = parts.length - 1; i >= 0; i--) {\\n          var last = parts[i];\\n          if (last === \".\") {\\n            parts.splice(i, 1);\\n          } else if (last === \"..\") {\\n            parts.splice(i, 1);\\n            up++;\\n          } else if (up) {\\n            parts.splice(i, 1);\\n            up--;\\n          }\\n        }\\n        if (allowAboveRoot) {\\n          for (; up; up--) {\\n            parts.unshift(\"..\");\\n          }\\n        }\\n        return parts;\\n      },\\n      normalize: (path) => {\\n        var isAbsolute = PATH.isAbs(path),\\n          trailingSlash = path.slice(-1) === \"/\";\\n        path = PATH.normalizeArray(\\n          path.split(\"/\").filter((p) => !!p),\\n          !isAbsolute,\\n        ).join(\"/\");\\n        if (!path && !isAbsolute) {\\n          path = \".\";\\n        }\\n        if (path && trailingSlash) {\\n          path += \"/\";\\n        }\\n        return (isAbsolute ? \"/\" : \"\") + path;\\n      },\\n      dirname: (path) => {\\n        var result = PATH.splitPath(path),\\n          root = result[0],\\n          dir = result[1];\\n        if (!root && !dir) {\\n          return \".\";\\n        }\\n        if (dir) {\\n          dir = dir.slice(0, -1);\\n        }\\n        return root + dir;\\n      },\\n      basename: (path) => path && path.match(/([^\\\\/]+|\\\\/)\\\\/*$/)[1],\\n      join: (...paths) => PATH.normalize(paths.join(\"/\")),\\n      join2: (l, r) => PATH.normalize(l + \"/\" + r),\\n    };\\n    var initRandomFill = () => (view) => crypto.getRandomValues(view);\\n    var randomFill = (view) => {\\n      (randomFill = initRandomFill())(view);\\n    };\\n    var PATH_FS = {\\n      resolve: (...args) => {\\n        var resolvedPath = \"\",\\n          resolvedAbsolute = false;\\n        for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\\n          var path = i >= 0 ? args[i] : FS.cwd();\\n          if (typeof path != \"string\") {\\n            throw new TypeError(\"Arguments to path.resolve must be strings\");\\n          } else if (!path) {\\n            return \"\";\\n          }\\n          resolvedPath = path + \"/\" + resolvedPath;\\n          resolvedAbsolute = PATH.isAbs(path);\\n        }\\n        resolvedPath = PATH.normalizeArray(\\n          resolvedPath.split(\"/\").filter((p) => !!p),\\n          !resolvedAbsolute,\\n        ).join(\"/\");\\n        return (resolvedAbsolute ? \"/\" : \"\") + resolvedPath || \".\";\\n      },\\n      relative: (from, to) => {\\n        from = PATH_FS.resolve(from).slice(1);\\n        to = PATH_FS.resolve(to).slice(1);\\n        function trim(arr) {\\n          var start = 0;\\n          for (; start < arr.length; start++) {\\n            if (arr[start] !== \"\") break;\\n          }\\n          var end = arr.length - 1;\\n          for (; end >= 0; end--) {\\n            if (arr[end] !== \"\") break;\\n          }\\n          if (start > end) return [];\\n          return arr.slice(start, end - start + 1);\\n        }\\n        var fromParts = trim(from.split(\"/\"));\\n        var toParts = trim(to.split(\"/\"));\\n        var length = Math.min(fromParts.length, toParts.length);\\n        var samePartsLength = length;\\n        for (var i = 0; i < length; i++) {\\n          if (fromParts[i] !== toParts[i]) {\\n            samePartsLength = i;\\n            break;\\n          }\\n        }\\n        var outputParts = [];\\n        for (var i = samePartsLength; i < fromParts.length; i++) {\\n          outputParts.push(\"..\");\\n        }\\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\\n        return outputParts.join(\"/\");\\n      },\\n    };\\n    var FS_stdin_getChar_buffer = [];\\n    var lengthBytesUTF8 = (str) => {\\n      var len = 0;\\n      for (var i = 0; i < str.length; ++i) {\\n        var c = str.charCodeAt(i);\\n        if (c <= 127) {\\n          len++;\\n        } else if (c <= 2047) {\\n          len += 2;\\n        } else if (c >= 55296 && c <= 57343) {\\n          len += 4;\\n          ++i;\\n        } else {\\n          len += 3;\\n        }\\n      }\\n      return len;\\n    };\\n    var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\\n      assert(\\n        typeof str === \"string\",\\n        `stringToUTF8Array expects a string (got ${typeof str})`,\\n      );\\n      if (!(maxBytesToWrite > 0)) return 0;\\n      var startIdx = outIdx;\\n      var endIdx = outIdx + maxBytesToWrite - 1;\\n      for (var i = 0; i < str.length; ++i) {\\n        var u = str.charCodeAt(i);\\n        if (u >= 55296 && u <= 57343) {\\n          var u1 = str.charCodeAt(++i);\\n          u = (65536 + ((u & 1023) << 10)) | (u1 & 1023);\\n        }\\n        if (u <= 127) {\\n          if (outIdx >= endIdx) break;\\n          heap[outIdx++] = u;\\n        } else if (u <= 2047) {\\n          if (outIdx + 1 >= endIdx) break;\\n          heap[outIdx++] = 192 | (u >> 6);\\n          heap[outIdx++] = 128 | (u & 63);\\n        } else if (u <= 65535) {\\n          if (outIdx + 2 >= endIdx) break;\\n          heap[outIdx++] = 224 | (u >> 12);\\n          heap[outIdx++] = 128 | ((u >> 6) & 63);\\n          heap[outIdx++] = 128 | (u & 63);\\n        } else {\\n          if (outIdx + 3 >= endIdx) break;\\n          if (u > 1114111)\\n            warnOnce(\\n              \"Invalid Unicode code point \" +\\n                ptrToString(u) +\\n                \" encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).\",\\n            );\\n          heap[outIdx++] = 240 | (u >> 18);\\n          heap[outIdx++] = 128 | ((u >> 12) & 63);\\n          heap[outIdx++] = 128 | ((u >> 6) & 63);\\n          heap[outIdx++] = 128 | (u & 63);\\n        }\\n      }\\n      heap[outIdx] = 0;\\n      return outIdx - startIdx;\\n    };\\n    var intArrayFromString = (stringy, dontAddNull, length) => {\\n      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\\n      var u8array = new Array(len);\\n      var numBytesWritten = stringToUTF8Array(\\n        stringy,\\n        u8array,\\n        0,\\n        u8array.length,\\n      );\\n      if (dontAddNull) u8array.length = numBytesWritten;\\n      return u8array;\\n    };\\n    var FS_stdin_getChar = () => {\\n      if (!FS_stdin_getChar_buffer.length) {\\n        var result = null;\\n        if (\\n          typeof window != \"undefined\" &&\\n          typeof window.prompt == \"function\"\\n        ) {\\n          result = window.prompt(\"Input: \");\\n          if (result !== null) {\\n            result += \"\\\\n\";\\n          }\\n        } else {\\n        }\\n        if (!result) {\\n          return null;\\n        }\\n        FS_stdin_getChar_buffer = intArrayFromString(result, true);\\n      }\\n      return FS_stdin_getChar_buffer.shift();\\n    };\\n    var TTY = {\\n      ttys: [],\\n      init() {},\\n      shutdown() {},\\n      register(dev, ops) {\\n        TTY.ttys[dev] = { input: [], output: [], ops };\\n        FS.registerDevice(dev, TTY.stream_ops);\\n      },\\n      stream_ops: {\\n        open(stream) {\\n          var tty = TTY.ttys[stream.node.rdev];\\n          if (!tty) {\\n            throw new FS.ErrnoError(43);\\n          }\\n          stream.tty = tty;\\n          stream.seekable = false;\\n        },\\n        close(stream) {\\n          stream.tty.ops.fsync(stream.tty);\\n        },\\n        fsync(stream) {\\n          stream.tty.ops.fsync(stream.tty);\\n        },\\n        read(stream, buffer, offset, length, pos) {\\n          if (!stream.tty || !stream.tty.ops.get_char) {\\n            throw new FS.ErrnoError(60);\\n          }\\n          var bytesRead = 0;\\n          for (var i = 0; i < length; i++) {\\n            var result;\\n            try {\\n              result = stream.tty.ops.get_char(stream.tty);\\n            } catch (e) {\\n              throw new FS.ErrnoError(29);\\n            }\\n            if (result === undefined && bytesRead === 0) {\\n              throw new FS.ErrnoError(6);\\n            }\\n            if (result === null || result === undefined) break;\\n            bytesRead++;\\n            buffer[offset + i] = result;\\n          }\\n          if (bytesRead) {\\n            stream.node.atime = Date.now();\\n          }\\n          return bytesRead;\\n        },\\n        write(stream, buffer, offset, length, pos) {\\n          if (!stream.tty || !stream.tty.ops.put_char) {\\n            throw new FS.ErrnoError(60);\\n          }\\n          try {\\n            for (var i = 0; i < length; i++) {\\n              stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\\n            }\\n          } catch (e) {\\n            throw new FS.ErrnoError(29);\\n          }\\n          if (length) {\\n            stream.node.mtime = stream.node.ctime = Date.now();\\n          }\\n          return i;\\n        },\\n      },\\n      default_tty_ops: {\\n        get_char(tty) {\\n          return FS_stdin_getChar();\\n        },\\n        put_char(tty, val) {\\n          if (val === null || val === 10) {\\n            out(UTF8ArrayToString(tty.output));\\n            tty.output = [];\\n          } else {\\n            if (val != 0) tty.output.push(val);\\n          }\\n        },\\n        fsync(tty) {\\n          if (tty.output?.length > 0) {\\n            out(UTF8ArrayToString(tty.output));\\n            tty.output = [];\\n          }\\n        },\\n        ioctl_tcgets(tty) {\\n          return {\\n            c_iflag: 25856,\\n            c_oflag: 5,\\n            c_cflag: 191,\\n            c_lflag: 35387,\\n            c_cc: [\\n              3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0,\\n              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n            ],\\n          };\\n        },\\n        ioctl_tcsets(tty, optional_actions, data) {\\n          return 0;\\n        },\\n        ioctl_tiocgwinsz(tty) {\\n          return [24, 80];\\n        },\\n      },\\n      default_tty1_ops: {\\n        put_char(tty, val) {\\n          if (val === null || val === 10) {\\n            err(UTF8ArrayToString(tty.output));\\n            tty.output = [];\\n          } else {\\n            if (val != 0) tty.output.push(val);\\n          }\\n        },\\n        fsync(tty) {\\n          if (tty.output?.length > 0) {\\n            err(UTF8ArrayToString(tty.output));\\n            tty.output = [];\\n          }\\n        },\\n      },\\n    };\\n    var zeroMemory = (address, size) => {\\n      HEAPU8.fill(0, address, address + size);\\n    };\\n    var alignMemory = (size, alignment) => {\\n      assert(alignment, \"alignment argument is required\");\\n      return Math.ceil(size / alignment) * alignment;\\n    };\\n    var mmapAlloc = (size) => {\\n      size = alignMemory(size, 65536);\\n      var ptr = _emscripten_builtin_memalign(65536, size);\\n      if (ptr) zeroMemory(ptr, size);\\n      return ptr;\\n    };\\n    var MEMFS = {\\n      ops_table: null,\\n      mount(mount) {\\n        return MEMFS.createNode(null, \"/\", 16895, 0);\\n      },\\n      createNode(parent, name, mode, dev) {\\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\\n          throw new FS.ErrnoError(63);\\n        }\\n        MEMFS.ops_table ||= {\\n          dir: {\\n            node: {\\n              getattr: MEMFS.node_ops.getattr,\\n              setattr: MEMFS.node_ops.setattr,\\n              lookup: MEMFS.node_ops.lookup,\\n              mknod: MEMFS.node_ops.mknod,\\n              rename: MEMFS.node_ops.rename,\\n              unlink: MEMFS.node_ops.unlink,\\n              rmdir: MEMFS.node_ops.rmdir,\\n              readdir: MEMFS.node_ops.readdir,\\n              symlink: MEMFS.node_ops.symlink,\\n            },\\n            stream: { llseek: MEMFS.stream_ops.llseek },\\n          },\\n          file: {\\n            node: {\\n              getattr: MEMFS.node_ops.getattr,\\n              setattr: MEMFS.node_ops.setattr,\\n            },\\n            stream: {\\n              llseek: MEMFS.stream_ops.llseek,\\n              read: MEMFS.stream_ops.read,\\n              write: MEMFS.stream_ops.write,\\n              allocate: MEMFS.stream_ops.allocate,\\n              mmap: MEMFS.stream_ops.mmap,\\n              msync: MEMFS.stream_ops.msync,\\n            },\\n          },\\n          link: {\\n            node: {\\n              getattr: MEMFS.node_ops.getattr,\\n              setattr: MEMFS.node_ops.setattr,\\n              readlink: MEMFS.node_ops.readlink,\\n            },\\n            stream: {},\\n          },\\n          chrdev: {\\n            node: {\\n              getattr: MEMFS.node_ops.getattr,\\n              setattr: MEMFS.node_ops.setattr,\\n            },\\n            stream: FS.chrdev_stream_ops,\\n          },\\n        };\\n        var node = FS.createNode(parent, name, mode, dev);\\n        if (FS.isDir(node.mode)) {\\n          node.node_ops = MEMFS.ops_table.dir.node;\\n          node.stream_ops = MEMFS.ops_table.dir.stream;\\n          node.contents = {};\\n        } else if (FS.isFile(node.mode)) {\\n          node.node_ops = MEMFS.ops_table.file.node;\\n          node.stream_ops = MEMFS.ops_table.file.stream;\\n          node.usedBytes = 0;\\n          node.contents = null;\\n        } else if (FS.isLink(node.mode)) {\\n          node.node_ops = MEMFS.ops_table.link.node;\\n          node.stream_ops = MEMFS.ops_table.link.stream;\\n        } else if (FS.isChrdev(node.mode)) {\\n          node.node_ops = MEMFS.ops_table.chrdev.node;\\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\\n        }\\n        node.atime = node.mtime = node.ctime = Date.now();\\n        if (parent) {\\n          parent.contents[name] = node;\\n          parent.atime = parent.mtime = parent.ctime = node.atime;\\n        }\\n        return node;\\n      },\\n      getFileDataAsTypedArray(node) {\\n        if (!node.contents) return new Uint8Array(0);\\n        if (node.contents.subarray)\\n          return node.contents.subarray(0, node.usedBytes);\\n        return new Uint8Array(node.contents);\\n      },\\n      expandFileStorage(node, newCapacity) {\\n        var prevCapacity = node.contents ? node.contents.length : 0;\\n        if (prevCapacity >= newCapacity) return;\\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\\n        newCapacity = Math.max(\\n          newCapacity,\\n          (prevCapacity *\\n            (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125)) >>>\\n            0,\\n        );\\n        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\\n        var oldContents = node.contents;\\n        node.contents = new Uint8Array(newCapacity);\\n        if (node.usedBytes > 0)\\n          node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\\n      },\\n      resizeFileStorage(node, newSize) {\\n        if (node.usedBytes == newSize) return;\\n        if (newSize == 0) {\\n          node.contents = null;\\n          node.usedBytes = 0;\\n        } else {\\n          var oldContents = node.contents;\\n          node.contents = new Uint8Array(newSize);\\n          if (oldContents) {\\n            node.contents.set(\\n              oldContents.subarray(0, Math.min(newSize, node.usedBytes)),\\n            );\\n          }\\n          node.usedBytes = newSize;\\n        }\\n      },\\n      node_ops: {\\n        getattr(node) {\\n          var attr = {};\\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\\n          attr.ino = node.id;\\n          attr.mode = node.mode;\\n          attr.nlink = 1;\\n          attr.uid = 0;\\n          attr.gid = 0;\\n          attr.rdev = node.rdev;\\n          if (FS.isDir(node.mode)) {\\n            attr.size = 4096;\\n          } else if (FS.isFile(node.mode)) {\\n            attr.size = node.usedBytes;\\n          } else if (FS.isLink(node.mode)) {\\n            attr.size = node.link.length;\\n          } else {\\n            attr.size = 0;\\n          }\\n          attr.atime = new Date(node.atime);\\n          attr.mtime = new Date(node.mtime);\\n          attr.ctime = new Date(node.ctime);\\n          attr.blksize = 4096;\\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\\n          return attr;\\n        },\\n        setattr(node, attr) {\\n          for (const key of [\"mode\", \"atime\", \"mtime\", \"ctime\"]) {\\n            if (attr[key] != null) {\\n              node[key] = attr[key];\\n            }\\n          }\\n          if (attr.size !== undefined) {\\n            MEMFS.resizeFileStorage(node, attr.size);\\n          }\\n        },\\n        lookup(parent, name) {\\n          throw new FS.ErrnoError(44);\\n        },\\n        mknod(parent, name, mode, dev) {\\n          return MEMFS.createNode(parent, name, mode, dev);\\n        },\\n        rename(old_node, new_dir, new_name) {\\n          var new_node;\\n          try {\\n            new_node = FS.lookupNode(new_dir, new_name);\\n          } catch (e) {}\\n          if (new_node) {\\n            if (FS.isDir(old_node.mode)) {\\n              for (var i in new_node.contents) {\\n                throw new FS.ErrnoError(55);\\n              }\\n            }\\n            FS.hashRemoveNode(new_node);\\n          }\\n          delete old_node.parent.contents[old_node.name];\\n          new_dir.contents[new_name] = old_node;\\n          old_node.name = new_name;\\n          new_dir.ctime =\\n            new_dir.mtime =\\n            old_node.parent.ctime =\\n            old_node.parent.mtime =\\n              Date.now();\\n        },\\n        unlink(parent, name) {\\n          delete parent.contents[name];\\n          parent.ctime = parent.mtime = Date.now();\\n        },\\n        rmdir(parent, name) {\\n          var node = FS.lookupNode(parent, name);\\n          for (var i in node.contents) {\\n            throw new FS.ErrnoError(55);\\n          }\\n          delete parent.contents[name];\\n          parent.ctime = parent.mtime = Date.now();\\n        },\\n        readdir(node) {\\n          return [\".\", \"..\", ...Object.keys(node.contents)];\\n        },\\n        symlink(parent, newname, oldpath) {\\n          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\\n          node.link = oldpath;\\n          return node;\\n        },\\n        readlink(node) {\\n          if (!FS.isLink(node.mode)) {\\n            throw new FS.ErrnoError(28);\\n          }\\n          return node.link;\\n        },\\n      },\\n      stream_ops: {\\n        read(stream, buffer, offset, length, position) {\\n          var contents = stream.node.contents;\\n          if (position >= stream.node.usedBytes) return 0;\\n          var size = Math.min(stream.node.usedBytes - position, length);\\n          assert(size >= 0);\\n          if (size > 8 && contents.subarray) {\\n            buffer.set(contents.subarray(position, position + size), offset);\\n          } else {\\n            for (var i = 0; i < size; i++)\\n              buffer[offset + i] = contents[position + i];\\n          }\\n          return size;\\n        },\\n        write(stream, buffer, offset, length, position, canOwn) {\\n          assert(!(buffer instanceof ArrayBuffer));\\n          if (buffer.buffer === HEAP8.buffer) {\\n            canOwn = false;\\n          }\\n          if (!length) return 0;\\n          var node = stream.node;\\n          node.mtime = node.ctime = Date.now();\\n          if (buffer.subarray && (!node.contents || node.contents.subarray)) {\\n            if (canOwn) {\\n              assert(\\n                position === 0,\\n                \"canOwn must imply no weird position inside the file\",\\n              );\\n              node.contents = buffer.subarray(offset, offset + length);\\n              node.usedBytes = length;\\n              return length;\\n            } else if (node.usedBytes === 0 && position === 0) {\\n              node.contents = buffer.slice(offset, offset + length);\\n              node.usedBytes = length;\\n              return length;\\n            } else if (position + length <= node.usedBytes) {\\n              node.contents.set(\\n                buffer.subarray(offset, offset + length),\\n                position,\\n              );\\n              return length;\\n            }\\n          }\\n          MEMFS.expandFileStorage(node, position + length);\\n          if (node.contents.subarray && buffer.subarray) {\\n            node.contents.set(\\n              buffer.subarray(offset, offset + length),\\n              position,\\n            );\\n          } else {\\n            for (var i = 0; i < length; i++) {\\n              node.contents[position + i] = buffer[offset + i];\\n            }\\n          }\\n          node.usedBytes = Math.max(node.usedBytes, position + length);\\n          return length;\\n        },\\n        llseek(stream, offset, whence) {\\n          var position = offset;\\n          if (whence === 1) {\\n            position += stream.position;\\n          } else if (whence === 2) {\\n            if (FS.isFile(stream.node.mode)) {\\n              position += stream.node.usedBytes;\\n            }\\n          }\\n          if (position < 0) {\\n            throw new FS.ErrnoError(28);\\n          }\\n          return position;\\n        },\\n        allocate(stream, offset, length) {\\n          MEMFS.expandFileStorage(stream.node, offset + length);\\n          stream.node.usedBytes = Math.max(\\n            stream.node.usedBytes,\\n            offset + length,\\n          );\\n        },\\n        mmap(stream, length, position, prot, flags) {\\n          if (!FS.isFile(stream.node.mode)) {\\n            throw new FS.ErrnoError(43);\\n          }\\n          var ptr;\\n          var allocated;\\n          var contents = stream.node.contents;\\n          if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {\\n            allocated = false;\\n            ptr = contents.byteOffset;\\n          } else {\\n            allocated = true;\\n            ptr = mmapAlloc(length);\\n            if (!ptr) {\\n              throw new FS.ErrnoError(48);\\n            }\\n            if (contents) {\\n              if (position > 0 || position + length < contents.length) {\\n                if (contents.subarray) {\\n                  contents = contents.subarray(position, position + length);\\n                } else {\\n                  contents = Array.prototype.slice.call(\\n                    contents,\\n                    position,\\n                    position + length,\\n                  );\\n                }\\n              }\\n              HEAP8.set(contents, ptr);\\n            }\\n          }\\n          return { ptr, allocated };\\n        },\\n        msync(stream, buffer, offset, length, mmapFlags) {\\n          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\\n          return 0;\\n        },\\n      },\\n    };\\n    var asyncLoad = async (url) => {\\n      var arrayBuffer = await readAsync(url);\\n      assert(\\n        arrayBuffer,\\n        `Loading data file \"${url}\" failed (no arrayBuffer).`,\\n      );\\n      return new Uint8Array(arrayBuffer);\\n    };\\n    asyncLoad.isAsync = true;\\n    var FS_createDataFile = (\\n      parent,\\n      name,\\n      fileData,\\n      canRead,\\n      canWrite,\\n      canOwn,\\n    ) => {\\n      FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);\\n    };\\n    var preloadPlugins = Module[\"preloadPlugins\"] || [];\\n    var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {\\n      if (typeof Browser != \"undefined\") Browser.init();\\n      var handled = false;\\n      preloadPlugins.forEach((plugin) => {\\n        if (handled) return;\\n        if (plugin[\"canHandle\"](fullname)) {\\n          plugin[\"handle\"](byteArray, fullname, finish, onerror);\\n          handled = true;\\n        }\\n      });\\n      return handled;\\n    };\\n    var FS_createPreloadedFile = (\\n      parent,\\n      name,\\n      url,\\n      canRead,\\n      canWrite,\\n      onload,\\n      onerror,\\n      dontCreateFile,\\n      canOwn,\\n      preFinish,\\n    ) => {\\n      var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\\n      var dep = getUniqueRunDependency(`cp ${fullname}`);\\n      function processData(byteArray) {\\n        function finish(byteArray) {\\n          preFinish?.();\\n          if (!dontCreateFile) {\\n            FS_createDataFile(\\n              parent,\\n              name,\\n              byteArray,\\n              canRead,\\n              canWrite,\\n              canOwn,\\n            );\\n          }\\n          onload?.();\\n          removeRunDependency(dep);\\n        }\\n        if (\\n          FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {\\n            onerror?.();\\n            removeRunDependency(dep);\\n          })\\n        ) {\\n          return;\\n        }\\n        finish(byteArray);\\n      }\\n      addRunDependency(dep);\\n      if (typeof url == \"string\") {\\n        asyncLoad(url).then(processData, onerror);\\n      } else {\\n        processData(url);\\n      }\\n    };\\n    var FS_modeStringToFlags = (str) => {\\n      var flagModes = {\\n        r: 0,\\n        \"r+\": 2,\\n        w: 512 | 64 | 1,\\n        \"w+\": 512 | 64 | 2,\\n        a: 1024 | 64 | 1,\\n        \"a+\": 1024 | 64 | 2,\\n      };\\n      var flags = flagModes[str];\\n      if (typeof flags == \"undefined\") {\\n        throw new Error(`Unknown file open mode: ${str}`);\\n      }\\n      return flags;\\n    };\\n    var FS_getMode = (canRead, canWrite) => {\\n      var mode = 0;\\n      if (canRead) mode |= 292 | 73;\\n      if (canWrite) mode |= 146;\\n      return mode;\\n    };\\n    var strError = (errno) => UTF8ToString(_strerror(errno));\\n    var ERRNO_CODES = {\\n      EPERM: 63,\\n      ENOENT: 44,\\n      ESRCH: 71,\\n      EINTR: 27,\\n      EIO: 29,\\n      ENXIO: 60,\\n      E2BIG: 1,\\n      ENOEXEC: 45,\\n      EBADF: 8,\\n      ECHILD: 12,\\n      EAGAIN: 6,\\n      EWOULDBLOCK: 6,\\n      ENOMEM: 48,\\n      EACCES: 2,\\n      EFAULT: 21,\\n      ENOTBLK: 105,\\n      EBUSY: 10,\\n      EEXIST: 20,\\n      EXDEV: 75,\\n      ENODEV: 43,\\n      ENOTDIR: 54,\\n      EISDIR: 31,\\n      EINVAL: 28,\\n      ENFILE: 41,\\n      EMFILE: 33,\\n      ENOTTY: 59,\\n      ETXTBSY: 74,\\n      EFBIG: 22,\\n      ENOSPC: 51,\\n      ESPIPE: 70,\\n      EROFS: 69,\\n      EMLINK: 34,\\n      EPIPE: 64,\\n      EDOM: 18,\\n      ERANGE: 68,\\n      ENOMSG: 49,\\n      EIDRM: 24,\\n      ECHRNG: 106,\\n      EL2NSYNC: 156,\\n      EL3HLT: 107,\\n      EL3RST: 108,\\n      ELNRNG: 109,\\n      EUNATCH: 110,\\n      ENOCSI: 111,\\n      EL2HLT: 112,\\n      EDEADLK: 16,\\n      ENOLCK: 46,\\n      EBADE: 113,\\n      EBADR: 114,\\n      EXFULL: 115,\\n      ENOANO: 104,\\n      EBADRQC: 103,\\n      EBADSLT: 102,\\n      EDEADLOCK: 16,\\n      EBFONT: 101,\\n      ENOSTR: 100,\\n      ENODATA: 116,\\n      ETIME: 117,\\n      ENOSR: 118,\\n      ENONET: 119,\\n      ENOPKG: 120,\\n      EREMOTE: 121,\\n      ENOLINK: 47,\\n      EADV: 122,\\n      ESRMNT: 123,\\n      ECOMM: 124,\\n      EPROTO: 65,\\n      EMULTIHOP: 36,\\n      EDOTDOT: 125,\\n      EBADMSG: 9,\\n      ENOTUNIQ: 126,\\n      EBADFD: 127,\\n      EREMCHG: 128,\\n      ELIBACC: 129,\\n      ELIBBAD: 130,\\n      ELIBSCN: 131,\\n      ELIBMAX: 132,\\n      ELIBEXEC: 133,\\n      ENOSYS: 52,\\n      ENOTEMPTY: 55,\\n      ENAMETOOLONG: 37,\\n      ELOOP: 32,\\n      EOPNOTSUPP: 138,\\n      EPFNOSUPPORT: 139,\\n      ECONNRESET: 15,\\n      ENOBUFS: 42,\\n      EAFNOSUPPORT: 5,\\n      EPROTOTYPE: 67,\\n      ENOTSOCK: 57,\\n      ENOPROTOOPT: 50,\\n      ESHUTDOWN: 140,\\n      ECONNREFUSED: 14,\\n      EADDRINUSE: 3,\\n      ECONNABORTED: 13,\\n      ENETUNREACH: 40,\\n      ENETDOWN: 38,\\n      ETIMEDOUT: 73,\\n      EHOSTDOWN: 142,\\n      EHOSTUNREACH: 23,\\n      EINPROGRESS: 26,\\n      EALREADY: 7,\\n      EDESTADDRREQ: 17,\\n      EMSGSIZE: 35,\\n      EPROTONOSUPPORT: 66,\\n      ESOCKTNOSUPPORT: 137,\\n      EADDRNOTAVAIL: 4,\\n      ENETRESET: 39,\\n      EISCONN: 30,\\n      ENOTCONN: 53,\\n      ETOOMANYREFS: 141,\\n      EUSERS: 136,\\n      EDQUOT: 19,\\n      ESTALE: 72,\\n      ENOTSUP: 138,\\n      ENOMEDIUM: 148,\\n      EILSEQ: 25,\\n      EOVERFLOW: 61,\\n      ECANCELED: 11,\\n      ENOTRECOVERABLE: 56,\\n      EOWNERDEAD: 62,\\n      ESTRPIPE: 135,\\n    };\\n    var FS = {\\n      root: null,\\n      mounts: [],\\n      devices: {},\\n      streams: [],\\n      nextInode: 1,\\n      nameTable: null,\\n      currentPath: \"/\",\\n      initialized: false,\\n      ignorePermissions: true,\\n      ErrnoError: class extends Error {\\n        name = \"ErrnoError\";\\n        constructor(errno) {\\n          super(runtimeInitialized ? strError(errno) : \"\");\\n          this.errno = errno;\\n          for (var key in ERRNO_CODES) {\\n            if (ERRNO_CODES[key] === errno) {\\n              this.code = key;\\n              break;\\n            }\\n          }\\n        }\\n      },\\n      filesystems: null,\\n      syncFSRequests: 0,\\n      readFiles: {},\\n      FSStream: class {\\n        shared = {};\\n        get object() {\\n          return this.node;\\n        }\\n        set object(val) {\\n          this.node = val;\\n        }\\n        get isRead() {\\n          return (this.flags & 2097155) !== 1;\\n        }\\n        get isWrite() {\\n          return (this.flags & 2097155) !== 0;\\n        }\\n        get isAppend() {\\n          return this.flags & 1024;\\n        }\\n        get flags() {\\n          return this.shared.flags;\\n        }\\n        set flags(val) {\\n          this.shared.flags = val;\\n        }\\n        get position() {\\n          return this.shared.position;\\n        }\\n        set position(val) {\\n          this.shared.position = val;\\n        }\\n      },\\n      FSNode: class {\\n        node_ops = {};\\n        stream_ops = {};\\n        readMode = 292 | 73;\\n        writeMode = 146;\\n        mounted = null;\\n        constructor(parent, name, mode, rdev) {\\n          if (!parent) {\\n            parent = this;\\n          }\\n          this.parent = parent;\\n          this.mount = parent.mount;\\n          this.id = FS.nextInode++;\\n          this.name = name;\\n          this.mode = mode;\\n          this.rdev = rdev;\\n          this.atime = this.mtime = this.ctime = Date.now();\\n        }\\n        get read() {\\n          return (this.mode & this.readMode) === this.readMode;\\n        }\\n        set read(val) {\\n          val ? (this.mode |= this.readMode) : (this.mode &= ~this.readMode);\\n        }\\n        get write() {\\n          return (this.mode & this.writeMode) === this.writeMode;\\n        }\\n        set write(val) {\\n          val ? (this.mode |= this.writeMode) : (this.mode &= ~this.writeMode);\\n        }\\n        get isFolder() {\\n          return FS.isDir(this.mode);\\n        }\\n        get isDevice() {\\n          return FS.isChrdev(this.mode);\\n        }\\n      },\\n      lookupPath(path, opts = {}) {\\n        if (!path) {\\n          throw new FS.ErrnoError(44);\\n        }\\n        opts.follow_mount ??= true;\\n        if (!PATH.isAbs(path)) {\\n          path = FS.cwd() + \"/\" + path;\\n        }\\n        linkloop: for (var nlinks = 0; nlinks < 40; nlinks++) {\\n          var parts = path.split(\"/\").filter((p) => !!p);\\n          var current = FS.root;\\n          var current_path = \"/\";\\n          for (var i = 0; i < parts.length; i++) {\\n            var islast = i === parts.length - 1;\\n            if (islast && opts.parent) {\\n              break;\\n            }\\n            if (parts[i] === \".\") {\\n              continue;\\n            }\\n            if (parts[i] === \"..\") {\\n              current_path = PATH.dirname(current_path);\\n              current = current.parent;\\n              continue;\\n            }\\n            current_path = PATH.join2(current_path, parts[i]);\\n            try {\\n              current = FS.lookupNode(current, parts[i]);\\n            } catch (e) {\\n              if (e?.errno === 44 && islast && opts.noent_okay) {\\n                return { path: current_path };\\n              }\\n              throw e;\\n            }\\n            if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {\\n              current = current.mounted.root;\\n            }\\n            if (FS.isLink(current.mode) && (!islast || opts.follow)) {\\n              if (!current.node_ops.readlink) {\\n                throw new FS.ErrnoError(52);\\n              }\\n              var link = current.node_ops.readlink(current);\\n              if (!PATH.isAbs(link)) {\\n                link = PATH.dirname(current_path) + \"/\" + link;\\n              }\\n              path = link + \"/\" + parts.slice(i + 1).join(\"/\");\\n              continue linkloop;\\n            }\\n          }\\n          return { path: current_path, node: current };\\n        }\\n        throw new FS.ErrnoError(32);\\n      },\\n      getPath(node) {\\n        var path;\\n        while (true) {\\n          if (FS.isRoot(node)) {\\n            var mount = node.mount.mountpoint;\\n            if (!path) return mount;\\n            return mount[mount.length - 1] !== \"/\"\\n              ? `${mount}/${path}`\\n              : mount + path;\\n          }\\n          path = path ? `${node.name}/${path}` : node.name;\\n          node = node.parent;\\n        }\\n      },\\n      hashName(parentid, name) {\\n        var hash = 0;\\n        for (var i = 0; i < name.length; i++) {\\n          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;\\n        }\\n        return ((parentid + hash) >>> 0) % FS.nameTable.length;\\n      },\\n      hashAddNode(node) {\\n        var hash = FS.hashName(node.parent.id, node.name);\\n        node.name_next = FS.nameTable[hash];\\n        FS.nameTable[hash] = node;\\n      },\\n      hashRemoveNode(node) {\\n        var hash = FS.hashName(node.parent.id, node.name);\\n        if (FS.nameTable[hash] === node) {\\n          FS.nameTable[hash] = node.name_next;\\n        } else {\\n          var current = FS.nameTable[hash];\\n          while (current) {\\n            if (current.name_next === node) {\\n              current.name_next = node.name_next;\\n              break;\\n            }\\n            current = current.name_next;\\n          }\\n        }\\n      },\\n      lookupNode(parent, name) {\\n        var errCode = FS.mayLookup(parent);\\n        if (errCode) {\\n          throw new FS.ErrnoError(errCode);\\n        }\\n        var hash = FS.hashName(parent.id, name);\\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\\n          var nodeName = node.name;\\n          if (node.parent.id === parent.id && nodeName === name) {\\n            return node;\\n          }\\n        }\\n        return FS.lookup(parent, name);\\n      },\\n      createNode(parent, name, mode, rdev) {\\n        assert(typeof parent == \"object\");\\n        var node = new FS.FSNode(parent, name, mode, rdev);\\n        FS.hashAddNode(node);\\n        return node;\\n      },\\n      destroyNode(node) {\\n        FS.hashRemoveNode(node);\\n      },\\n      isRoot(node) {\\n        return node === node.parent;\\n      },\\n      isMountpoint(node) {\\n        return !!node.mounted;\\n      },\\n      isFile(mode) {\\n        return (mode & 61440) === 32768;\\n      },\\n      isDir(mode) {\\n        return (mode & 61440) === 16384;\\n      },\\n      isLink(mode) {\\n        return (mode & 61440) === 40960;\\n      },\\n      isChrdev(mode) {\\n        return (mode & 61440) === 8192;\\n      },\\n      isBlkdev(mode) {\\n        return (mode & 61440) === 24576;\\n      },\\n      isFIFO(mode) {\\n        return (mode & 61440) === 4096;\\n      },\\n      isSocket(mode) {\\n        return (mode & 49152) === 49152;\\n      },\\n      flagsToPermissionString(flag) {\\n        var perms = [\"r\", \"w\", \"rw\"][flag & 3];\\n        if (flag & 512) {\\n          perms += \"w\";\\n        }\\n        return perms;\\n      },\\n      nodePermissions(node, perms) {\\n        if (FS.ignorePermissions) {\\n          return 0;\\n        }\\n        if (perms.includes(\"r\") && !(node.mode & 292)) {\\n          return 2;\\n        } else if (perms.includes(\"w\") && !(node.mode & 146)) {\\n          return 2;\\n        } else if (perms.includes(\"x\") && !(node.mode & 73)) {\\n          return 2;\\n        }\\n        return 0;\\n      },\\n      mayLookup(dir) {\\n        if (!FS.isDir(dir.mode)) return 54;\\n        var errCode = FS.nodePermissions(dir, \"x\");\\n        if (errCode) return errCode;\\n        if (!dir.node_ops.lookup) return 2;\\n        return 0;\\n      },\\n      mayCreate(dir, name) {\\n        if (!FS.isDir(dir.mode)) {\\n          return 54;\\n        }\\n        try {\\n          var node = FS.lookupNode(dir, name);\\n          return 20;\\n        } catch (e) {}\\n        return FS.nodePermissions(dir, \"wx\");\\n      },\\n      mayDelete(dir, name, isdir) {\\n        var node;\\n        try {\\n          node = FS.lookupNode(dir, name);\\n        } catch (e) {\\n          return e.errno;\\n        }\\n        var errCode = FS.nodePermissions(dir, \"wx\");\\n        if (errCode) {\\n          return errCode;\\n        }\\n        if (isdir) {\\n          if (!FS.isDir(node.mode)) {\\n            return 54;\\n          }\\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\\n            return 10;\\n          }\\n        } else {\\n          if (FS.isDir(node.mode)) {\\n            return 31;\\n          }\\n        }\\n        return 0;\\n      },\\n      mayOpen(node, flags) {\\n        if (!node) {\\n          return 44;\\n        }\\n        if (FS.isLink(node.mode)) {\\n          return 32;\\n        } else if (FS.isDir(node.mode)) {\\n          if (FS.flagsToPermissionString(flags) !== \"r\" || flags & (512 | 64)) {\\n            return 31;\\n          }\\n        }\\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\\n      },\\n      checkOpExists(op, err) {\\n        if (!op) {\\n          throw new FS.ErrnoError(err);\\n        }\\n        return op;\\n      },\\n      MAX_OPEN_FDS: 4096,\\n      nextfd() {\\n        for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {\\n          if (!FS.streams[fd]) {\\n            return fd;\\n          }\\n        }\\n        throw new FS.ErrnoError(33);\\n      },\\n      getStreamChecked(fd) {\\n        var stream = FS.getStream(fd);\\n        if (!stream) {\\n          throw new FS.ErrnoError(8);\\n        }\\n        return stream;\\n      },\\n      getStream: (fd) => FS.streams[fd],\\n      createStream(stream, fd = -1) {\\n        assert(fd >= -1);\\n        stream = Object.assign(new FS.FSStream(), stream);\\n        if (fd == -1) {\\n          fd = FS.nextfd();\\n        }\\n        stream.fd = fd;\\n        FS.streams[fd] = stream;\\n        return stream;\\n      },\\n      closeStream(fd) {\\n        FS.streams[fd] = null;\\n      },\\n      dupStream(origStream, fd = -1) {\\n        var stream = FS.createStream(origStream, fd);\\n        stream.stream_ops?.dup?.(stream);\\n        return stream;\\n      },\\n      doSetAttr(stream, node, attr) {\\n        var setattr = stream?.stream_ops.setattr;\\n        var arg = setattr ? stream : node;\\n        setattr ??= node.node_ops.setattr;\\n        FS.checkOpExists(setattr, 63);\\n        setattr(arg, attr);\\n      },\\n      chrdev_stream_ops: {\\n        open(stream) {\\n          var device = FS.getDevice(stream.node.rdev);\\n          stream.stream_ops = device.stream_ops;\\n          stream.stream_ops.open?.(stream);\\n        },\\n        llseek() {\\n          throw new FS.ErrnoError(70);\\n        },\\n      },\\n      major: (dev) => dev >> 8,\\n      minor: (dev) => dev & 255,\\n      makedev: (ma, mi) => (ma << 8) | mi,\\n      registerDevice(dev, ops) {\\n        FS.devices[dev] = { stream_ops: ops };\\n      },\\n      getDevice: (dev) => FS.devices[dev],\\n      getMounts(mount) {\\n        var mounts = [];\\n        var check = [mount];\\n        while (check.length) {\\n          var m = check.pop();\\n          mounts.push(m);\\n          check.push(...m.mounts);\\n        }\\n        return mounts;\\n      },\\n      syncfs(populate, callback) {\\n        if (typeof populate == \"function\") {\\n          callback = populate;\\n          populate = false;\\n        }\\n        FS.syncFSRequests++;\\n        if (FS.syncFSRequests > 1) {\\n          err(\\n            `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`,\\n          );\\n        }\\n        var mounts = FS.getMounts(FS.root.mount);\\n        var completed = 0;\\n        function doCallback(errCode) {\\n          assert(FS.syncFSRequests > 0);\\n          FS.syncFSRequests--;\\n          return callback(errCode);\\n        }\\n        function done(errCode) {\\n          if (errCode) {\\n            if (!done.errored) {\\n              done.errored = true;\\n              return doCallback(errCode);\\n            }\\n            return;\\n          }\\n          if (++completed >= mounts.length) {\\n            doCallback(null);\\n          }\\n        }\\n        mounts.forEach((mount) => {\\n          if (!mount.type.syncfs) {\\n            return done(null);\\n          }\\n          mount.type.syncfs(mount, populate, done);\\n        });\\n      },\\n      mount(type, opts, mountpoint) {\\n        if (typeof type == \"string\") {\\n          throw type;\\n        }\\n        var root = mountpoint === \"/\";\\n        var pseudo = !mountpoint;\\n        var node;\\n        if (root && FS.root) {\\n          throw new FS.ErrnoError(10);\\n        } else if (!root && !pseudo) {\\n          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\\n          mountpoint = lookup.path;\\n          node = lookup.node;\\n          if (FS.isMountpoint(node)) {\\n            throw new FS.ErrnoError(10);\\n          }\\n          if (!FS.isDir(node.mode)) {\\n            throw new FS.ErrnoError(54);\\n          }\\n        }\\n        var mount = { type, opts, mountpoint, mounts: [] };\\n        var mountRoot = type.mount(mount);\\n        mountRoot.mount = mount;\\n        mount.root = mountRoot;\\n        if (root) {\\n          FS.root = mountRoot;\\n        } else if (node) {\\n          node.mounted = mount;\\n          if (node.mount) {\\n            node.mount.mounts.push(mount);\\n          }\\n        }\\n        return mountRoot;\\n      },\\n      unmount(mountpoint) {\\n        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\\n        if (!FS.isMountpoint(lookup.node)) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        var node = lookup.node;\\n        var mount = node.mounted;\\n        var mounts = FS.getMounts(mount);\\n        Object.keys(FS.nameTable).forEach((hash) => {\\n          var current = FS.nameTable[hash];\\n          while (current) {\\n            var next = current.name_next;\\n            if (mounts.includes(current.mount)) {\\n              FS.destroyNode(current);\\n            }\\n            current = next;\\n          }\\n        });\\n        node.mounted = null;\\n        var idx = node.mount.mounts.indexOf(mount);\\n        assert(idx !== -1);\\n        node.mount.mounts.splice(idx, 1);\\n      },\\n      lookup(parent, name) {\\n        return parent.node_ops.lookup(parent, name);\\n      },\\n      mknod(path, mode, dev) {\\n        var lookup = FS.lookupPath(path, { parent: true });\\n        var parent = lookup.node;\\n        var name = PATH.basename(path);\\n        if (!name) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        if (name === \".\" || name === \"..\") {\\n          throw new FS.ErrnoError(20);\\n        }\\n        var errCode = FS.mayCreate(parent, name);\\n        if (errCode) {\\n          throw new FS.ErrnoError(errCode);\\n        }\\n        if (!parent.node_ops.mknod) {\\n          throw new FS.ErrnoError(63);\\n        }\\n        return parent.node_ops.mknod(parent, name, mode, dev);\\n      },\\n      statfs(path) {\\n        return FS.statfsNode(FS.lookupPath(path, { follow: true }).node);\\n      },\\n      statfsStream(stream) {\\n        return FS.statfsNode(stream.node);\\n      },\\n      statfsNode(node) {\\n        var rtn = {\\n          bsize: 4096,\\n          frsize: 4096,\\n          blocks: 1e6,\\n          bfree: 5e5,\\n          bavail: 5e5,\\n          files: FS.nextInode,\\n          ffree: FS.nextInode - 1,\\n          fsid: 42,\\n          flags: 2,\\n          namelen: 255,\\n        };\\n        if (node.node_ops.statfs) {\\n          Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));\\n        }\\n        return rtn;\\n      },\\n      create(path, mode = 438) {\\n        mode &= 4095;\\n        mode |= 32768;\\n        return FS.mknod(path, mode, 0);\\n      },\\n      mkdir(path, mode = 511) {\\n        mode &= 511 | 512;\\n        mode |= 16384;\\n        return FS.mknod(path, mode, 0);\\n      },\\n      mkdirTree(path, mode) {\\n        var dirs = path.split(\"/\");\\n        var d = \"\";\\n        for (var i = 0; i < dirs.length; ++i) {\\n          if (!dirs[i]) continue;\\n          d += \"/\" + dirs[i];\\n          try {\\n            FS.mkdir(d, mode);\\n          } catch (e) {\\n            if (e.errno != 20) throw e;\\n          }\\n        }\\n      },\\n      mkdev(path, mode, dev) {\\n        if (typeof dev == \"undefined\") {\\n          dev = mode;\\n          mode = 438;\\n        }\\n        mode |= 8192;\\n        return FS.mknod(path, mode, dev);\\n      },\\n      symlink(oldpath, newpath) {\\n        if (!PATH_FS.resolve(oldpath)) {\\n          throw new FS.ErrnoError(44);\\n        }\\n        var lookup = FS.lookupPath(newpath, { parent: true });\\n        var parent = lookup.node;\\n        if (!parent) {\\n          throw new FS.ErrnoError(44);\\n        }\\n        var newname = PATH.basename(newpath);\\n        var errCode = FS.mayCreate(parent, newname);\\n        if (errCode) {\\n          throw new FS.ErrnoError(errCode);\\n        }\\n        if (!parent.node_ops.symlink) {\\n          throw new FS.ErrnoError(63);\\n        }\\n        return parent.node_ops.symlink(parent, newname, oldpath);\\n      },\\n      rename(old_path, new_path) {\\n        var old_dirname = PATH.dirname(old_path);\\n        var new_dirname = PATH.dirname(new_path);\\n        var old_name = PATH.basename(old_path);\\n        var new_name = PATH.basename(new_path);\\n        var lookup, old_dir, new_dir;\\n        lookup = FS.lookupPath(old_path, { parent: true });\\n        old_dir = lookup.node;\\n        lookup = FS.lookupPath(new_path, { parent: true });\\n        new_dir = lookup.node;\\n        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\\n        if (old_dir.mount !== new_dir.mount) {\\n          throw new FS.ErrnoError(75);\\n        }\\n        var old_node = FS.lookupNode(old_dir, old_name);\\n        var relative = PATH_FS.relative(old_path, new_dirname);\\n        if (relative.charAt(0) !== \".\") {\\n          throw new FS.ErrnoError(28);\\n        }\\n        relative = PATH_FS.relative(new_path, old_dirname);\\n        if (relative.charAt(0) !== \".\") {\\n          throw new FS.ErrnoError(55);\\n        }\\n        var new_node;\\n        try {\\n          new_node = FS.lookupNode(new_dir, new_name);\\n        } catch (e) {}\\n        if (old_node === new_node) {\\n          return;\\n        }\\n        var isdir = FS.isDir(old_node.mode);\\n        var errCode = FS.mayDelete(old_dir, old_name, isdir);\\n        if (errCode) {\\n          throw new FS.ErrnoError(errCode);\\n        }\\n        errCode = new_node\\n          ? FS.mayDelete(new_dir, new_name, isdir)\\n          : FS.mayCreate(new_dir, new_name);\\n        if (errCode) {\\n          throw new FS.ErrnoError(errCode);\\n        }\\n        if (!old_dir.node_ops.rename) {\\n          throw new FS.ErrnoError(63);\\n        }\\n        if (\\n          FS.isMountpoint(old_node) ||\\n          (new_node && FS.isMountpoint(new_node))\\n        ) {\\n          throw new FS.ErrnoError(10);\\n        }\\n        if (new_dir !== old_dir) {\\n          errCode = FS.nodePermissions(old_dir, \"w\");\\n          if (errCode) {\\n            throw new FS.ErrnoError(errCode);\\n          }\\n        }\\n        FS.hashRemoveNode(old_node);\\n        try {\\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\\n          old_node.parent = new_dir;\\n        } catch (e) {\\n          throw e;\\n        } finally {\\n          FS.hashAddNode(old_node);\\n        }\\n      },\\n      rmdir(path) {\\n        var lookup = FS.lookupPath(path, { parent: true });\\n        var parent = lookup.node;\\n        var name = PATH.basename(path);\\n        var node = FS.lookupNode(parent, name);\\n        var errCode = FS.mayDelete(parent, name, true);\\n        if (errCode) {\\n          throw new FS.ErrnoError(errCode);\\n        }\\n        if (!parent.node_ops.rmdir) {\\n          throw new FS.ErrnoError(63);\\n        }\\n        if (FS.isMountpoint(node)) {\\n          throw new FS.ErrnoError(10);\\n        }\\n        parent.node_ops.rmdir(parent, name);\\n        FS.destroyNode(node);\\n      },\\n      readdir(path) {\\n        var lookup = FS.lookupPath(path, { follow: true });\\n        var node = lookup.node;\\n        var readdir = FS.checkOpExists(node.node_ops.readdir, 54);\\n        return readdir(node);\\n      },\\n      unlink(path) {\\n        var lookup = FS.lookupPath(path, { parent: true });\\n        var parent = lookup.node;\\n        if (!parent) {\\n          throw new FS.ErrnoError(44);\\n        }\\n        var name = PATH.basename(path);\\n        var node = FS.lookupNode(parent, name);\\n        var errCode = FS.mayDelete(parent, name, false);\\n        if (errCode) {\\n          throw new FS.ErrnoError(errCode);\\n        }\\n        if (!parent.node_ops.unlink) {\\n          throw new FS.ErrnoError(63);\\n        }\\n        if (FS.isMountpoint(node)) {\\n          throw new FS.ErrnoError(10);\\n        }\\n        parent.node_ops.unlink(parent, name);\\n        FS.destroyNode(node);\\n      },\\n      readlink(path) {\\n        var lookup = FS.lookupPath(path);\\n        var link = lookup.node;\\n        if (!link) {\\n          throw new FS.ErrnoError(44);\\n        }\\n        if (!link.node_ops.readlink) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        return link.node_ops.readlink(link);\\n      },\\n      stat(path, dontFollow) {\\n        var lookup = FS.lookupPath(path, { follow: !dontFollow });\\n        var node = lookup.node;\\n        var getattr = FS.checkOpExists(node.node_ops.getattr, 63);\\n        return getattr(node);\\n      },\\n      fstat(fd) {\\n        var stream = FS.getStreamChecked(fd);\\n        var node = stream.node;\\n        var getattr = stream.stream_ops.getattr;\\n        var arg = getattr ? stream : node;\\n        getattr ??= node.node_ops.getattr;\\n        FS.checkOpExists(getattr, 63);\\n        return getattr(arg);\\n      },\\n      lstat(path) {\\n        return FS.stat(path, true);\\n      },\\n      doChmod(stream, node, mode, dontFollow) {\\n        FS.doSetAttr(stream, node, {\\n          mode: (mode & 4095) | (node.mode & ~4095),\\n          ctime: Date.now(),\\n          dontFollow,\\n        });\\n      },\\n      chmod(path, mode, dontFollow) {\\n        var node;\\n        if (typeof path == \"string\") {\\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\\n          node = lookup.node;\\n        } else {\\n          node = path;\\n        }\\n        FS.doChmod(null, node, mode, dontFollow);\\n      },\\n      lchmod(path, mode) {\\n        FS.chmod(path, mode, true);\\n      },\\n      fchmod(fd, mode) {\\n        var stream = FS.getStreamChecked(fd);\\n        FS.doChmod(stream, stream.node, mode, false);\\n      },\\n      doChown(stream, node, dontFollow) {\\n        FS.doSetAttr(stream, node, { timestamp: Date.now(), dontFollow });\\n      },\\n      chown(path, uid, gid, dontFollow) {\\n        var node;\\n        if (typeof path == \"string\") {\\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\\n          node = lookup.node;\\n        } else {\\n          node = path;\\n        }\\n        FS.doChown(null, node, dontFollow);\\n      },\\n      lchown(path, uid, gid) {\\n        FS.chown(path, uid, gid, true);\\n      },\\n      fchown(fd, uid, gid) {\\n        var stream = FS.getStreamChecked(fd);\\n        FS.doChown(stream, stream.node, false);\\n      },\\n      doTruncate(stream, node, len) {\\n        if (FS.isDir(node.mode)) {\\n          throw new FS.ErrnoError(31);\\n        }\\n        if (!FS.isFile(node.mode)) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        var errCode = FS.nodePermissions(node, \"w\");\\n        if (errCode) {\\n          throw new FS.ErrnoError(errCode);\\n        }\\n        FS.doSetAttr(stream, node, { size: len, timestamp: Date.now() });\\n      },\\n      truncate(path, len) {\\n        if (len < 0) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        var node;\\n        if (typeof path == \"string\") {\\n          var lookup = FS.lookupPath(path, { follow: true });\\n          node = lookup.node;\\n        } else {\\n          node = path;\\n        }\\n        FS.doTruncate(null, node, len);\\n      },\\n      ftruncate(fd, len) {\\n        var stream = FS.getStreamChecked(fd);\\n        if (len < 0 || (stream.flags & 2097155) === 0) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        FS.doTruncate(stream, stream.node, len);\\n      },\\n      utime(path, atime, mtime) {\\n        var lookup = FS.lookupPath(path, { follow: true });\\n        var node = lookup.node;\\n        var setattr = FS.checkOpExists(node.node_ops.setattr, 63);\\n        setattr(node, { atime, mtime });\\n      },\\n      open(path, flags, mode = 438) {\\n        if (path === \"\") {\\n          throw new FS.ErrnoError(44);\\n        }\\n        flags = typeof flags == \"string\" ? FS_modeStringToFlags(flags) : flags;\\n        if (flags & 64) {\\n          mode = (mode & 4095) | 32768;\\n        } else {\\n          mode = 0;\\n        }\\n        var node;\\n        var isDirPath;\\n        if (typeof path == \"object\") {\\n          node = path;\\n        } else {\\n          isDirPath = path.endsWith(\"/\");\\n          var lookup = FS.lookupPath(path, {\\n            follow: !(flags & 131072),\\n            noent_okay: true,\\n          });\\n          node = lookup.node;\\n          path = lookup.path;\\n        }\\n        var created = false;\\n        if (flags & 64) {\\n          if (node) {\\n            if (flags & 128) {\\n              throw new FS.ErrnoError(20);\\n            }\\n          } else if (isDirPath) {\\n            throw new FS.ErrnoError(31);\\n          } else {\\n            node = FS.mknod(path, mode | 511, 0);\\n            created = true;\\n          }\\n        }\\n        if (!node) {\\n          throw new FS.ErrnoError(44);\\n        }\\n        if (FS.isChrdev(node.mode)) {\\n          flags &= ~512;\\n        }\\n        if (flags & 65536 && !FS.isDir(node.mode)) {\\n          throw new FS.ErrnoError(54);\\n        }\\n        if (!created) {\\n          var errCode = FS.mayOpen(node, flags);\\n          if (errCode) {\\n            throw new FS.ErrnoError(errCode);\\n          }\\n        }\\n        if (flags & 512 && !created) {\\n          FS.truncate(node, 0);\\n        }\\n        flags &= ~(128 | 512 | 131072);\\n        var stream = FS.createStream({\\n          node,\\n          path: FS.getPath(node),\\n          flags,\\n          seekable: true,\\n          position: 0,\\n          stream_ops: node.stream_ops,\\n          ungotten: [],\\n          error: false,\\n        });\\n        if (stream.stream_ops.open) {\\n          stream.stream_ops.open(stream);\\n        }\\n        if (created) {\\n          FS.chmod(node, mode & 511);\\n        }\\n        if (Module[\"logReadFiles\"] && !(flags & 1)) {\\n          if (!(path in FS.readFiles)) {\\n            FS.readFiles[path] = 1;\\n          }\\n        }\\n        return stream;\\n      },\\n      close(stream) {\\n        if (FS.isClosed(stream)) {\\n          throw new FS.ErrnoError(8);\\n        }\\n        if (stream.getdents) stream.getdents = null;\\n        try {\\n          if (stream.stream_ops.close) {\\n            stream.stream_ops.close(stream);\\n          }\\n        } catch (e) {\\n          throw e;\\n        } finally {\\n          FS.closeStream(stream.fd);\\n        }\\n        stream.fd = null;\\n      },\\n      isClosed(stream) {\\n        return stream.fd === null;\\n      },\\n      llseek(stream, offset, whence) {\\n        if (FS.isClosed(stream)) {\\n          throw new FS.ErrnoError(8);\\n        }\\n        if (!stream.seekable || !stream.stream_ops.llseek) {\\n          throw new FS.ErrnoError(70);\\n        }\\n        if (whence != 0 && whence != 1 && whence != 2) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\\n        stream.ungotten = [];\\n        return stream.position;\\n      },\\n      read(stream, buffer, offset, length, position) {\\n        assert(offset >= 0);\\n        if (length < 0 || position < 0) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        if (FS.isClosed(stream)) {\\n          throw new FS.ErrnoError(8);\\n        }\\n        if ((stream.flags & 2097155) === 1) {\\n          throw new FS.ErrnoError(8);\\n        }\\n        if (FS.isDir(stream.node.mode)) {\\n          throw new FS.ErrnoError(31);\\n        }\\n        if (!stream.stream_ops.read) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        var seeking = typeof position != \"undefined\";\\n        if (!seeking) {\\n          position = stream.position;\\n        } else if (!stream.seekable) {\\n          throw new FS.ErrnoError(70);\\n        }\\n        var bytesRead = stream.stream_ops.read(\\n          stream,\\n          buffer,\\n          offset,\\n          length,\\n          position,\\n        );\\n        if (!seeking) stream.position += bytesRead;\\n        return bytesRead;\\n      },\\n      write(stream, buffer, offset, length, position, canOwn) {\\n        assert(offset >= 0);\\n        if (length < 0 || position < 0) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        if (FS.isClosed(stream)) {\\n          throw new FS.ErrnoError(8);\\n        }\\n        if ((stream.flags & 2097155) === 0) {\\n          throw new FS.ErrnoError(8);\\n        }\\n        if (FS.isDir(stream.node.mode)) {\\n          throw new FS.ErrnoError(31);\\n        }\\n        if (!stream.stream_ops.write) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        if (stream.seekable && stream.flags & 1024) {\\n          FS.llseek(stream, 0, 2);\\n        }\\n        var seeking = typeof position != \"undefined\";\\n        if (!seeking) {\\n          position = stream.position;\\n        } else if (!stream.seekable) {\\n          throw new FS.ErrnoError(70);\\n        }\\n        var bytesWritten = stream.stream_ops.write(\\n          stream,\\n          buffer,\\n          offset,\\n          length,\\n          position,\\n          canOwn,\\n        );\\n        if (!seeking) stream.position += bytesWritten;\\n        return bytesWritten;\\n      },\\n      allocate(stream, offset, length) {\\n        if (FS.isClosed(stream)) {\\n          throw new FS.ErrnoError(8);\\n        }\\n        if (offset < 0 || length <= 0) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        if ((stream.flags & 2097155) === 0) {\\n          throw new FS.ErrnoError(8);\\n        }\\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\\n          throw new FS.ErrnoError(43);\\n        }\\n        if (!stream.stream_ops.allocate) {\\n          throw new FS.ErrnoError(138);\\n        }\\n        stream.stream_ops.allocate(stream, offset, length);\\n      },\\n      mmap(stream, length, position, prot, flags) {\\n        if (\\n          (prot & 2) !== 0 &&\\n          (flags & 2) === 0 &&\\n          (stream.flags & 2097155) !== 2\\n        ) {\\n          throw new FS.ErrnoError(2);\\n        }\\n        if ((stream.flags & 2097155) === 1) {\\n          throw new FS.ErrnoError(2);\\n        }\\n        if (!stream.stream_ops.mmap) {\\n          throw new FS.ErrnoError(43);\\n        }\\n        if (!length) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        return stream.stream_ops.mmap(stream, length, position, prot, flags);\\n      },\\n      msync(stream, buffer, offset, length, mmapFlags) {\\n        assert(offset >= 0);\\n        if (!stream.stream_ops.msync) {\\n          return 0;\\n        }\\n        return stream.stream_ops.msync(\\n          stream,\\n          buffer,\\n          offset,\\n          length,\\n          mmapFlags,\\n        );\\n      },\\n      ioctl(stream, cmd, arg) {\\n        if (!stream.stream_ops.ioctl) {\\n          throw new FS.ErrnoError(59);\\n        }\\n        return stream.stream_ops.ioctl(stream, cmd, arg);\\n      },\\n      readFile(path, opts = {}) {\\n        opts.flags = opts.flags || 0;\\n        opts.encoding = opts.encoding || \"binary\";\\n        if (opts.encoding !== \"utf8\" && opts.encoding !== \"binary\") {\\n          throw new Error(`Invalid encoding type \"${opts.encoding}\"`);\\n        }\\n        var ret;\\n        var stream = FS.open(path, opts.flags);\\n        var stat = FS.stat(path);\\n        var length = stat.size;\\n        var buf = new Uint8Array(length);\\n        FS.read(stream, buf, 0, length, 0);\\n        if (opts.encoding === \"utf8\") {\\n          ret = UTF8ArrayToString(buf);\\n        } else if (opts.encoding === \"binary\") {\\n          ret = buf;\\n        }\\n        FS.close(stream);\\n        return ret;\\n      },\\n      writeFile(path, data, opts = {}) {\\n        opts.flags = opts.flags || 577;\\n        var stream = FS.open(path, opts.flags, opts.mode);\\n        if (typeof data == \"string\") {\\n          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\\n          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\\n        } else if (ArrayBuffer.isView(data)) {\\n          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\\n        } else {\\n          throw new Error(\"Unsupported data type\");\\n        }\\n        FS.close(stream);\\n      },\\n      cwd: () => FS.currentPath,\\n      chdir(path) {\\n        var lookup = FS.lookupPath(path, { follow: true });\\n        if (lookup.node === null) {\\n          throw new FS.ErrnoError(44);\\n        }\\n        if (!FS.isDir(lookup.node.mode)) {\\n          throw new FS.ErrnoError(54);\\n        }\\n        var errCode = FS.nodePermissions(lookup.node, \"x\");\\n        if (errCode) {\\n          throw new FS.ErrnoError(errCode);\\n        }\\n        FS.currentPath = lookup.path;\\n      },\\n      createDefaultDirectories() {\\n        FS.mkdir(\"/tmp\");\\n        FS.mkdir(\"/home\");\\n        FS.mkdir(\"/home/web_user\");\\n      },\\n      createDefaultDevices() {\\n        FS.mkdir(\"/dev\");\\n        FS.registerDevice(FS.makedev(1, 3), {\\n          read: () => 0,\\n          write: (stream, buffer, offset, length, pos) => length,\\n          llseek: () => 0,\\n        });\\n        FS.mkdev(\"/dev/null\", FS.makedev(1, 3));\\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\\n        FS.mkdev(\"/dev/tty\", FS.makedev(5, 0));\\n        FS.mkdev(\"/dev/tty1\", FS.makedev(6, 0));\\n        var randomBuffer = new Uint8Array(1024),\\n          randomLeft = 0;\\n        var randomByte = () => {\\n          if (randomLeft === 0) {\\n            randomFill(randomBuffer);\\n            randomLeft = randomBuffer.byteLength;\\n          }\\n          return randomBuffer[--randomLeft];\\n        };\\n        FS.createDevice(\"/dev\", \"random\", randomByte);\\n        FS.createDevice(\"/dev\", \"urandom\", randomByte);\\n        FS.mkdir(\"/dev/shm\");\\n        FS.mkdir(\"/dev/shm/tmp\");\\n      },\\n      createSpecialDirectories() {\\n        FS.mkdir(\"/proc\");\\n        var proc_self = FS.mkdir(\"/proc/self\");\\n        FS.mkdir(\"/proc/self/fd\");\\n        FS.mount(\\n          {\\n            mount() {\\n              var node = FS.createNode(proc_self, \"fd\", 16895, 73);\\n              node.stream_ops = { llseek: MEMFS.stream_ops.llseek };\\n              node.node_ops = {\\n                lookup(parent, name) {\\n                  var fd = +name;\\n                  var stream = FS.getStreamChecked(fd);\\n                  var ret = {\\n                    parent: null,\\n                    mount: { mountpoint: \"fake\" },\\n                    node_ops: { readlink: () => stream.path },\\n                    id: fd + 1,\\n                  };\\n                  ret.parent = ret;\\n                  return ret;\\n                },\\n                readdir() {\\n                  return Array.from(FS.streams.entries())\\n                    .filter(([k, v]) => v)\\n                    .map(([k, v]) => k.toString());\\n                },\\n              };\\n              return node;\\n            },\\n          },\\n          {},\\n          \"/proc/self/fd\",\\n        );\\n      },\\n      createStandardStreams(input, output, error) {\\n        if (input) {\\n          FS.createDevice(\"/dev\", \"stdin\", input);\\n        } else {\\n          FS.symlink(\"/dev/tty\", \"/dev/stdin\");\\n        }\\n        if (output) {\\n          FS.createDevice(\"/dev\", \"stdout\", null, output);\\n        } else {\\n          FS.symlink(\"/dev/tty\", \"/dev/stdout\");\\n        }\\n        if (error) {\\n          FS.createDevice(\"/dev\", \"stderr\", null, error);\\n        } else {\\n          FS.symlink(\"/dev/tty1\", \"/dev/stderr\");\\n        }\\n        var stdin = FS.open(\"/dev/stdin\", 0);\\n        var stdout = FS.open(\"/dev/stdout\", 1);\\n        var stderr = FS.open(\"/dev/stderr\", 1);\\n        assert(stdin.fd === 0, `invalid handle for stdin (${stdin.fd})`);\\n        assert(stdout.fd === 1, `invalid handle for stdout (${stdout.fd})`);\\n        assert(stderr.fd === 2, `invalid handle for stderr (${stderr.fd})`);\\n      },\\n      staticInit() {\\n        FS.nameTable = new Array(4096);\\n        FS.mount(MEMFS, {}, \"/\");\\n        FS.createDefaultDirectories();\\n        FS.createDefaultDevices();\\n        FS.createSpecialDirectories();\\n        FS.filesystems = { MEMFS };\\n      },\\n      init(input, output, error) {\\n        assert(\\n          !FS.initialized,\\n          \"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)\",\\n        );\\n        FS.initialized = true;\\n        input ??= Module[\"stdin\"];\\n        output ??= Module[\"stdout\"];\\n        error ??= Module[\"stderr\"];\\n        FS.createStandardStreams(input, output, error);\\n      },\\n      quit() {\\n        FS.initialized = false;\\n        _fflush(0);\\n        for (var i = 0; i < FS.streams.length; i++) {\\n          var stream = FS.streams[i];\\n          if (!stream) {\\n            continue;\\n          }\\n          FS.close(stream);\\n        }\\n      },\\n      findObject(path, dontResolveLastLink) {\\n        var ret = FS.analyzePath(path, dontResolveLastLink);\\n        if (!ret.exists) {\\n          return null;\\n        }\\n        return ret.object;\\n      },\\n      analyzePath(path, dontResolveLastLink) {\\n        try {\\n          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\\n          path = lookup.path;\\n        } catch (e) {}\\n        var ret = {\\n          isRoot: false,\\n          exists: false,\\n          error: 0,\\n          name: null,\\n          path: null,\\n          object: null,\\n          parentExists: false,\\n          parentPath: null,\\n          parentObject: null,\\n        };\\n        try {\\n          var lookup = FS.lookupPath(path, { parent: true });\\n          ret.parentExists = true;\\n          ret.parentPath = lookup.path;\\n          ret.parentObject = lookup.node;\\n          ret.name = PATH.basename(path);\\n          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\\n          ret.exists = true;\\n          ret.path = lookup.path;\\n          ret.object = lookup.node;\\n          ret.name = lookup.node.name;\\n          ret.isRoot = lookup.path === \"/\";\\n        } catch (e) {\\n          ret.error = e.errno;\\n        }\\n        return ret;\\n      },\\n      createPath(parent, path, canRead, canWrite) {\\n        parent = typeof parent == \"string\" ? parent : FS.getPath(parent);\\n        var parts = path.split(\"/\").reverse();\\n        while (parts.length) {\\n          var part = parts.pop();\\n          if (!part) continue;\\n          var current = PATH.join2(parent, part);\\n          try {\\n            FS.mkdir(current);\\n          } catch (e) {}\\n          parent = current;\\n        }\\n        return current;\\n      },\\n      createFile(parent, name, properties, canRead, canWrite) {\\n        var path = PATH.join2(\\n          typeof parent == \"string\" ? parent : FS.getPath(parent),\\n          name,\\n        );\\n        var mode = FS_getMode(canRead, canWrite);\\n        return FS.create(path, mode);\\n      },\\n      createDataFile(parent, name, data, canRead, canWrite, canOwn) {\\n        var path = name;\\n        if (parent) {\\n          parent = typeof parent == \"string\" ? parent : FS.getPath(parent);\\n          path = name ? PATH.join2(parent, name) : parent;\\n        }\\n        var mode = FS_getMode(canRead, canWrite);\\n        var node = FS.create(path, mode);\\n        if (data) {\\n          if (typeof data == \"string\") {\\n            var arr = new Array(data.length);\\n            for (var i = 0, len = data.length; i < len; ++i)\\n              arr[i] = data.charCodeAt(i);\\n            data = arr;\\n          }\\n          FS.chmod(node, mode | 146);\\n          var stream = FS.open(node, 577);\\n          FS.write(stream, data, 0, data.length, 0, canOwn);\\n          FS.close(stream);\\n          FS.chmod(node, mode);\\n        }\\n      },\\n      createDevice(parent, name, input, output) {\\n        var path = PATH.join2(\\n          typeof parent == \"string\" ? parent : FS.getPath(parent),\\n          name,\\n        );\\n        var mode = FS_getMode(!!input, !!output);\\n        FS.createDevice.major ??= 64;\\n        var dev = FS.makedev(FS.createDevice.major++, 0);\\n        FS.registerDevice(dev, {\\n          open(stream) {\\n            stream.seekable = false;\\n          },\\n          close(stream) {\\n            if (output?.buffer?.length) {\\n              output(10);\\n            }\\n          },\\n          read(stream, buffer, offset, length, pos) {\\n            var bytesRead = 0;\\n            for (var i = 0; i < length; i++) {\\n              var result;\\n              try {\\n                result = input();\\n              } catch (e) {\\n                throw new FS.ErrnoError(29);\\n              }\\n              if (result === undefined && bytesRead === 0) {\\n                throw new FS.ErrnoError(6);\\n              }\\n              if (result === null || result === undefined) break;\\n              bytesRead++;\\n              buffer[offset + i] = result;\\n            }\\n            if (bytesRead) {\\n              stream.node.atime = Date.now();\\n            }\\n            return bytesRead;\\n          },\\n          write(stream, buffer, offset, length, pos) {\\n            for (var i = 0; i < length; i++) {\\n              try {\\n                output(buffer[offset + i]);\\n              } catch (e) {\\n                throw new FS.ErrnoError(29);\\n              }\\n            }\\n            if (length) {\\n              stream.node.mtime = stream.node.ctime = Date.now();\\n            }\\n            return i;\\n          },\\n        });\\n        return FS.mkdev(path, mode, dev);\\n      },\\n      forceLoadFile(obj) {\\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents)\\n          return true;\\n        if (typeof XMLHttpRequest != \"undefined\") {\\n          throw new Error(\\n            \"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\",\\n          );\\n        } else {\\n          try {\\n            obj.contents = readBinary(obj.url);\\n            obj.usedBytes = obj.contents.length;\\n          } catch (e) {\\n            throw new FS.ErrnoError(29);\\n          }\\n        }\\n      },\\n      createLazyFile(parent, name, url, canRead, canWrite) {\\n        class LazyUint8Array {\\n          lengthKnown = false;\\n          chunks = [];\\n          get(idx) {\\n            if (idx > this.length - 1 || idx < 0) {\\n              return undefined;\\n            }\\n            var chunkOffset = idx % this.chunkSize;\\n            var chunkNum = (idx / this.chunkSize) | 0;\\n            return this.getter(chunkNum)[chunkOffset];\\n          }\\n          setDataGetter(getter) {\\n            this.getter = getter;\\n          }\\n          cacheLength() {\\n            var xhr = new XMLHttpRequest();\\n            xhr.open(\"HEAD\", url, false);\\n            xhr.send(null);\\n            if (\\n              !((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304)\\n            )\\n              throw new Error(\\n                \"Couldn\\'t load \" + url + \". Status: \" + xhr.status,\\n              );\\n            var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\\n            var header;\\n            var hasByteServing =\\n              (header = xhr.getResponseHeader(\"Accept-Ranges\")) &&\\n              header === \"bytes\";\\n            var usesGzip =\\n              (header = xhr.getResponseHeader(\"Content-Encoding\")) &&\\n              header === \"gzip\";\\n            var chunkSize = 1024 * 1024;\\n            if (!hasByteServing) chunkSize = datalength;\\n            var doXHR = (from, to) => {\\n              if (from > to)\\n                throw new Error(\\n                  \"invalid range (\" +\\n                    from +\\n                    \", \" +\\n                    to +\\n                    \") or no bytes requested!\",\\n                );\\n              if (to > datalength - 1)\\n                throw new Error(\\n                  \"only \" + datalength + \" bytes available! programmer error!\",\\n                );\\n              var xhr = new XMLHttpRequest();\\n              xhr.open(\"GET\", url, false);\\n              if (datalength !== chunkSize)\\n                xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\\n              xhr.responseType = \"arraybuffer\";\\n              if (xhr.overrideMimeType) {\\n                xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\\n              }\\n              xhr.send(null);\\n              if (\\n                !((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304)\\n              )\\n                throw new Error(\\n                  \"Couldn\\'t load \" + url + \". Status: \" + xhr.status,\\n                );\\n              if (xhr.response !== undefined) {\\n                return new Uint8Array(xhr.response || []);\\n              }\\n              return intArrayFromString(xhr.responseText || \"\", true);\\n            };\\n            var lazyArray = this;\\n            lazyArray.setDataGetter((chunkNum) => {\\n              var start = chunkNum * chunkSize;\\n              var end = (chunkNum + 1) * chunkSize - 1;\\n              end = Math.min(end, datalength - 1);\\n              if (typeof lazyArray.chunks[chunkNum] == \"undefined\") {\\n                lazyArray.chunks[chunkNum] = doXHR(start, end);\\n              }\\n              if (typeof lazyArray.chunks[chunkNum] == \"undefined\")\\n                throw new Error(\"doXHR failed!\");\\n              return lazyArray.chunks[chunkNum];\\n            });\\n            if (usesGzip || !datalength) {\\n              chunkSize = datalength = 1;\\n              datalength = this.getter(0).length;\\n              chunkSize = datalength;\\n              out(\\n                \"LazyFiles on gzip forces download of the whole file when length is accessed\",\\n              );\\n            }\\n            this._length = datalength;\\n            this._chunkSize = chunkSize;\\n            this.lengthKnown = true;\\n          }\\n          get length() {\\n            if (!this.lengthKnown) {\\n              this.cacheLength();\\n            }\\n            return this._length;\\n          }\\n          get chunkSize() {\\n            if (!this.lengthKnown) {\\n              this.cacheLength();\\n            }\\n            return this._chunkSize;\\n          }\\n        }\\n        if (typeof XMLHttpRequest != \"undefined\") {\\n          if (!ENVIRONMENT_IS_WORKER)\\n            throw \"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";\\n          var lazyArray = new LazyUint8Array();\\n          var properties = { isDevice: false, contents: lazyArray };\\n        } else {\\n          var properties = { isDevice: false, url };\\n        }\\n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\\n        if (properties.contents) {\\n          node.contents = properties.contents;\\n        } else if (properties.url) {\\n          node.contents = null;\\n          node.url = properties.url;\\n        }\\n        Object.defineProperties(node, {\\n          usedBytes: {\\n            get: function () {\\n              return this.contents.length;\\n            },\\n          },\\n        });\\n        var stream_ops = {};\\n        var keys = Object.keys(node.stream_ops);\\n        keys.forEach((key) => {\\n          var fn = node.stream_ops[key];\\n          stream_ops[key] = (...args) => {\\n            FS.forceLoadFile(node);\\n            return fn(...args);\\n          };\\n        });\\n        function writeChunks(stream, buffer, offset, length, position) {\\n          var contents = stream.node.contents;\\n          if (position >= contents.length) return 0;\\n          var size = Math.min(contents.length - position, length);\\n          assert(size >= 0);\\n          if (contents.slice) {\\n            for (var i = 0; i < size; i++) {\\n              buffer[offset + i] = contents[position + i];\\n            }\\n          } else {\\n            for (var i = 0; i < size; i++) {\\n              buffer[offset + i] = contents.get(position + i);\\n            }\\n          }\\n          return size;\\n        }\\n        stream_ops.read = (stream, buffer, offset, length, position) => {\\n          FS.forceLoadFile(node);\\n          return writeChunks(stream, buffer, offset, length, position);\\n        };\\n        stream_ops.mmap = (stream, length, position, prot, flags) => {\\n          FS.forceLoadFile(node);\\n          var ptr = mmapAlloc(length);\\n          if (!ptr) {\\n            throw new FS.ErrnoError(48);\\n          }\\n          writeChunks(stream, HEAP8, ptr, length, position);\\n          return { ptr, allocated: true };\\n        };\\n        node.stream_ops = stream_ops;\\n        return node;\\n      },\\n      absolutePath() {\\n        abort(\"FS.absolutePath has been removed; use PATH_FS.resolve instead\");\\n      },\\n      createFolder() {\\n        abort(\"FS.createFolder has been removed; use FS.mkdir instead\");\\n      },\\n      createLink() {\\n        abort(\"FS.createLink has been removed; use FS.symlink instead\");\\n      },\\n      joinPath() {\\n        abort(\"FS.joinPath has been removed; use PATH.join instead\");\\n      },\\n      mmapAlloc() {\\n        abort(\\n          \"FS.mmapAlloc has been replaced by the top level function mmapAlloc\",\\n        );\\n      },\\n      standardizePath() {\\n        abort(\\n          \"FS.standardizePath has been removed; use PATH.normalize instead\",\\n        );\\n      },\\n    };\\n    var SYSCALLS = {\\n      DEFAULT_POLLMASK: 5,\\n      calculateAt(dirfd, path, allowEmpty) {\\n        if (PATH.isAbs(path)) {\\n          return path;\\n        }\\n        var dir;\\n        if (dirfd === -100) {\\n          dir = FS.cwd();\\n        } else {\\n          var dirstream = SYSCALLS.getStreamFromFD(dirfd);\\n          dir = dirstream.path;\\n        }\\n        if (path.length == 0) {\\n          if (!allowEmpty) {\\n            throw new FS.ErrnoError(44);\\n          }\\n          return dir;\\n        }\\n        return dir + \"/\" + path;\\n      },\\n      writeStat(buf, stat) {\\n        HEAP32[buf / 4] = stat.dev;\\n        HEAP32[(buf + 4) / 4] = stat.mode;\\n        HEAPU64[(buf + 8) / 8] = BigInt(stat.nlink);\\n        HEAP32[(buf + 16) / 4] = stat.uid;\\n        HEAP32[(buf + 20) / 4] = stat.gid;\\n        HEAP32[(buf + 24) / 4] = stat.rdev;\\n        HEAP64[(buf + 32) / 8] = BigInt(stat.size);\\n        HEAP32[(buf + 40) / 4] = 4096;\\n        HEAP32[(buf + 44) / 4] = stat.blocks;\\n        var atime = stat.atime.getTime();\\n        var mtime = stat.mtime.getTime();\\n        var ctime = stat.ctime.getTime();\\n        HEAP64[(buf + 48) / 8] = BigInt(Math.floor(atime / 1e3));\\n        HEAPU64[(buf + 56) / 8] = BigInt((atime % 1e3) * 1e3 * 1e3);\\n        HEAP64[(buf + 64) / 8] = BigInt(Math.floor(mtime / 1e3));\\n        HEAPU64[(buf + 72) / 8] = BigInt((mtime % 1e3) * 1e3 * 1e3);\\n        HEAP64[(buf + 80) / 8] = BigInt(Math.floor(ctime / 1e3));\\n        HEAPU64[(buf + 88) / 8] = BigInt((ctime % 1e3) * 1e3 * 1e3);\\n        HEAP64[(buf + 96) / 8] = BigInt(stat.ino);\\n        return 0;\\n      },\\n      writeStatFs(buf, stats) {\\n        HEAP32[(buf + 8) / 4] = stats.bsize;\\n        HEAP32[(buf + 56) / 4] = stats.bsize;\\n        HEAP32[(buf + 16) / 4] = stats.blocks;\\n        HEAP32[(buf + 20) / 4] = stats.bfree;\\n        HEAP32[(buf + 24) / 4] = stats.bavail;\\n        HEAP32[(buf + 28) / 4] = stats.files;\\n        HEAP32[(buf + 32) / 4] = stats.ffree;\\n        HEAP32[(buf + 36) / 4] = stats.fsid;\\n        HEAP32[(buf + 64) / 4] = stats.flags;\\n        HEAP32[(buf + 48) / 4] = stats.namelen;\\n      },\\n      doMsync(addr, stream, len, flags, offset) {\\n        if (!FS.isFile(stream.node.mode)) {\\n          throw new FS.ErrnoError(43);\\n        }\\n        if (flags & 2) {\\n          return 0;\\n        }\\n        var buffer = HEAPU8.slice(addr, addr + len);\\n        FS.msync(stream, buffer, offset, len, flags);\\n      },\\n      getStreamFromFD(fd) {\\n        var stream = FS.getStreamChecked(fd);\\n        return stream;\\n      },\\n      varargs: undefined,\\n      getStr(ptr) {\\n        var ret = UTF8ToString(ptr);\\n        return ret;\\n      },\\n    };\\n    function ___syscall_fcntl64(fd, cmd, varargs) {\\n      varargs = bigintToI53Checked(varargs);\\n      SYSCALLS.varargs = varargs;\\n      try {\\n        var stream = SYSCALLS.getStreamFromFD(fd);\\n        switch (cmd) {\\n          case 0: {\\n            var arg = syscallGetVarargI();\\n            if (arg < 0) {\\n              return -28;\\n            }\\n            while (FS.streams[arg]) {\\n              arg++;\\n            }\\n            var newStream;\\n            newStream = FS.dupStream(stream, arg);\\n            return newStream.fd;\\n          }\\n          case 1:\\n          case 2:\\n            return 0;\\n          case 3:\\n            return stream.flags;\\n          case 4: {\\n            var arg = syscallGetVarargI();\\n            stream.flags |= arg;\\n            return 0;\\n          }\\n          case 5: {\\n            var arg = syscallGetVarargP();\\n            var offset = 0;\\n            HEAP16[(arg + offset) / 2] = 2;\\n            return 0;\\n          }\\n          case 6:\\n          case 7:\\n            return 0;\\n        }\\n        return -28;\\n      } catch (e) {\\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\\n        return -e.errno;\\n      }\\n    }\\n    function ___syscall_fstat64(fd, buf) {\\n      buf = bigintToI53Checked(buf);\\n      try {\\n        return SYSCALLS.writeStat(buf, FS.fstat(fd));\\n      } catch (e) {\\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\\n        return -e.errno;\\n      }\\n    }\\n    function ___syscall_ioctl(fd, op, varargs) {\\n      varargs = bigintToI53Checked(varargs);\\n      SYSCALLS.varargs = varargs;\\n      try {\\n        var stream = SYSCALLS.getStreamFromFD(fd);\\n        switch (op) {\\n          case 21509: {\\n            if (!stream.tty) return -59;\\n            return 0;\\n          }\\n          case 21505: {\\n            if (!stream.tty) return -59;\\n            if (stream.tty.ops.ioctl_tcgets) {\\n              var termios = stream.tty.ops.ioctl_tcgets(stream);\\n              var argp = syscallGetVarargP();\\n              HEAP32[argp / 4] = termios.c_iflag || 0;\\n              HEAP32[(argp + 4) / 4] = termios.c_oflag || 0;\\n              HEAP32[(argp + 8) / 4] = termios.c_cflag || 0;\\n              HEAP32[(argp + 12) / 4] = termios.c_lflag || 0;\\n              for (var i = 0; i < 32; i++) {\\n                HEAP8[argp + i + 17] = termios.c_cc[i] || 0;\\n              }\\n              return 0;\\n            }\\n            return 0;\\n          }\\n          case 21510:\\n          case 21511:\\n          case 21512: {\\n            if (!stream.tty) return -59;\\n            return 0;\\n          }\\n          case 21506:\\n          case 21507:\\n          case 21508: {\\n            if (!stream.tty) return -59;\\n            if (stream.tty.ops.ioctl_tcsets) {\\n              var argp = syscallGetVarargP();\\n              var c_iflag = HEAP32[argp / 4];\\n              var c_oflag = HEAP32[(argp + 4) / 4];\\n              var c_cflag = HEAP32[(argp + 8) / 4];\\n              var c_lflag = HEAP32[(argp + 12) / 4];\\n              var c_cc = [];\\n              for (var i = 0; i < 32; i++) {\\n                c_cc.push(HEAP8[argp + i + 17]);\\n              }\\n              return stream.tty.ops.ioctl_tcsets(stream.tty, op, {\\n                c_iflag,\\n                c_oflag,\\n                c_cflag,\\n                c_lflag,\\n                c_cc,\\n              });\\n            }\\n            return 0;\\n          }\\n          case 21519: {\\n            if (!stream.tty) return -59;\\n            var argp = syscallGetVarargP();\\n            HEAP32[argp / 4] = 0;\\n            return 0;\\n          }\\n          case 21520: {\\n            if (!stream.tty) return -59;\\n            return -28;\\n          }\\n          case 21531: {\\n            var argp = syscallGetVarargP();\\n            return FS.ioctl(stream, op, argp);\\n          }\\n          case 21523: {\\n            if (!stream.tty) return -59;\\n            if (stream.tty.ops.ioctl_tiocgwinsz) {\\n              var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);\\n              var argp = syscallGetVarargP();\\n              HEAP16[argp / 2] = winsize[0];\\n              HEAP16[(argp + 2) / 2] = winsize[1];\\n            }\\n            return 0;\\n          }\\n          case 21524: {\\n            if (!stream.tty) return -59;\\n            return 0;\\n          }\\n          case 21515: {\\n            if (!stream.tty) return -59;\\n            return 0;\\n          }\\n          default:\\n            return -28;\\n        }\\n      } catch (e) {\\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\\n        return -e.errno;\\n      }\\n    }\\n    function ___syscall_openat(dirfd, path, flags, varargs) {\\n      path = bigintToI53Checked(path);\\n      varargs = bigintToI53Checked(varargs);\\n      SYSCALLS.varargs = varargs;\\n      try {\\n        path = SYSCALLS.getStr(path);\\n        path = SYSCALLS.calculateAt(dirfd, path);\\n        var mode = varargs ? syscallGetVarargI() : 0;\\n        return FS.open(path, flags, mode).fd;\\n      } catch (e) {\\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\\n        return -e.errno;\\n      }\\n    }\\n    var __abort_js = () => abort(\"native code called abort()\");\\n    var runtimeKeepaliveCounter = 0;\\n    var __emscripten_runtime_keepalive_clear = () => {\\n      noExitRuntime = false;\\n      runtimeKeepaliveCounter = 0;\\n    };\\n    function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {\\n      len = bigintToI53Checked(len);\\n      offset = bigintToI53Checked(offset);\\n      allocated = bigintToI53Checked(allocated);\\n      addr = bigintToI53Checked(addr);\\n      try {\\n        if (isNaN(offset)) return 61;\\n        var stream = SYSCALLS.getStreamFromFD(fd);\\n        var res = FS.mmap(stream, len, offset, prot, flags);\\n        var ptr = res.ptr;\\n        HEAP32[allocated / 4] = res.allocated;\\n        HEAPU64[addr / 8] = BigInt(ptr);\\n        return 0;\\n      } catch (e) {\\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\\n        return -e.errno;\\n      }\\n    }\\n    function __munmap_js(addr, len, prot, flags, fd, offset) {\\n      addr = bigintToI53Checked(addr);\\n      len = bigintToI53Checked(len);\\n      offset = bigintToI53Checked(offset);\\n      try {\\n        var stream = SYSCALLS.getStreamFromFD(fd);\\n        if (prot & 2) {\\n          SYSCALLS.doMsync(addr, stream, len, flags, offset);\\n        }\\n      } catch (e) {\\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\\n        return -e.errno;\\n      }\\n    }\\n    var timers = {};\\n    var handleException = (e) => {\\n      if (e instanceof ExitStatus || e == \"unwind\") {\\n        return EXITSTATUS;\\n      }\\n      checkStackCookie();\\n      if (e instanceof WebAssembly.RuntimeError) {\\n        if (_emscripten_stack_get_current() <= 0) {\\n          err(\\n            \"Stack overflow detected.  You can try increasing -sSTACK_SIZE (currently set to 65536)\",\\n          );\\n        }\\n      }\\n      quit_(1, e);\\n    };\\n    var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;\\n    var _proc_exit = (code) => {\\n      EXITSTATUS = code;\\n      if (!keepRuntimeAlive()) {\\n        Module[\"onExit\"]?.(code);\\n        ABORT = true;\\n      }\\n      quit_(code, new ExitStatus(code));\\n    };\\n    var exitJS = (statusw, implicit) => {\\n      EXITSTATUS = statusw;\\n      checkUnflushedContent();\\n      if (keepRuntimeAlive() && !implicit) {\\n\\n        for (let i = 0; i < instructions.length; i++){\\n          instructions[i]._rowVariant = \\'\\';\\n        }\\n        status.run_program = -1; // program finished\\n        if (statusw !== 0){\\n          reset_disable.value = false;\\n          instruction_disable.value = true;\\n          run_disable.value = true;\\n          stop_disable.value = false;\\n          show_notification(\"Your program has finished with errors.\", \"danger\");\\n        } else {\\n          reset_disable.value = false;\\n          instruction_disable.value = false;\\n          run_disable.value = false;\\n          stop_disable.value = true;\\n          isFinished.value = true;\\n        }\\n        var msg = `program exited (with status: ${statusw}), but keepRuntimeAlive() is set (counter=${runtimeKeepaliveCounter}) due to an async operation, so halting execution but not exiting the runtime or preventing further async execution (you can use emscripten_force_exit, if you want to force a true shutdown)`;\\n        readyPromiseReject(msg);\\n        err(msg);\\n      }\\n      _proc_exit(statusw);\\n    };\\n    var _exit = exitJS;\\n    var maybeExit = () => {\\n      if (!keepRuntimeAlive()) {\\n        try {\\n          _exit(EXITSTATUS);\\n        } catch (e) {\\n          handleException(e);\\n        }\\n      }\\n    };\\n    var callUserCallback = (func) => {\\n      if (ABORT) {\\n        err(\\n          \"user callback triggered after runtime exited or application aborted.  Ignoring.\",\\n        );\\n        return;\\n      }\\n      try {\\n        func();\\n        maybeExit();\\n      } catch (e) {\\n        handleException(e);\\n      }\\n    };\\n    var _emscripten_get_now = () => performance.now();\\n    var __setitimer_js = (which, timeout_ms) => {\\n      if (timers[which]) {\\n        clearTimeout(timers[which].id);\\n        delete timers[which];\\n      }\\n      if (!timeout_ms) return 0;\\n      var id = setTimeout(() => {\\n        assert(which in timers);\\n        delete timers[which];\\n        callUserCallback(() =>\\n          __emscripten_timeout(which, _emscripten_get_now()),\\n        );\\n      }, timeout_ms);\\n      timers[which] = { id, timeout_ms };\\n      return 0;\\n    };\\n    var _emscripten_set_main_loop_timing = (mode, value) => {\\n      MainLoop.timingMode = mode;\\n      MainLoop.timingValue = value;\\n      if (!MainLoop.func) {\\n        err(\\n          \"emscripten_set_main_loop_timing: Cannot set timing mode for main loop since a main loop does not exist! Call emscripten_set_main_loop first to set one up.\",\\n        );\\n        return 1;\\n      }\\n      if (!MainLoop.running) {\\n        MainLoop.running = true;\\n      }\\n      if (mode == 0) {\\n        MainLoop.scheduler = function MainLoop_scheduler_setTimeout() {\\n          var timeUntilNextTick =\\n            Math.max(\\n              0,\\n              MainLoop.tickStartTime + value - _emscripten_get_now(),\\n            ) | 0;\\n          setTimeout(MainLoop.runner, timeUntilNextTick);\\n        };\\n        MainLoop.method = \"timeout\";\\n      } else if (mode == 1) {\\n        MainLoop.scheduler = function MainLoop_scheduler_rAF() {\\n          MainLoop.requestAnimationFrame(MainLoop.runner);\\n        };\\n        MainLoop.method = \"rAF\";\\n      } else if (mode == 2) {\\n        if (typeof MainLoop.setImmediate == \"undefined\") {\\n          if (typeof setImmediate == \"undefined\") {\\n            var setImmediates = [];\\n            var emscriptenMainLoopMessageId = \"setimmediate\";\\n            var MainLoop_setImmediate_messageHandler = (event) => {\\n              if (\\n                event.data === emscriptenMainLoopMessageId ||\\n                event.data.target === emscriptenMainLoopMessageId\\n              ) {\\n                event.stopPropagation();\\n                setImmediates.shift()();\\n              }\\n            };\\n            addEventListener(\\n              \"message\",\\n              MainLoop_setImmediate_messageHandler,\\n              true,\\n            );\\n            MainLoop.setImmediate = (func) => {\\n              setImmediates.push(func);\\n              if (ENVIRONMENT_IS_WORKER) {\\n                Module[\"setImmediates\"] ??= [];\\n                Module[\"setImmediates\"].push(func);\\n                postMessage({ target: emscriptenMainLoopMessageId });\\n              } else postMessage(emscriptenMainLoopMessageId, \"*\");\\n            };\\n          } else {\\n            MainLoop.setImmediate = setImmediate;\\n          }\\n        }\\n        MainLoop.scheduler = function MainLoop_scheduler_setImmediate() {\\n          MainLoop.setImmediate(MainLoop.runner);\\n        };\\n        MainLoop.method = \"immediate\";\\n      }\\n      return 0;\\n    };\\n    var setMainLoop = (\\n      iterFunc,\\n      fps,\\n      simulateInfiniteLoop,\\n      arg,\\n      noSetTiming,\\n    ) => {\\n      assert(\\n        !MainLoop.func,\\n        \"emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters.\",\\n      );\\n      MainLoop.func = iterFunc;\\n      MainLoop.arg = arg;\\n      var thisMainLoopId = MainLoop.currentlyRunningMainloop;\\n      function checkIsRunning() {\\n        if (thisMainLoopId < MainLoop.currentlyRunningMainloop) {\\n          maybeExit();\\n          return false;\\n        }\\n        return true;\\n      }\\n      MainLoop.running = false;\\n      MainLoop.runner = function MainLoop_runner() {\\n        if (ABORT) return;\\n        if (MainLoop.queue.length > 0) {\\n          var start = Date.now();\\n          var blocker = MainLoop.queue.shift();\\n          blocker.func(blocker.arg);\\n          if (MainLoop.remainingBlockers) {\\n            var remaining = MainLoop.remainingBlockers;\\n            var next =\\n              remaining % 1 == 0 ? remaining - 1 : Math.floor(remaining);\\n            if (blocker.counted) {\\n              MainLoop.remainingBlockers = next;\\n            } else {\\n              next = next + 0.5;\\n              MainLoop.remainingBlockers = (8 * remaining + next) / 9;\\n            }\\n          }\\n          MainLoop.updateStatus();\\n          if (!checkIsRunning()) return;\\n          setTimeout(MainLoop.runner, 0);\\n          return;\\n        }\\n        if (!checkIsRunning()) return;\\n        MainLoop.currentFrameNumber = (MainLoop.currentFrameNumber + 1) | 0;\\n        if (\\n          MainLoop.timingMode == 1 &&\\n          MainLoop.timingValue > 1 &&\\n          MainLoop.currentFrameNumber % MainLoop.timingValue != 0\\n        ) {\\n          MainLoop.scheduler();\\n          return;\\n        } else if (MainLoop.timingMode == 0) {\\n          MainLoop.tickStartTime = _emscripten_get_now();\\n        }\\n        if (MainLoop.method === \"timeout\" && Module[\"ctx\"]) {\\n          warnOnce(\\n            \"Looks like you are rendering without using requestAnimationFrame for the main loop. You should use 0 for the frame rate in emscripten_set_main_loop in order to use requestAnimationFrame, as that can greatly improve your frame rates!\",\\n          );\\n          MainLoop.method = \"\";\\n        }\\n        MainLoop.runIter(iterFunc);\\n        if (!checkIsRunning()) return;\\n        MainLoop.scheduler();\\n      };\\n      if (!noSetTiming) {\\n        if (fps > 0) {\\n          _emscripten_set_main_loop_timing(0, 1e3 / fps);\\n        } else {\\n          _emscripten_set_main_loop_timing(1, 1);\\n        }\\n        MainLoop.scheduler();\\n      }\\n      if (simulateInfiniteLoop) {\\n        throw \"unwind\";\\n      }\\n    };\\n    var MainLoop = {\\n      running: false,\\n      scheduler: null,\\n      method: \"\",\\n      currentlyRunningMainloop: 0,\\n      func: null,\\n      arg: 0,\\n      timingMode: 0,\\n      timingValue: 0,\\n      currentFrameNumber: 0,\\n      queue: [],\\n      preMainLoop: [],\\n      postMainLoop: [],\\n      pause() {\\n        MainLoop.scheduler = null;\\n        MainLoop.currentlyRunningMainloop++;\\n      },\\n      resume() {\\n        MainLoop.currentlyRunningMainloop++;\\n        var timingMode = MainLoop.timingMode;\\n        var timingValue = MainLoop.timingValue;\\n        var func = MainLoop.func;\\n        MainLoop.func = null;\\n        setMainLoop(func, 0, false, MainLoop.arg, true);\\n        _emscripten_set_main_loop_timing(timingMode, timingValue);\\n        MainLoop.scheduler();\\n      },\\n      updateStatus() {\\n        if (Module[\"setStatus\"]) {\\n          var message = Module[\"statusMessage\"] || \"Please wait...\";\\n          var remaining = MainLoop.remainingBlockers ?? 0;\\n          var expected = MainLoop.expectedBlockers ?? 0;\\n          if (remaining) {\\n            if (remaining < expected) {\\n              Module[\"setStatus\"](\\n                `{message} ({expected - remaining}/{expected})`,\\n              );\\n            } else {\\n              Module[\"setStatus\"](message);\\n            }\\n          } else {\\n            Module[\"setStatus\"](\"\");\\n          }\\n        }\\n      },\\n      init() {\\n        Module[\"preMainLoop\"] &&\\n          MainLoop.preMainLoop.push(Module[\"preMainLoop\"]);\\n        Module[\"postMainLoop\"] &&\\n          MainLoop.postMainLoop.push(Module[\"postMainLoop\"]);\\n      },\\n      runIter(func) {\\n        if (ABORT) return;\\n        for (var pre of MainLoop.preMainLoop) {\\n          if (pre() === false) {\\n            return;\\n          }\\n        }\\n        callUserCallback(func);\\n        for (var post of MainLoop.postMainLoop) {\\n          post();\\n        }\\n        checkStackCookie();\\n      },\\n      nextRAF: 0,\\n      fakeRequestAnimationFrame(func) {\\n        var now = Date.now();\\n        if (MainLoop.nextRAF === 0) {\\n          MainLoop.nextRAF = now + 1e3 / 60;\\n        } else {\\n          while (now + 2 >= MainLoop.nextRAF) {\\n            MainLoop.nextRAF += 1e3 / 60;\\n          }\\n        }\\n        var delay = Math.max(MainLoop.nextRAF - now, 0);\\n        setTimeout(func, delay);\\n      },\\n      requestAnimationFrame(func) {\\n        if (typeof requestAnimationFrame == \"function\") {\\n          requestAnimationFrame(func);\\n          return;\\n        }\\n        var RAF = MainLoop.fakeRequestAnimationFrame;\\n        RAF(func);\\n      },\\n    };\\n    var _emscripten_date_now = () => Date.now();\\n    var getHeapMax = () => 2147483648;\\n    var growMemory = (size) => {\\n      var b = wasmMemory.buffer;\\n      var pages = ((size - b.byteLength + 65535) / 65536) | 0;\\n      try {\\n        wasmMemory.grow(BigInt(pages));\\n        updateMemoryViews();\\n        return 1;\\n      } catch (e) {\\n        err(\\n          `growMemory: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`,\\n        );\\n      }\\n    };\\n    function _emscripten_resize_heap(requestedSize) {\\n      requestedSize = bigintToI53Checked(requestedSize);\\n      var oldSize = HEAPU8.length;\\n      assert(requestedSize > oldSize);\\n      var maxHeapSize = getHeapMax();\\n      if (requestedSize > maxHeapSize) {\\n        err(\\n          `Cannot enlarge memory, requested ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`,\\n        );\\n        return false;\\n      }\\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\\n        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\\n        overGrownHeapSize = Math.min(\\n          overGrownHeapSize,\\n          requestedSize + 100663296,\\n        );\\n        var newSize = Math.min(\\n          maxHeapSize,\\n          alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536),\\n        );\\n        var replacement = growMemory(newSize);\\n        if (replacement) {\\n          return true;\\n        }\\n      }\\n      err(\\n        `Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`,\\n      );\\n      return false;\\n    }\\n    function _emscripten_run_script_int(ptr) {\\n      ptr = bigintToI53Checked(ptr);\\n      return eval(UTF8ToString(ptr)) | 0;\\n    }\\n    var safeSetTimeout = (func, timeout) =>\\n      setTimeout(() => {\\n        callUserCallback(func);\\n      }, timeout);\\n    var _emscripten_sleep = (ms) =>\\n      Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));\\n    _emscripten_sleep.isAsync = true;\\n    function _fd_close(fd) {\\n      try {\\n        var stream = SYSCALLS.getStreamFromFD(fd);\\n        FS.close(stream);\\n        return 0;\\n      } catch (e) {\\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\\n        return e.errno;\\n      }\\n    }\\n    var doReadv = (stream, iov, iovcnt, offset) => {\\n      var ret = 0;\\n      for (var i = 0; i < iovcnt; i++) {\\n        var ptr = Number(HEAPU64[iov / 8]);\\n        var len = Number(HEAPU64[(iov + 8) / 8]);\\n        iov += 16;\\n        var curr = FS.read(stream, HEAP8, ptr, len, offset);\\n        if (curr < 0) return -1;\\n        ret += curr;\\n        if (curr < len) break;\\n        if (typeof offset != \"undefined\") {\\n          offset += curr;\\n        }\\n      }\\n      return ret;\\n    };\\n    function _fd_read(fd, iov, iovcnt, pnum) {\\n      iov = bigintToI53Checked(iov);\\n      iovcnt = bigintToI53Checked(iovcnt);\\n      pnum = bigintToI53Checked(pnum);\\n      try {\\n        var stream = SYSCALLS.getStreamFromFD(fd);\\n        var num = doReadv(stream, iov, iovcnt);\\n        HEAPU64[pnum / 8] = BigInt(num);\\n        return 0;\\n      } catch (e) {\\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\\n        return e.errno;\\n      }\\n    }\\n    function _fd_seek(fd, offset, whence, newOffset) {\\n      offset = bigintToI53Checked(offset);\\n      newOffset = bigintToI53Checked(newOffset);\\n      try {\\n        if (isNaN(offset)) return 61;\\n        var stream = SYSCALLS.getStreamFromFD(fd);\\n        FS.llseek(stream, offset, whence);\\n        HEAP64[newOffset / 8] = BigInt(stream.position);\\n        if (stream.getdents && offset === 0 && whence === 0)\\n          stream.getdents = null;\\n        return 0;\\n      } catch (e) {\\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\\n        return e.errno;\\n      }\\n    }\\n    var doWritev = (stream, iov, iovcnt, offset) => {\\n      var ret = 0;\\n      for (var i = 0; i < iovcnt; i++) {\\n        var ptr = Number(HEAPU64[iov / 8]);\\n        var len = Number(HEAPU64[(iov + 8) / 8]);\\n        iov += 16;\\n        var curr = FS.write(stream, HEAP8, ptr, len, offset);\\n        if (curr < 0) return -1;\\n        ret += curr;\\n        if (curr < len) {\\n          break;\\n        }\\n        if (typeof offset != \"undefined\") {\\n          offset += curr;\\n        }\\n      }\\n      return ret;\\n    };\\n    function _fd_write(fd, iov, iovcnt, pnum) {\\n      iov = bigintToI53Checked(iov);\\n      iovcnt = bigintToI53Checked(iovcnt);\\n      pnum = bigintToI53Checked(pnum);\\n      try {\\n        var stream = SYSCALLS.getStreamFromFD(fd);\\n        var num = doWritev(stream, iov, iovcnt);\\n        HEAPU64[pnum / 8] = BigInt(num);\\n        return 0;\\n      } catch (e) {\\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\\n        return e.errno;\\n      }\\n    }\\n    var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {\\n      assert(\\n        typeof maxBytesToWrite == \"number\",\\n        \"stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\",\\n      );\\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\\n    };\\n    var stackAlloc = (sz) => __emscripten_stack_alloc(sz);\\n    var stringToUTF8OnStack = (str) => {\\n      var size = lengthBytesUTF8(str) + 1;\\n      var ret = stackAlloc(size);\\n      stringToUTF8(str, ret, size);\\n      return ret;\\n    };\\n    var runAndAbortIfError = (func) => {\\n      try {\\n        return func();\\n      } catch (e) {\\n        abort(e);\\n      }\\n    };\\n    var runtimeKeepalivePush = () => {\\n      runtimeKeepaliveCounter += 1;\\n    };\\n    var runtimeKeepalivePop = () => {\\n      assert(runtimeKeepaliveCounter > 0);\\n      runtimeKeepaliveCounter -= 1;\\n    };\\n    var Asyncify = {\\n      rewindArguments: {},\\n      instrumentWasmImports(imports) {\\n        var importPattern = /^(invoke_.*|__asyncjs__.*)$/;\\n        for (let [x, original] of Object.entries(imports)) {\\n          if (typeof original == \"function\") {\\n            let isAsyncifyImport = original.isAsync || importPattern.test(x);\\n            imports[x] = (...args) => {\\n              var originalAsyncifyState = Asyncify.state;\\n              try {\\n                return original(...args);\\n              } finally {\\n                var changedToDisabled =\\n                  originalAsyncifyState === Asyncify.State.Normal &&\\n                  Asyncify.state === Asyncify.State.Disabled;\\n                var ignoredInvoke = x.startsWith(\"invoke_\") && true;\\n                if (\\n                  Asyncify.state !== originalAsyncifyState &&\\n                  !isAsyncifyImport &&\\n                  !changedToDisabled &&\\n                  !ignoredInvoke\\n                ) {\\n                  throw new Error(\\n                    `import ${x} was not in ASYNCIFY_IMPORTS, but changed the state`,\\n                  );\\n                }\\n              }\\n            };\\n          }\\n        }\\n      },\\n      saveRewindArguments(funcName, passedArguments) {\\n        return (Asyncify.rewindArguments[funcName] =\\n          Array.from(passedArguments));\\n      },\\n      restoreRewindArguments(funcName) {\\n        return Asyncify.rewindArguments[funcName] || [];\\n      },\\n      instrumentWasmExports(exports) {\\n        var ret = {};\\n        for (let [x, original] of Object.entries(exports)) {\\n          if (typeof original == \"function\") {\\n            ret[x] = (...args) => {\\n              Asyncify.exportCallStack.push(x);\\n              try {\\n                Asyncify.saveRewindArguments(x, args);\\n                return original(...args);\\n              } finally {\\n                if (!ABORT) {\\n                  var y = Asyncify.exportCallStack.pop();\\n                  assert(y === x);\\n                  Asyncify.maybeStopUnwind();\\n                }\\n              }\\n            };\\n          } else {\\n            ret[x] = original;\\n          }\\n        }\\n        return ret;\\n      },\\n      State: { Normal: 0, Unwinding: 1, Rewinding: 2, Disabled: 3 },\\n      state: 0,\\n      StackSize: 4096,\\n      currData: null,\\n      handleSleepReturnValue: 0,\\n      exportCallStack: [],\\n      callStackNameToId: {},\\n      callStackIdToName: {},\\n      callStackId: 0,\\n      asyncPromiseHandlers: null,\\n      sleepCallbacks: [],\\n      getCallStackId(funcName) {\\n        var id = Asyncify.callStackNameToId[funcName];\\n        if (id === undefined) {\\n          id = Asyncify.callStackId++;\\n          Asyncify.callStackNameToId[funcName] = id;\\n          Asyncify.callStackIdToName[id] = funcName;\\n        }\\n        return id;\\n      },\\n      maybeStopUnwind() {\\n        if (\\n          Asyncify.currData &&\\n          Asyncify.state === Asyncify.State.Unwinding &&\\n          Asyncify.exportCallStack.length === 0\\n        ) {\\n          Asyncify.state = Asyncify.State.Normal;\\n          runAndAbortIfError(_asyncify_stop_unwind);\\n          if (typeof Fibers != \"undefined\") {\\n            Fibers.trampoline();\\n          }\\n        }\\n      },\\n      whenDone() {\\n        assert(\\n          Asyncify.currData,\\n          \"Tried to wait for an async operation when none is in progress.\",\\n        );\\n        assert(\\n          !Asyncify.asyncPromiseHandlers,\\n          \"Cannot have multiple async operations in flight at once\",\\n        );\\n        return new Promise((resolve, reject) => {\\n          Asyncify.asyncPromiseHandlers = { resolve, reject };\\n        });\\n      },\\n      allocateData() {\\n        var ptr = _malloc(24 + Asyncify.StackSize);\\n        Asyncify.setDataHeader(ptr, ptr + 24, Asyncify.StackSize);\\n        Asyncify.setDataRewindFunc(ptr);\\n        return ptr;\\n      },\\n      setDataHeader(ptr, stack, stackSize) {\\n        HEAPU64[ptr / 8] = BigInt(stack);\\n        HEAPU64[(ptr + 8) / 8] = BigInt(stack + stackSize);\\n      },\\n      setDataRewindFunc(ptr) {\\n        var bottomOfCallStack = Asyncify.exportCallStack[0];\\n        var rewindId = Asyncify.getCallStackId(bottomOfCallStack);\\n        HEAP32[(ptr + 16) / 4] = rewindId;\\n      },\\n      getDataRewindFuncName(ptr) {\\n        var id = HEAP32[(ptr + 16) / 4];\\n        var name = Asyncify.callStackIdToName[id];\\n        return name;\\n      },\\n      getDataRewindFunc(name) {\\n        var func = wasmExports[name];\\n        return func;\\n      },\\n      doRewind(ptr) {\\n        var name = Asyncify.getDataRewindFuncName(ptr);\\n        var func = Asyncify.getDataRewindFunc(name);\\n        return func(...Asyncify.restoreRewindArguments(name));\\n      },\\n      handleSleep(startAsync) {\\n        assert(\\n          Asyncify.state !== Asyncify.State.Disabled,\\n          \"Asyncify cannot be done during or after the runtime exits\",\\n        );\\n        if (ABORT) return;\\n        if (Asyncify.state === Asyncify.State.Normal) {\\n          var reachedCallback = false;\\n          var reachedAfterCallback = false;\\n          startAsync((handleSleepReturnValue = 0) => {\\n            assert(\\n              !handleSleepReturnValue ||\\n                typeof handleSleepReturnValue == \"number\" ||\\n                typeof handleSleepReturnValue == \"boolean\",\\n            );\\n            if (ABORT) return;\\n            Asyncify.handleSleepReturnValue = handleSleepReturnValue;\\n            reachedCallback = true;\\n            if (!reachedAfterCallback) {\\n              return;\\n            }\\n            assert(\\n              !Asyncify.exportCallStack.length,\\n              \"Waking up (starting to rewind) must be done from JS, without compiled code on the stack.\",\\n            );\\n            Asyncify.state = Asyncify.State.Rewinding;\\n            runAndAbortIfError(() => _asyncify_start_rewind(Asyncify.currData));\\n            if (typeof MainLoop != \"undefined\" && MainLoop.func) {\\n              MainLoop.resume();\\n            }\\n            var asyncWasmReturnValue,\\n              isError = false;\\n            try {\\n              asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);\\n            } catch (err) {\\n              asyncWasmReturnValue = err;\\n              isError = true;\\n            }\\n            var handled = false;\\n            if (!Asyncify.currData) {\\n              var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;\\n              if (asyncPromiseHandlers) {\\n                Asyncify.asyncPromiseHandlers = null;\\n                (isError\\n                  ? asyncPromiseHandlers.reject\\n                  : asyncPromiseHandlers.resolve)(asyncWasmReturnValue);\\n                handled = true;\\n              }\\n            }\\n            if (isError && !handled) {\\n              throw asyncWasmReturnValue;\\n            }\\n          });\\n          reachedAfterCallback = true;\\n          if (!reachedCallback) {\\n            Asyncify.state = Asyncify.State.Unwinding;\\n            Asyncify.currData = Asyncify.allocateData();\\n            if (typeof MainLoop != \"undefined\" && MainLoop.func) {\\n              MainLoop.pause();\\n            }\\n            runAndAbortIfError(() => _asyncify_start_unwind(Asyncify.currData));\\n          }\\n        } else if (Asyncify.state === Asyncify.State.Rewinding) {\\n          Asyncify.state = Asyncify.State.Normal;\\n          runAndAbortIfError(_asyncify_stop_rewind);\\n          _free(Asyncify.currData);\\n          Asyncify.currData = null;\\n          Asyncify.sleepCallbacks.forEach(callUserCallback);\\n        } else {\\n          abort(`invalid state: ${Asyncify.state}`);\\n        }\\n        return Asyncify.handleSleepReturnValue;\\n      },\\n      handleAsync(startAsync) {\\n        return Asyncify.handleSleep((wakeUp) => {\\n          startAsync().then(wakeUp);\\n        });\\n      },\\n    };\\n    var getCFunc = (ident) => {\\n      var func = Module[\"_\" + ident];\\n      assert(\\n        func,\\n        \"Cannot call unknown function \" + ident + \", make sure it is exported\",\\n      );\\n      return func;\\n    };\\n    var writeArrayToMemory = (array, buffer) => {\\n      assert(\\n        array.length >= 0,\\n        \"writeArrayToMemory array must have a length (should be an array or typed array)\",\\n      );\\n      HEAP8.set(array, buffer);\\n    };\\n    var ccall = (ident, returnType, argTypes, args, opts) => {\\n      var toC = {\\n        pointer: (p) => BigInt(p),\\n        string: (str) => {\\n          var ret = 0;\\n          if (str !== null && str !== undefined && str !== 0) {\\n            ret = stringToUTF8OnStack(str);\\n          }\\n          return BigInt(ret);\\n        },\\n        array: (arr) => {\\n          var ret = stackAlloc(arr.length);\\n          writeArrayToMemory(arr, ret);\\n          return BigInt(ret);\\n        },\\n      };\\n      function convertReturnValue(ret) {\\n        if (returnType === \"string\") {\\n          return UTF8ToString(Number(ret));\\n        }\\n        if (returnType === \"pointer\") return Number(ret);\\n        if (returnType === \"boolean\") return Boolean(ret);\\n        return ret;\\n      }\\n      var func = getCFunc(ident);\\n      var cArgs = [];\\n      var stack = 0;\\n      assert(returnType !== \"array\", \\'Return type should not be \"array\".\\');\\n      if (args) {\\n        for (var i = 0; i < args.length; i++) {\\n          var converter = toC[argTypes[i]];\\n          if (converter) {\\n            if (stack === 0) stack = stackSave();\\n            cArgs[i] = converter(args[i]);\\n          } else {\\n            cArgs[i] = args[i];\\n          }\\n        }\\n      }\\n      var previousAsync = Asyncify.currData;\\n      var ret = func(...cArgs);\\n      function onDone(ret) {\\n        runtimeKeepalivePop();\\n        if (stack !== 0) stackRestore(stack);\\n        return convertReturnValue(ret);\\n      }\\n      var asyncMode = opts?.async;\\n      runtimeKeepalivePush();\\n      if (Asyncify.currData != previousAsync) {\\n        assert(\\n          !(previousAsync && Asyncify.currData),\\n          \"We cannot start an async operation when one is already flight\",\\n        );\\n        assert(\\n          !(previousAsync && !Asyncify.currData),\\n          \"We cannot stop an async operation in flight\",\\n        );\\n        assert(\\n          asyncMode,\\n          \"The call to \" +\\n            ident +\\n            \" is running asynchronously. If this was intended, add the async option to the ccall/cwrap call.\",\\n        );\\n        return Asyncify.whenDone().then(onDone);\\n      }\\n      ret = onDone(ret);\\n      if (asyncMode) return Promise.resolve(ret);\\n      return ret;\\n    };\\n    FS.createPreloadedFile = FS_createPreloadedFile;\\n    FS.staticInit();\\n    Module[\"requestAnimationFrame\"] = MainLoop.requestAnimationFrame;\\n    Module[\"pauseMainLoop\"] = MainLoop.pause;\\n    Module[\"resumeMainLoop\"] = MainLoop.resume;\\n    MainLoop.init();\\n    function checkIncomingModuleAPI() {\\n      ignoredModuleProp(\"fetchSettings\");\\n    }\\n    var wasmImports = {\\n      __assert_fail: ___assert_fail,\\n      __syscall_fcntl64: ___syscall_fcntl64,\\n      __syscall_fstat64: ___syscall_fstat64,\\n      __syscall_ioctl: ___syscall_ioctl,\\n      __syscall_openat: ___syscall_openat,\\n      _abort_js: __abort_js,\\n      _emscripten_runtime_keepalive_clear: __emscripten_runtime_keepalive_clear,\\n      _mmap_js: __mmap_js,\\n      _munmap_js: __munmap_js,\\n      _setitimer_js: __setitimer_js,\\n      emscripten_date_now: _emscripten_date_now,\\n      emscripten_resize_heap: _emscripten_resize_heap,\\n      emscripten_run_script_int: _emscripten_run_script_int,\\n      emscripten_sleep: _emscripten_sleep,\\n      exit: _exit,\\n      fd_close: _fd_close,\\n      fd_read: _fd_read,\\n      fd_seek: _fd_seek,\\n      fd_write: _fd_write,\\n      proc_exit: _proc_exit,\\n    };\\n    var wasmExports = await createWasm();\\n    var ___wasm_call_ctors = createExportWrapper(\"__wasm_call_ctors\", 0);\\n    var _malloc = (Module[\"_malloc\"] = createExportWrapper(\"malloc\", 1));\\n    var _free = (Module[\"_free\"] = createExportWrapper(\"free\", 1));\\n    var _send_int_to_C = (Module[\"_send_int_to_C\"] = createExportWrapper(\\n      \"send_int_to_C\",\\n      1,\\n    ));\\n    var _send_float_to_C = (Module[\"_send_float_to_C\"] = createExportWrapper(\\n      \"send_float_to_C\",\\n      1,\\n    ));\\n    var _send_double_to_C = (Module[\"_send_double_to_C\"] = createExportWrapper(\\n      \"send_double_to_C\",\\n      1,\\n    ));\\n    var _send_char_to_C = (Module[\"_send_char_to_C\"] = createExportWrapper(\\n      \"send_char_to_C\",\\n      1,\\n    ));\\n    var _send_string_to_C = (Module[\"_send_string_to_C\"] = createExportWrapper(\\n      \"send_string_to_C\",\\n      1,\\n    ));\\n    var _reanudar_ejecucion = (Module[\"_reanudar_ejecucion\"] =\\n      createExportWrapper(\"reanudar_ejecucion\", 1));\\n    var _strerror = createExportWrapper(\"strerror\", 1);\\n    var _fflush = createExportWrapper(\"fflush\", 1);\\n    var _main = (Module[\"_main\"] = createExportWrapper(\"__main_argc_argv\", 2));\\n    var _emscripten_builtin_memalign = createExportWrapper(\\n      \"emscripten_builtin_memalign\",\\n      2,\\n    );\\n    var __emscripten_timeout = createExportWrapper(\"_emscripten_timeout\", 2);\\n    var _emscripten_stack_init = wasmExports[\"emscripten_stack_init\"];\\n    var _emscripten_stack_get_free = wasmExports[\"emscripten_stack_get_free\"];\\n    var _emscripten_stack_get_base = wasmExports[\"emscripten_stack_get_base\"];\\n    var _emscripten_stack_get_end = wasmExports[\"emscripten_stack_get_end\"];\\n    var __emscripten_stack_restore = wasmExports[\"_emscripten_stack_restore\"];\\n    var __emscripten_stack_alloc = wasmExports[\"_emscripten_stack_alloc\"];\\n    var _emscripten_stack_get_current =\\n      wasmExports[\"emscripten_stack_get_current\"];\\n    var ___cxa_increment_exception_refcount = createExportWrapper(\\n      \"__cxa_increment_exception_refcount\",\\n      1,\\n    );\\n    var dynCall_jj = (Module[\"dynCall_jj\"] = createExportWrapper(\\n      \"dynCall_jj\",\\n      2,\\n    ));\\n    var dynCall_jjjj = (Module[\"dynCall_jjjj\"] = createExportWrapper(\\n      \"dynCall_jjjj\",\\n      4,\\n    ));\\n    var dynCall_vjj = (Module[\"dynCall_vjj\"] = createExportWrapper(\\n      \"dynCall_vjj\",\\n      3,\\n    ));\\n    var dynCall_ijjj = (Module[\"dynCall_ijjj\"] = createExportWrapper(\\n      \"dynCall_ijjj\",\\n      4,\\n    ));\\n    var dynCall_ijii = (Module[\"dynCall_ijii\"] = createExportWrapper(\\n      \"dynCall_ijii\",\\n      4,\\n    ));\\n    var dynCall_ij = (Module[\"dynCall_ij\"] = createExportWrapper(\\n      \"dynCall_ij\",\\n      2,\\n    ));\\n    var dynCall_jjii = (Module[\"dynCall_jjii\"] = createExportWrapper(\\n      \"dynCall_jjii\",\\n      4,\\n    ));\\n    var dynCall_jjji = (Module[\"dynCall_jjji\"] = createExportWrapper(\\n      \"dynCall_jjji\",\\n      4,\\n    ));\\n    var dynCall_ijdiiii = (Module[\"dynCall_ijdiiii\"] = createExportWrapper(\\n      \"dynCall_ijdiiii\",\\n      7,\\n    ));\\n    var dynCall_v = (Module[\"dynCall_v\"] = createExportWrapper(\"dynCall_v\", 1));\\n    var dynCall_vi = (Module[\"dynCall_vi\"] = createExportWrapper(\\n      \"dynCall_vi\",\\n      2,\\n    ));\\n    var _asyncify_start_unwind = createExportWrapper(\\n      \"asyncify_start_unwind\",\\n      1,\\n    );\\n    var _asyncify_stop_unwind = createExportWrapper(\"asyncify_stop_unwind\", 0);\\n    var _asyncify_start_rewind = createExportWrapper(\\n      \"asyncify_start_rewind\",\\n      1,\\n    );\\n    var _asyncify_stop_rewind = createExportWrapper(\"asyncify_stop_rewind\", 0);\\n    function applySignatureConversions(wasmExports) {\\n      wasmExports = Object.assign({}, wasmExports);\\n      var makeWrapper_pp = (f) => (a0) => Number(f(BigInt(a0)));\\n      var makeWrapper__p = (f) => (a0) => f(BigInt(a0));\\n      var makeWrapper_p_ = (f) => (a0) => Number(f(a0));\\n      var makeWrapper___PP = (f) => (a0, a1, a2) =>\\n        f(a0, BigInt(a1 ? a1 : 0), BigInt(a2 ? a2 : 0));\\n      var makeWrapper_ppp = (f) => (a0, a1) =>\\n        Number(f(BigInt(a0), BigInt(a1)));\\n      var makeWrapper_p = (f) => () => Number(f());\\n      var makeWrapper__p_ = (f) => (a0, a1) => f(BigInt(a0), a1);\\n      var makeWrapper__p___ = (f) => (a0, a1, a2, a3) =>\\n        f(BigInt(a0), a1, a2, a3);\\n      var makeWrapper__p__ = (f) => (a0, a1, a2) => f(BigInt(a0), a1, a2);\\n      var makeWrapper__p______ = (f) => (a0, a1, a2, a3, a4, a5, a6) =>\\n        f(BigInt(a0), a1, a2, a3, a4, a5, a6);\\n      wasmExports[\"malloc\"] = makeWrapper_pp(wasmExports[\"malloc\"]);\\n      wasmExports[\"free\"] = makeWrapper__p(wasmExports[\"free\"]);\\n      wasmExports[\"strerror\"] = makeWrapper_p_(wasmExports[\"strerror\"]);\\n      wasmExports[\"fflush\"] = makeWrapper__p(wasmExports[\"fflush\"]);\\n      wasmExports[\"__main_argc_argv\"] = makeWrapper___PP(\\n        wasmExports[\"__main_argc_argv\"],\\n      );\\n      wasmExports[\"emscripten_builtin_memalign\"] = makeWrapper_ppp(\\n        wasmExports[\"emscripten_builtin_memalign\"],\\n      );\\n      wasmExports[\"emscripten_stack_get_base\"] = makeWrapper_p(\\n        wasmExports[\"emscripten_stack_get_base\"],\\n      );\\n      wasmExports[\"emscripten_stack_get_end\"] = makeWrapper_p(\\n        wasmExports[\"emscripten_stack_get_end\"],\\n      );\\n      wasmExports[\"_emscripten_stack_restore\"] = makeWrapper__p(\\n        wasmExports[\"_emscripten_stack_restore\"],\\n      );\\n      wasmExports[\"_emscripten_stack_alloc\"] = makeWrapper_pp(\\n        wasmExports[\"_emscripten_stack_alloc\"],\\n      );\\n      wasmExports[\"emscripten_stack_get_current\"] = makeWrapper_p(\\n        wasmExports[\"emscripten_stack_get_current\"],\\n      );\\n      wasmExports[\"__cxa_increment_exception_refcount\"] = makeWrapper__p(\\n        wasmExports[\"__cxa_increment_exception_refcount\"],\\n      );\\n      wasmExports[\"dynCall_jj\"] = makeWrapper__p_(wasmExports[\"dynCall_jj\"]);\\n      wasmExports[\"dynCall_jjjj\"] = makeWrapper__p___(\\n        wasmExports[\"dynCall_jjjj\"],\\n      );\\n      wasmExports[\"dynCall_vjj\"] = makeWrapper__p__(wasmExports[\"dynCall_vjj\"]);\\n      wasmExports[\"dynCall_ijjj\"] = makeWrapper__p___(\\n        wasmExports[\"dynCall_ijjj\"],\\n      );\\n      wasmExports[\"dynCall_ijii\"] = makeWrapper__p___(\\n        wasmExports[\"dynCall_ijii\"],\\n      );\\n      wasmExports[\"dynCall_ij\"] = makeWrapper__p_(wasmExports[\"dynCall_ij\"]);\\n      wasmExports[\"dynCall_jjii\"] = makeWrapper__p___(\\n        wasmExports[\"dynCall_jjii\"],\\n      );\\n      wasmExports[\"dynCall_jjji\"] = makeWrapper__p___(\\n        wasmExports[\"dynCall_jjji\"],\\n      );\\n      wasmExports[\"dynCall_ijdiiii\"] = makeWrapper__p______(\\n        wasmExports[\"dynCall_ijdiiii\"],\\n      );\\n      wasmExports[\"dynCall_v\"] = makeWrapper__p(wasmExports[\"dynCall_v\"]);\\n      wasmExports[\"dynCall_vi\"] = makeWrapper__p_(wasmExports[\"dynCall_vi\"]);\\n      wasmExports[\"asyncify_start_unwind\"] = makeWrapper__p(\\n        wasmExports[\"asyncify_start_unwind\"],\\n      );\\n      wasmExports[\"asyncify_start_rewind\"] = makeWrapper__p(\\n        wasmExports[\"asyncify_start_rewind\"],\\n      );\\n      return wasmExports;\\n    }\\n    Module[\"run\"] = run;\\n    Module[\"callMain\"] = callMain;\\n    Module[\"ccall\"] = ccall;\\n    Module[\"stringToUTF8\"] = stringToUTF8;\\n    Module[\"lengthBytesUTF8\"] = lengthBytesUTF8;\\n    var missingLibrarySymbols = [\\n      \"writeI53ToI64\",\\n      \"writeI53ToI64Clamped\",\\n      \"writeI53ToI64Signaling\",\\n      \"writeI53ToU64Clamped\",\\n      \"writeI53ToU64Signaling\",\\n      \"readI53FromI64\",\\n      \"readI53FromU64\",\\n      \"convertI32PairToI53\",\\n      \"convertI32PairToI53Checked\",\\n      \"convertU32PairToI53\",\\n      \"getTempRet0\",\\n      \"setTempRet0\",\\n      \"inetPton4\",\\n      \"inetNtop4\",\\n      \"inetPton6\",\\n      \"inetNtop6\",\\n      \"readSockaddr\",\\n      \"writeSockaddr\",\\n      \"emscriptenLog\",\\n      \"readEmAsmArgs\",\\n      \"jstoi_q\",\\n      \"getExecutableName\",\\n      \"listenOnce\",\\n      \"autoResumeAudioContext\",\\n      \"dynCallLegacy\",\\n      \"getDynCaller\",\\n      \"dynCall\",\\n      \"asmjsMangle\",\\n      \"HandleAllocator\",\\n      \"getNativeTypeSize\",\\n      \"addOnInit\",\\n      \"addOnPostCtor\",\\n      \"addOnPreMain\",\\n      \"addOnExit\",\\n      \"STACK_SIZE\",\\n      \"STACK_ALIGN\",\\n      \"POINTER_SIZE\",\\n      \"ASSERTIONS\",\\n      \"cwrap\",\\n      \"uleb128Encode\",\\n      \"generateFuncType\",\\n      \"convertJsFunctionToWasm\",\\n      \"getEmptyTableSlot\",\\n      \"updateTableMap\",\\n      \"getFunctionAddress\",\\n      \"addFunction\",\\n      \"removeFunction\",\\n      \"reallyNegative\",\\n      \"unSign\",\\n      \"strLen\",\\n      \"reSign\",\\n      \"formatString\",\\n      \"intArrayToString\",\\n      \"AsciiToString\",\\n      \"stringToAscii\",\\n      \"UTF16ToString\",\\n      \"stringToUTF16\",\\n      \"lengthBytesUTF16\",\\n      \"UTF32ToString\",\\n      \"stringToUTF32\",\\n      \"lengthBytesUTF32\",\\n      \"stringToNewUTF8\",\\n      \"registerKeyEventCallback\",\\n      \"maybeCStringToJsString\",\\n      \"findEventTarget\",\\n      \"getBoundingClientRect\",\\n      \"fillMouseEventData\",\\n      \"registerMouseEventCallback\",\\n      \"registerWheelEventCallback\",\\n      \"registerUiEventCallback\",\\n      \"registerFocusEventCallback\",\\n      \"fillDeviceOrientationEventData\",\\n      \"registerDeviceOrientationEventCallback\",\\n      \"fillDeviceMotionEventData\",\\n      \"registerDeviceMotionEventCallback\",\\n      \"screenOrientation\",\\n      \"fillOrientationChangeEventData\",\\n      \"registerOrientationChangeEventCallback\",\\n      \"fillFullscreenChangeEventData\",\\n      \"registerFullscreenChangeEventCallback\",\\n      \"JSEvents_requestFullscreen\",\\n      \"JSEvents_resizeCanvasForFullscreen\",\\n      \"registerRestoreOldStyle\",\\n      \"hideEverythingExceptGivenElement\",\\n      \"restoreHiddenElements\",\\n      \"setLetterbox\",\\n      \"softFullscreenResizeWebGLRenderTarget\",\\n      \"doRequestFullscreen\",\\n      \"fillPointerlockChangeEventData\",\\n      \"registerPointerlockChangeEventCallback\",\\n      \"registerPointerlockErrorEventCallback\",\\n      \"requestPointerLock\",\\n      \"fillVisibilityChangeEventData\",\\n      \"registerVisibilityChangeEventCallback\",\\n      \"registerTouchEventCallback\",\\n      \"fillGamepadEventData\",\\n      \"registerGamepadEventCallback\",\\n      \"registerBeforeUnloadEventCallback\",\\n      \"fillBatteryEventData\",\\n      \"battery\",\\n      \"registerBatteryEventCallback\",\\n      \"setCanvasElementSize\",\\n      \"getCanvasElementSize\",\\n      \"jsStackTrace\",\\n      \"getCallstack\",\\n      \"convertPCtoSourceLocation\",\\n      \"getEnvStrings\",\\n      \"checkWasiClock\",\\n      \"wasiRightsToMuslOFlags\",\\n      \"wasiOFlagsToMuslOFlags\",\\n      \"setImmediateWrapped\",\\n      \"safeRequestAnimationFrame\",\\n      \"clearImmediateWrapped\",\\n      \"registerPostMainLoop\",\\n      \"registerPreMainLoop\",\\n      \"getPromise\",\\n      \"makePromise\",\\n      \"idsToPromises\",\\n      \"makePromiseCallback\",\\n      \"ExceptionInfo\",\\n      \"findMatchingCatch\",\\n      \"Browser_asyncPrepareDataCounter\",\\n      \"isLeapYear\",\\n      \"ydayFromDate\",\\n      \"arraySum\",\\n      \"addDays\",\\n      \"getSocketFromFD\",\\n      \"getSocketAddress\",\\n      \"FS_unlink\",\\n      \"FS_mkdirTree\",\\n      \"_setNetworkCallback\",\\n      \"heapObjectForWebGLType\",\\n      \"toTypedArrayIndex\",\\n      \"webgl_enable_ANGLE_instanced_arrays\",\\n      \"webgl_enable_OES_vertex_array_object\",\\n      \"webgl_enable_WEBGL_draw_buffers\",\\n      \"webgl_enable_WEBGL_multi_draw\",\\n      \"webgl_enable_EXT_polygon_offset_clamp\",\\n      \"webgl_enable_EXT_clip_control\",\\n      \"webgl_enable_WEBGL_polygon_mode\",\\n      \"emscriptenWebGLGet\",\\n      \"computeUnpackAlignedImageSize\",\\n      \"colorChannelsInGlTextureFormat\",\\n      \"emscriptenWebGLGetTexPixelData\",\\n      \"emscriptenWebGLGetUniform\",\\n      \"webglGetUniformLocation\",\\n      \"webglPrepareUniformLocationsBeforeFirstUse\",\\n      \"webglGetLeftBracePos\",\\n      \"emscriptenWebGLGetVertexAttrib\",\\n      \"__glGetActiveAttribOrUniform\",\\n      \"writeGLArray\",\\n      \"registerWebGlEventCallback\",\\n      \"ALLOC_NORMAL\",\\n      \"ALLOC_STACK\",\\n      \"allocate\",\\n      \"writeStringToMemory\",\\n      \"writeAsciiToMemory\",\\n      \"setErrNo\",\\n      \"demangle\",\\n      \"stackTrace\",\\n    ];\\n    missingLibrarySymbols.forEach(missingLibrarySymbol);\\n    var unexportedSymbols = [\\n      \"addRunDependency\",\\n      \"removeRunDependency\",\\n      \"out\",\\n      \"err\",\\n      \"abort\",\\n      \"wasmMemory\",\\n      \"wasmExports\",\\n      \"writeStackCookie\",\\n      \"checkStackCookie\",\\n      \"INT53_MAX\",\\n      \"INT53_MIN\",\\n      \"bigintToI53Checked\",\\n      \"stackSave\",\\n      \"stackRestore\",\\n      \"stackAlloc\",\\n      \"ptrToString\",\\n      \"zeroMemory\",\\n      \"exitJS\",\\n      \"getHeapMax\",\\n      \"growMemory\",\\n      \"ENV\",\\n      \"ERRNO_CODES\",\\n      \"strError\",\\n      \"DNS\",\\n      \"Protocols\",\\n      \"Sockets\",\\n      \"timers\",\\n      \"warnOnce\",\\n      \"readEmAsmArgsArray\",\\n      \"jstoi_s\",\\n      \"handleException\",\\n      \"keepRuntimeAlive\",\\n      \"runtimeKeepalivePush\",\\n      \"runtimeKeepalivePop\",\\n      \"callUserCallback\",\\n      \"maybeExit\",\\n      \"asyncLoad\",\\n      \"alignMemory\",\\n      \"mmapAlloc\",\\n      \"wasmTable\",\\n      \"noExitRuntime\",\\n      \"addOnPreRun\",\\n      \"addOnPostRun\",\\n      \"getCFunc\",\\n      \"sigToWasmTypes\",\\n      \"freeTableIndexes\",\\n      \"functionsInTableMap\",\\n      \"setValue\",\\n      \"getValue\",\\n      \"PATH\",\\n      \"PATH_FS\",\\n      \"UTF8Decoder\",\\n      \"UTF8ArrayToString\",\\n      \"UTF8ToString\",\\n      \"stringToUTF8Array\",\\n      \"intArrayFromString\",\\n      \"UTF16Decoder\",\\n      \"stringToUTF8OnStack\",\\n      \"writeArrayToMemory\",\\n      \"JSEvents\",\\n      \"specialHTMLTargets\",\\n      \"findCanvasEventTarget\",\\n      \"currentFullscreenStrategy\",\\n      \"restoreOldWindowedStyle\",\\n      \"UNWIND_CACHE\",\\n      \"ExitStatus\",\\n      \"doReadv\",\\n      \"doWritev\",\\n      \"initRandomFill\",\\n      \"randomFill\",\\n      \"safeSetTimeout\",\\n      \"emSetImmediate\",\\n      \"emClearImmediate_deps\",\\n      \"emClearImmediate\",\\n      \"promiseMap\",\\n      \"uncaughtExceptionCount\",\\n      \"exceptionLast\",\\n      \"exceptionCaught\",\\n      \"Browser\",\\n      \"getPreloadedImageData__data\",\\n      \"wget\",\\n      \"MONTH_DAYS_REGULAR\",\\n      \"MONTH_DAYS_LEAP\",\\n      \"MONTH_DAYS_REGULAR_CUMULATIVE\",\\n      \"MONTH_DAYS_LEAP_CUMULATIVE\",\\n      \"SYSCALLS\",\\n      \"preloadPlugins\",\\n      \"FS_createPreloadedFile\",\\n      \"FS_modeStringToFlags\",\\n      \"FS_getMode\",\\n      \"FS_stdin_getChar_buffer\",\\n      \"FS_stdin_getChar\",\\n      \"FS_createPath\",\\n      \"FS_createDevice\",\\n      \"FS_readFile\",\\n      \"FS\",\\n      \"FS_createDataFile\",\\n      \"FS_createLazyFile\",\\n      \"MEMFS\",\\n      \"TTY\",\\n      \"PIPEFS\",\\n      \"SOCKFS\",\\n      \"tempFixedLengthArray\",\\n      \"miniTempWebGLFloatBuffers\",\\n      \"miniTempWebGLIntBuffers\",\\n      \"GL\",\\n      \"AL\",\\n      \"GLUT\",\\n      \"EGL\",\\n      \"GLEW\",\\n      \"IDBStore\",\\n      \"runAndAbortIfError\",\\n      \"Asyncify\",\\n      \"Fibers\",\\n      \"SDL\",\\n      \"SDL_gfx\",\\n      \"allocateUTF8\",\\n      \"allocateUTF8OnStack\",\\n      \"print\",\\n      \"printErr\",\\n    ];\\n    unexportedSymbols.forEach(unexportedRuntimeSymbol);\\n    var calledRun;\\n    function callMain(args = []) {\\n      assert(\\n        runDependencies == 0,\\n        \\'cannot call main when async dependencies remain! (listen on Module[\"onRuntimeInitialized\"])\\',\\n      );\\n      assert(\\n        typeof onPreRuns === \"undefined\" || onPreRuns.length == 0,\\n        \"cannot call main when preRun functions remain to be called\",\\n      );\\n      var entryFunction = _main;\\n      args.unshift(thisProgram);\\n      var argc = args.length;\\n      var argv = stackAlloc((argc + 1) * 8);\\n      var argv_ptr = argv;\\n      args.forEach((arg) => {\\n        HEAPU64[argv_ptr / 8] = BigInt(stringToUTF8OnStack(arg));\\n        argv_ptr += 8;\\n      });\\n      HEAPU64[argv_ptr / 8] = BigInt(0);\\n      try {\\n        var ret = entryFunction(argc, BigInt(argv));\\n        exitJS(ret, true);\\n        return ret;\\n      } catch (e) {\\n        return handleException(e);\\n      }\\n    }\\n    function stackCheckInit() {\\n      _emscripten_stack_init();\\n      writeStackCookie();\\n    }\\n    function run(args = arguments_) {\\n      if (runDependencies > 0) {\\n        // dependenciesFulfilled = run;\\n        return;\\n      }\\n      stackCheckInit();\\n      preRun();\\n      if (runDependencies > 0) {\\n        // dependenciesFulfilled = run;\\n        return;\\n      }\\n      function doRun() {\\n        assert(!calledRun);\\n        calledRun = true;\\n        Module[\"calledRun\"] = true;\\n        if (ABORT) return;\\n        initRuntime();\\n        FS.writeFile(\"output.elf\", args[0]);\\n        args.shift();\\n        preMain();\\n        readyPromiseResolve(Module);\\n        Module[\"onRuntimeInitialized\"]?.();\\n        var noInitialRun = Module[\"noInitialRun\"];\\n        legacyModuleProp(\"noInitialRun\", \"noInitialRun\");\\n        callMain(args);\\n        postRun();\\n      }\\n      if (Module[\"setStatus\"]) {\\n        Module[\"setStatus\"](\"Running...\");\\n        setTimeout(() => {\\n          setTimeout(() => Module[\"setStatus\"](\"\"), 1);\\n          doRun();\\n        }, 1);\\n      } else {\\n        doRun();\\n      }\\n      checkStackCookie();\\n    }\\n    function checkUnflushedContent() {\\n      var oldOut = out;\\n      var oldErr = err;\\n      var has = false;\\n      out = err = (x) => {\\n        has = true;\\n      };\\n      try {\\n        _fflush(0);\\n        [\"stdout\", \"stderr\"].forEach((name) => {\\n          var info = FS.analyzePath(\"/dev/\" + name);\\n          if (!info) return;\\n          var stream = info.object;\\n          var rdev = stream.rdev;\\n          var tty = TTY.ttys[rdev];\\n          if (tty?.output?.length) {\\n            has = true;\\n          }\\n        });\\n      } catch (e) {}\\n      out = oldOut;\\n      err = oldErr;\\n      if (has) {\\n        warnOnce(\\n          \"stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.\",\\n        );\\n      }\\n    }\\n    if (Module[\"preInit\"]) {\\n      if (typeof Module[\"preInit\"] == \"function\")\\n        Module[\"preInit\"] = [Module[\"preInit\"]];\\n      while (Module[\"preInit\"].length > 0) {\\n        Module[\"preInit\"].pop()();\\n      }\\n    }\\n    // run();\\n    moduleRtn = readyPromise;\\n    for (const prop of Object.keys(Module)) {\\n      if (!(prop in moduleArg)) {\\n        Object.defineProperty(moduleArg, prop, {\\n          configurable: true,\\n          get() {\\n            abort(\\n              `Access to module property (\\'${prop}\\') is no longer possible via the module constructor argument; Instead, use the result of the module constructor.`,\\n            );\\n          },\\n        });\\n      }\\n    }\\n    readyPromiseResolve(Module);\\n    return moduleRtn;\\n  };\\n})();\\n(() => {\\n  // Create a small, never-async wrapper around Module which\\n  // checks for callers incorrectly using it with `new`.\\n  var real_Module = Module;\\n  Module = function (arg) {\\n    if (new.target)\\n      throw new Error(\"Module() should not be called with `new Module()`\");\\n    return real_Module(arg);\\n  };\\n})();\\nexport default Module;\\n';\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJmcyIsInJlcXVpcmUiLCJwYXRoIiwibW9kdWxlIiwiZXhwb3J0cyIsInRyYW5zZm9ybWVyIiwiZmlsZSIsImFwaSIsInNvdXJjZSIsImFuY2hvcnMiLCJpc0V4cGVjdGVkSW5wdXQiLCJldmVyeSIsImEiLCJpbmNsdWRlcyIsImRlc2lyZWRQYXRoIiwiam9pbiIsInByb2Nlc3MiLCJjd2QiLCJleGlzdHNTeW5jIiwicmVhZEZpbGVTeW5jIiwiREVTSVJFRF9DT05URU5UIl0sInNvdXJjZVJvb3QiOiIvaG9tZS9qdWFuY2FybG9zL0VzY3JpdG9yaW8vcHJ1ZWJhL2NyZWF0b3Itc2FpbC1leGVjdXRvci9jX2VtdWxhdG9yLyIsInNvdXJjZXMiOlsidHJhbnNmb3JtNjQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiB0cmFuc2Zvcm0uanMgKGpzY29kZXNoaWZ0KVxuICpcbiAqIEV4YWN0IGNvZGVtb2Q6IGNvbnZlcnRzIHRoZSBzcGVjaWZpYyBwcm92aWRlZCBvcmlnaW5hbC5qcyBpbnRvIHRoZSBzcGVjaWZpYyBwcm92aWRlZCBkZXNlYWRvLmpzLlxuICogRm9yIHNhZmV0eSwgaXQgY2hlY2tzIGEgZmV3IGFuY2hvciBzdHJpbmdzOyBpZiB0aGV5IGRvbid0IG1hdGNoLCBpdCBsZWF2ZXMgdGhlIGZpbGUgdW5jaGFuZ2VkLlxuICpcbiAqIFVzYWdlOlxuICogICAjIE9wdGlvbiBBOiBydW4gd2l0aCBlbWJlZGRlZCBkZXNpcmVkIGNvbnRlbnQgKG5vIGV4dHJhIGZpbGVzIG5lZWRlZClcbiAqICAgbnB4IGpzY29kZXNoaWZ0IC10IHRyYW5zZm9ybS5qcyBvcmlnaW5hbC5qc1xuICpcbiAqICAgIyBPcHRpb24gQjogaWYgeW91IHByZWZlciBub3QgdG8gZW1iZWQsIGtlZXAgYSBkZXNlYWRvLmpzIG5leHQgdG8gd2hlcmUgeW91IHJ1biB0aGUgY29tbWFuZDpcbiAqICAgY3AgZGVzZWFkby5qcyAvcGF0aC93aGVyZS95b3UvcnVuL1xuICogICBucHgganNjb2Rlc2hpZnQgLXQgdHJhbnNmb3JtLmpzIG9yaWdpbmFsLmpzXG4gKi9cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtZXIoZmlsZSwgYXBpKSB7XG4gIGNvbnN0IHNvdXJjZSA9IGZpbGUuc291cmNlO1xuXG4gIC8vIEFuY2hvcnMgdG8gY29uZmlybSB3ZSdyZSBsb29raW5nIGF0IHRoZSBleHBlY3RlZCBpbnB1dCBmaWxlLlxuICBjb25zdCBhbmNob3JzID0gW1xuICAgICd2YXIgTW9kdWxlID0gKCgpID0+IHsnLFxuICAgICdyZXR1cm4gYXN5bmMgZnVuY3Rpb24gKG1vZHVsZUFyZyA9IHt9KSB7JyxcbiAgICAndmFyIHJlYWR5UHJvbWlzZVJlc29sdmUsIHJlYWR5UHJvbWlzZVJlamVjdDsnXG4gIF07XG5cbiAgY29uc3QgaXNFeHBlY3RlZElucHV0ID0gYW5jaG9ycy5ldmVyeSgoYSkgPT4gc291cmNlLmluY2x1ZGVzKGEpKTtcbiAgaWYgKCFpc0V4cGVjdGVkSW5wdXQpIHJldHVybiBzb3VyY2U7XG5cbiAgLy8gSWYgYSBkZXNlYWRvLmpzIGV4aXN0cyBpbiB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeSwgcHJlZmVyIGl0LlxuICBjb25zdCBkZXNpcmVkUGF0aCA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnZGVzZWFkby5qcycpO1xuICBpZiAoZnMuZXhpc3RzU3luYyhkZXNpcmVkUGF0aCkpIHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKGRlc2lyZWRQYXRoLCAndXRmOCcpO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlIGZhbGwgYmFjayB0byB0aGUgZW1iZWRkZWQgY29udGVudC5cbiAgcmV0dXJuIERFU0lSRURfQ09OVEVOVDtcbn07XG5cbmNvbnN0IERFU0lSRURfQ09OVEVOVCA9ICdpbXBvcnQgeyBpbnN0cnVjdGlvbnMgfSBmcm9tIFwiQC9jb3JlL2Fzc2VtYmxlci9hc3NlbWJsZXIubWpzXCI7XFxuaW1wb3J0IHsgcmVhZFJlZ2lzdGVyLCB3cml0ZVJlZ2lzdGVyLCBub3RpZnlSZWdpc3RlclVwZGF0ZSB9IGZyb20gXCJAL2NvcmUvcmVnaXN0ZXIvcmVnaXN0ZXJPcGVyYXRpb25zLm1qc1wiO1xcbmltcG9ydCB7IGNyZXhfZmluZFJlZ19ieXRhZywgY3JleF9maW5kUmVnIH0gZnJvbSBcIkAvY29yZS9yZWdpc3Rlci9yZWdpc3Rlckxvb2t1cC5tanNcIlxcbmltcG9ydCB7IHN0YXR1cywgUENfUkVHX0lOREVYLCBSRUdJU1RFUlMsIGdldFBDLCBtYWluX21lbW9yeSwgY29uZmlnX2NhY2hlLCBMMV9jYWNoZV9tZW1vcnksIEwxX0lfY2FjaGVfbWVtb3J5LCBMMV9EX2NhY2hlX21lbW9yeSwgTDJfRF9jYWNoZV9tZW1vcnksIEwyX0lfY2FjaGVfbWVtb3J5LCBMMl9jYWNoZV9tZW1vcnksIHVwZGF0ZUNhY2hlTWVtICB9IGZyb20gXCJAL2NvcmUvY29yZS5tanNcIjtcXG5pbXBvcnQgeyBzZXRJbnN0cnVjdGlvbnMgfSBmcm9tIFwiQC9jb3JlL2Fzc2VtYmxlci9hc3NlbWJsZXIubWpzXCI7XFxuaW1wb3J0IHsgZGlzcGxheV9wcmludCB9IGZyb20gXCIuLi8uLi9JTy5tanNcIjtcXG5pbXBvcnQgeyBTWVNDQUxMIH0gZnJvbSBcIkAvY29yZS9jYXBpL3N5c2NhbGwubXRzXCI7XFxuaW1wb3J0IHsgY29yZUV2ZW50cyB9IGZyb20gXCJAL2NvcmUvZXZlbnRzLm10c1wiO1xcbmltcG9ydCB7IHNob3dfbm90aWZpY2F0aW9uIH0gZnJvbSBcIkAvd2ViL3V0aWxzLm1qc1wiO1xcbmltcG9ydCB7IHJlc2V0X2Rpc2FibGUsIGluc3RydWN0aW9uX2Rpc2FibGUsIHJ1bl9kaXNhYmxlLCBzdG9wX2Rpc2FibGUsIGlzRmluaXNoZWQgfSBmcm9tIFwiQC93ZWIvdXRpbHMubWpzXCI7XFxuaW1wb3J0IHsgYXJjaGl0ZWN0dXJlIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUubWpzXCI7XFxuaW1wb3J0IHsgY2xlYXJBbGxSZWdpc3Rlckdsb3dzIH0gZnJvbSBcIkAvY29yZS9yZWdpc3Rlci9yZWdpc3Rlckdsb3dTdGF0ZS5tanNcIjtcXG5cXG5leHBvcnQgdmFyIHVzZXJNb2RlNjQgPSBmYWxzZTtcXG5cXG52YXIgTW9kdWxlID0gKCgpID0+IHtcXG4gIHZhciBfc2NyaXB0TmFtZSA9IGltcG9ydC5tZXRhLnVybDtcXG4gIHZhciBpbnNuX251bWJlcjtcXG5cXG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiAobW9kdWxlQXJnID0ge30pIHtcXG4gICAgZG9jdW1lbnQuYXBwLiRkYXRhLmlzX2JyZWFrcG9pbnQgPSBpbnN0cnVjdGlvbnNbMF0uQnJlYWs7XFxuICAgIHZhciBwY19zYWlsID0gY3JleF9maW5kUmVnX2J5dGFnKFwicHJvZ3JhbV9jb3VudGVyXCIpO1xcbiAgICB2YXIgcGNfbWluID0gYXJjaGl0ZWN0dXJlLm1lbW9yeV9sYXlvdXQudGV4dC5zdGFydDtcXG4gICAgdmFyIHBjX21heCA9IGFyY2hpdGVjdHVyZS5tZW1vcnlfbGF5b3V0LnRleHQuZW5kO1xcbiAgICB2YXIgaGlkZW5fZXhlY3V0ZWQsIGhpZGVuX25leHRfZXhlY3V0ZTtcXG5cXG4gICAgdmFyIHJlZ2lzdGVyc19iZWZvcmVfZnVuY3Rpb24gPSBbIFxcbiAgICAgIHsgbmFtZTogXCJ0MFwiLCBjYW5fb3BlcmF0ZSA6IGZhbHNlfSxcXG4gICAgICB7IG5hbWU6IFwidDFcIiwgY2FuX29wZXJhdGUgOiBmYWxzZX0sXFxuICAgICAgeyBuYW1lOiBcInQyXCIsIGNhbl9vcGVyYXRlIDogZmFsc2V9LFxcbiAgICAgIHsgbmFtZTogXCJ0M1wiLCBjYW5fb3BlcmF0ZSA6IGZhbHNlfSxcXG4gICAgICB7IG5hbWU6IFwidDRcIiwgY2FuX29wZXJhdGUgOiBmYWxzZX0sIFxcbiAgICAgIHsgbmFtZTogXCJ0NVwiLCBjYW5fb3BlcmF0ZSA6IGZhbHNlfSxcXG4gICAgICB7IG5hbWU6IFwidDZcIiwgY2FuX29wZXJhdGUgOiBmYWxzZX0sXFxuICAgICAgeyBuYW1lOiBcInMwXCIsIGNhbl9vcGVyYXRlIDogZmFsc2V9LFxcbiAgICAgIHsgbmFtZTogXCJzMVwiLCBjYW5fb3BlcmF0ZSA6IGZhbHNlfSxcXG4gICAgICB7IG5hbWU6IFwiczJcIiwgY2FuX29wZXJhdGUgOiBmYWxzZX0sXFxuICAgICAgeyBuYW1lOiBcInMzXCIsIGNhbl9vcGVyYXRlIDogZmFsc2V9LFxcbiAgICAgIHsgbmFtZTogXCJzNFwiLCBjYW5fb3BlcmF0ZSA6IGZhbHNlfSwgXFxuICAgICAgeyBuYW1lOiBcInM1XCIsIGNhbl9vcGVyYXRlIDogZmFsc2V9LFxcbiAgICAgIHsgbmFtZTogXCJzNlwiLCBjYW5fb3BlcmF0ZSA6IGZhbHNlfSxcXG4gICAgICB7IG5hbWU6IFwiczdcIiwgY2FuX29wZXJhdGUgOiBmYWxzZX0sXFxuICAgICAgeyBuYW1lOiBcInM4XCIsIGNhbl9vcGVyYXRlIDogZmFsc2V9LFxcbiAgICAgIHsgbmFtZTogXCJzOVwiLCBjYW5fb3BlcmF0ZSA6IGZhbHNlfSxcXG4gICAgICB7IG5hbWU6IFwiczEwXCIsIGNhbl9vcGVyYXRlIDogZmFsc2V9LCBcXG4gICAgICB7IG5hbWU6IFwiczExXCIsIGNhbl9vcGVyYXRlIDogZmFsc2V9XFxuICAgIF1cXG4gICAgdmFyIGNhbGxzdGFja19jb252ZW50aW9uID0gW107XFxuICAgIHZhciBpbnNpZGVfZnVuY3Rpb24gPSBmYWxzZTtcXG4gICAgTW9kdWxlID0gTW9kdWxlIHx8IHt9O1xcbiAgICB2YXIgbW9kdWxlUnRuO1xcblxcbiAgICB2YXIgTW9kdWxlID0gbW9kdWxlQXJnO1xcbiAgICB2YXIgcmVhZHlQcm9taXNlUmVzb2x2ZSwgcmVhZHlQcm9taXNlUmVqZWN0O1xcbiAgICB2YXIgcmVhZHlQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xcbiAgICAgIHJlYWR5UHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xcbiAgICAgIHJlYWR5UHJvbWlzZVJlamVjdCA9IHJlamVjdDtcXG4gICAgfSk7XFxuICAgIHZhciBFTlZJUk9OTUVOVF9JU19XRUIgPSB0cnVlO1xcbiAgICB2YXIgRU5WSVJPTk1FTlRfSVNfV09SS0VSID0gZmFsc2U7XFxuICAgIHZhciBFTlZJUk9OTUVOVF9JU19OT0RFID0gZmFsc2U7XFxuICAgIHZhciBFTlZJUk9OTUVOVF9JU19TSEVMTCA9IGZhbHNlO1xcbiAgICB2YXIgbW9kdWxlT3ZlcnJpZGVzID0gT2JqZWN0LmFzc2lnbih7fSwgTW9kdWxlKTtcXG4gICAgdmFyIGFyZ3VtZW50c18gPSBbXTtcXG4gICAgdmFyIHRoaXNQcm9ncmFtID0gXCIuL3RoaXMucHJvZ3JhbVwiO1xcbiAgICB2YXIgcXVpdF8gPSAoc3RhdHVzLCB0b1Rocm93KSA9PiB7XFxuICAgICAgdGhyb3cgdG9UaHJvdztcXG4gICAgfTtcXG4gICAgdmFyIHNjcmlwdERpcmVjdG9yeSA9IFwiXCI7XFxuICAgIGZ1bmN0aW9uIGxvY2F0ZUZpbGUocGF0aCkge1xcbiAgICAgIGlmIChNb2R1bGVbXCJsb2NhdGVGaWxlXCJdKSB7XFxuICAgICAgICByZXR1cm4gTW9kdWxlW1wibG9jYXRlRmlsZVwiXShwYXRoLCBzY3JpcHREaXJlY3RvcnkpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gc2NyaXB0RGlyZWN0b3J5ICsgcGF0aDtcXG4gICAgfVxcbiAgICB2YXIgcmVhZEFzeW5jLCByZWFkQmluYXJ5O1xcbiAgICBpZiAoRU5WSVJPTk1FTlRfSVNfU0hFTEwpIHtcXG4gICAgICBpZiAoXFxuICAgICAgICAodHlwZW9mIHByb2Nlc3MgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiKSB8fFxcbiAgICAgICAgdHlwZW9mIHdpbmRvdyA9PSBcIm9iamVjdFwiIHx8XFxuICAgICAgICB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT0gXCJ1bmRlZmluZWRcIlxcbiAgICAgIClcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXG4gICAgICAgICAgXCJub3QgY29tcGlsZWQgZm9yIHRoaXMgZW52aXJvbm1lbnQgKGRpZCB5b3UgYnVpbGQgdG8gSFRNTCBhbmQgdHJ5IHRvIHJ1biBpdCBub3Qgb24gdGhlIHdlYiwgb3Igc2V0IEVOVklST05NRU5UIHRvIHNvbWV0aGluZyAtIGxpa2Ugbm9kZSAtIGFuZCBydW4gaXQgc29tZXBsYWNlIGVsc2UgLSBsaWtlIG9uIHRoZSB3ZWI/KVwiLFxcbiAgICAgICAgKTtcXG4gICAgfSBlbHNlIGlmIChFTlZJUk9OTUVOVF9JU19XRUIgfHwgRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XFxuICAgICAgaWYgKEVOVklST05NRU5UX0lTX1dPUktFUikge1xcbiAgICAgICAgc2NyaXB0RGlyZWN0b3J5ID0gc2VsZi5sb2NhdGlvbi5ocmVmO1xcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdCkge1xcbiAgICAgICAgc2NyaXB0RGlyZWN0b3J5ID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM7XFxuICAgICAgfVxcbiAgICAgIGlmIChfc2NyaXB0TmFtZSkge1xcbiAgICAgICAgc2NyaXB0RGlyZWN0b3J5ID0gX3NjcmlwdE5hbWU7XFxuICAgICAgfVxcbiAgICAgIGlmIChzY3JpcHREaXJlY3Rvcnkuc3RhcnRzV2l0aChcImJsb2I6XCIpKSB7XFxuICAgICAgICBzY3JpcHREaXJlY3RvcnkgPSBcIlwiO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzY3JpcHREaXJlY3RvcnkgPSBzY3JpcHREaXJlY3Rvcnkuc2xpY2UoXFxuICAgICAgICAgIDAsXFxuICAgICAgICAgIHNjcmlwdERpcmVjdG9yeS5yZXBsYWNlKC9bPyNdLiovLCBcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikgKyAxLFxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuICAgICAgaWYgKFxcbiAgICAgICAgISh0eXBlb2Ygd2luZG93ID09IFwib2JqZWN0XCIgfHwgdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9IFwidW5kZWZpbmVkXCIpXFxuICAgICAgKVxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcbiAgICAgICAgICBcIm5vdCBjb21waWxlZCBmb3IgdGhpcyBlbnZpcm9ubWVudCAoZGlkIHlvdSBidWlsZCB0byBIVE1MIGFuZCB0cnkgdG8gcnVuIGl0IG5vdCBvbiB0aGUgd2ViLCBvciBzZXQgRU5WSVJPTk1FTlQgdG8gc29tZXRoaW5nIC0gbGlrZSBub2RlIC0gYW5kIHJ1biBpdCBzb21lcGxhY2UgZWxzZSAtIGxpa2Ugb24gdGhlIHdlYj8pXCIsXFxuICAgICAgICApO1xcbiAgICAgIHtcXG4gICAgICAgIHJlYWRBc3luYyA9IGFzeW5jICh1cmwpID0+IHtcXG4gICAgICAgICAgYXNzZXJ0KCFpc0ZpbGVVUkkodXJsKSwgXCJyZWFkQXN5bmMgZG9lcyBub3Qgd29yayB3aXRoIGZpbGU6Ly8gVVJMc1wiKTtcXG4gICAgICAgICAgdmFyIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7IGNyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCIgfSk7XFxuICAgICAgICAgIGlmIChyZXNwb25zZS5vaykge1xcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXMgKyBcIiA6IFwiICsgcmVzcG9uc2UudXJsKTtcXG4gICAgICAgIH07XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImVudmlyb25tZW50IGRldGVjdGlvbiBlcnJvclwiKTtcXG4gICAgfVxcblxcblxcbiAgICAvLyBjb25zdCBpbnN0cnVjdGlvbkV4cCA9IC9cXFxcWyhcXFxcZCspXFxcXF0gXFxcXFsoXFxcXHcrKVxcXFxdOiAweChbMC05QS1GYS1mXSspIFxcXFwoMHgoWzAtOUEtRmEtZl0rKVxcXFwpIChcXFxcdyspIChbXixdKyksIChbXixdKykoPzosICguKykpPy87XFxuICAgIHZhciBpbnN0cnVjdGlvbkV4cCA9IC9cXFxcWyhcXFxcZCspXFxcXF0gXFxcXFsoXFxcXHcrKVxcXFxdOiAweChbMC05QS1GYS1mXSspIFxcXFwoMHgoWzAtOUEtRmEtZl0rKVxcXFwpIChbXFxcXHcuXSspKD86IChbXixdKyksIChbXixdKykoPzosICguKykpPyk/LztcXG4gICAgdmFyIHJlZ2lzdGVyRXhwID0gLyhbeGZdXFxcXGQrKSAoPC0pIDB4KFswLTlBLUZhLWZdKykvOyAvLyAvKHhcXFxcZCspICg8LXwtPikgMHgoWzAtOUEtRmEtZl0rKS87XFxuICAgIHZhciB2ZWN0b3JFeHAgPSAvKHZcXFxcZCspICg8LSkgMHgoWzAtOUEtRmEtZl0rKS87XFxuICAgIHZhciBtZW1vcnlFeHAgPSAvbWVtXFxcXFsweChbMC05QS1GYS1mXSspXFxcXF1cXFxccyooPC18LT4pXFxcXHMqMHgoWzAtOUEtRmEtZl0rKS87XFxuICAgIHZhciBDU1JUeXBlRXhwID0gLyhDU1JcXFxcUyopXFxcXHMrKFxcXFxTKylcXFxccysoXFxcXFMrKVxcXFxzKygweCkoW1xcXFxkQS1GYS1mXXsxLDE2fSkvO1xcbiAgICB2YXIgQ1NSRXhwID0gL14oQ1NSKVxcXFxzKyhcXFxcdyspXFxcXHMrKDwtfC0+KVxcXFxzKzB4KFswLTlhLWZBLUZdKykoPzpcXFxccysoLiopKT8kLztcXG4gICAgdmFyIGp1bXBFeHAgPSAvTmV4dF9QQzpcXFxccyoweChbMC05YS1mQS1GXSspLztcXG4gICAgLy8gdmFyIGNhY2hlRXhwID0gL15cXFxcWyhcXFxcZCspXFxcXF1cXFxccysoTDFfSXxMMV9EfEwxfEwyfEwyX0l8TDJfRCk6XFxcXHMqXFxcXCgoMHhbMC05QS1GYS1mXSspXFxcXClcXFxccyQvO1xcbiAgICB2YXIgY2FjaGVFeHAgPSAvXlxcXFxbKFxcXFxkKylcXFxcXVxcXFxzKyhMMV9JfEwxX0R8TDF8TDJ8TDJfSXxMMl9EKTpcXFxccypcXFxcKCgweFswLTlBLUZhLWZdKylcXFxcKVxcXFxzKiQvO1xcbiAgICB2YXIgY29uZmlnQ2FjaGVFeHAgPSAvXkNvbmZpZ3VyYXRpb246XFxcXHMqKFtBLVphLXpfXVtBLVphLXowLTlfXSopXFxcXHMqPC1cXFxccyooXFxcXFMrKVxcXFxzKiQvO1xcbiAgICAvLyB2YXIgZGlzcGxheUV4cCA9IC9eW0EtWmEtelxcXFxzXSs6XFxcXHMqKC4qKSQvO1xcbiAgICAvLyB2YXIgZGlzcGxheUV4cCA9IC9eKFtcXFxcd1xcXFxzXSspOlxcXFxzKiguKikkLzsgICAgIFxcbiAgICB2YXIgZGlzcGxheUV4cCA9IC9eRUNBTExcXFxccysoU0lHTkVEfFVOU0lHTkVEfFNUUklOR3xDSEFSfEZMT0FUfERPVUJMRSk6XFxcXHMqKC4rKSQvOyBcXG4gICAgdmFyIGluc3RvcGVyID0gXCJcIjtcXG4gICAgdmFyIHN5c2NhbGxfcHJpbnRfY29kZSA9IC0xO1xcbiAgICB2YXIgcHJldl9hZGRfdG9fanVtcDtcXG4gICAgLy8gdmFyIHR5cGVfdG9fd3JpdGU7XFxuXFxuXFxuXFxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNhY2hlU3RhdChpbmRleCwgYWNjZXNzLCBkYXRhPVwiXCIpIHtcXG4gICAgICBzd2l0Y2goYWNjZXNzKSB7XFxuICAgICAgICBjYXNlIFwiQ2FjaGUgTDEgaGl0IGluc3RcIjpcXG4gICAgICAgICAgaWYgKGluc3RydWN0aW9uc1tpbmRleF0uTDFfSSA9PSAwKVxcbiAgICAgICAgICAgIGluc3RydWN0aW9uc1tpbmRleF0uTDFfSSA9IDM7XFxuICAgICAgICAgIGVsc2UgaWYgKGluc3RydWN0aW9uc1tpbmRleF0uTDFfSSA9PSAzKVxcbiAgICAgICAgICAgIGluc3RydWN0aW9uc1tpbmRleF0uTDFfSSA9IDM7XFxuICAgICAgICAgIGVsc2UgaWYgKGluc3RydWN0aW9uc1tpbmRleF0uTDFfSSA9PSA0KVxcbiAgICAgICAgICAgIGluc3RydWN0aW9uc1tpbmRleF0uTDFfSSA9IDE7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSBcIkNhY2hlIEwxIG1pc3MgaW5zdFwiOlxcbiAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMV9JID09IDApXFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMV9JID0gNDtcXG4gICAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMV9JID09IDQpXFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMV9JID0gNDtcXG4gICAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMV9JID09IDMpXFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMV9JID0gMTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlIFwiQ2FjaGUgTDEgbWlzc1wiOlxcbiAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMV9JID09IDApXFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMV9JID0gNDtcXG4gICAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMV9JID09IDQpXFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMV9JID0gNDtcXG4gICAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMV9JID09IDMpXFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMV9JID0gMTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlIFwiQ2FjaGUgTDEgaGl0IGRhdGFcIjpcXG4gICAgICAgICAgaWYoZGF0YSAhPT0gXCJcIikge1xcbiAgICAgICAgICAgIGxldCBsYXN0diA9IHBhcnNlSW50KGRhdGFbZGF0YS5sZW5ndGggLSAxXSwgMTYpO1xcbiAgICAgICAgICAgIGlmIChsYXN0diA8IDQpIGRhdGEgPSBkYXRhLnNsaWNlKDAsIC0xKSArIFwiMFwiO1xcbiAgICAgICAgICAgIGVsc2UgaWYgKGxhc3R2IDwgOCkgZGF0YSA9IGRhdGEuc2xpY2UoMCwgLTEpICsgXCI0XCI7XFxuICAgICAgICAgICAgZWxzZSBpZiAobGFzdHYgPCAxMikgZGF0YSA9IGRhdGEuc2xpY2UoMCwgLTEpICsgIFwiOFwiO1xcbiAgICAgICAgICAgIGVsc2UgZGF0YSA9IGRhdGEuc2xpY2UoMCwgLTEpICsgXCJDXCI7XFxuICAgICAgICAgICAgbGV0IG1lbWluZGV4ID0gcGFyc2VJbnQoZGF0YSwgMTYpO1xcbiAgICAgICAgICAgIGlmIChtYWluX21lbW9yeVttZW1pbmRleF0uTDFfRCA9PSAwKVxcbiAgICAgICAgICAgICAgbWFpbl9tZW1vcnlbcGFyc2VJbnQoZGF0YSwgMTYpXS5MMV9EID0gMztcXG4gICAgICAgICAgICBlbHNlIGlmIChtYWluX21lbW9yeVttZW1pbmRleF0uTDFfRCA9PSAzKVxcbiAgICAgICAgICAgICAgbWFpbl9tZW1vcnlbcGFyc2VJbnQoZGF0YSwgMTYpXS5MMV9EID0gMztcXG4gICAgICAgICAgICBlbHNlIGlmIChtYWluX21lbW9yeVttZW1pbmRleF0uTDFfRCA9PSA0KVxcbiAgICAgICAgICAgICAgbWFpbl9tZW1vcnlbcGFyc2VJbnQoZGF0YSwgMTYpXS5MMV9EID0gMTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMV9EID09IDApXFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMV9EID0gMztcXG4gICAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMV9EID09IDMpXFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMV9EID0gMztcXG4gICAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMV9EID09IDQpXFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMV9EID0gMTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlIFwiQ2FjaGUgTDEgbWlzcyBkYXRhXCI6XFxuICAgICAgICAgIGlmKGRhdGEgIT09IFwiXCIpIHtcXG4gICAgICAgICAgICBsZXQgbGFzdHYgPSBwYXJzZUludChkYXRhW2RhdGEubGVuZ3RoIC0gMV0sIDE2KTtcXG4gICAgICAgICAgICBpZiAobGFzdHYgPCA0KSBkYXRhID0gZGF0YS5zbGljZSgwLCAtMSkgKyBcIjBcIjtcXG4gICAgICAgICAgICBlbHNlIGlmIChsYXN0diA8IDgpIGRhdGEgPSBkYXRhLnNsaWNlKDAsIC0xKSArIFwiNFwiO1xcbiAgICAgICAgICAgIGVsc2UgaWYgKGxhc3R2IDwgMTIpIGRhdGEgPSBkYXRhLnNsaWNlKDAsIC0xKSArICBcIjhcIjtcXG4gICAgICAgICAgICBlbHNlIGRhdGEgPSBkYXRhLnNsaWNlKDAsIC0xKSArIFwiQ1wiO1xcbiAgICAgICAgICAgIGxldCBtZW1pbmRleCA9IHBhcnNlSW50KGRhdGEsIDE2KTtcXG4gICAgICAgICAgICBpZiAobWFpbl9tZW1vcnlbbWVtaW5kZXhdLkwxX0QgPT0gMClcXG4gICAgICAgICAgICAgIG1haW5fbWVtb3J5W3BhcnNlSW50KGRhdGEsIDE2KV0uTDFfRCA9IDQ7XFxuICAgICAgICAgICAgZWxzZSBpZiAobWFpbl9tZW1vcnlbbWVtaW5kZXhdLkwxX0QgPT0gNClcXG4gICAgICAgICAgICAgIG1haW5fbWVtb3J5W3BhcnNlSW50KGRhdGEsIDE2KV0uTDFfRCA9IDQ7XFxuICAgICAgICAgICAgZWxzZSBpZiAobWFpbl9tZW1vcnlbbWVtaW5kZXhdLkwxX0QgPT0gMylcXG4gICAgICAgICAgICAgIG1haW5fbWVtb3J5W3BhcnNlSW50KGRhdGEsIDE2KV0uTDFfRCA9IDE7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKGluc3RydWN0aW9uc1tpbmRleF0uTDFfRCA9PSAwKVxcbiAgICAgICAgICAgIGluc3RydWN0aW9uc1tpbmRleF0uTDFfRCA9IDQ7XFxuICAgICAgICAgIGVsc2UgaWYgKGluc3RydWN0aW9uc1tpbmRleF0uTDFfRCA9PSA0KVxcbiAgICAgICAgICAgIGluc3RydWN0aW9uc1tpbmRleF0uTDFfRCA9IDQ7XFxuICAgICAgICAgIGVsc2UgaWYgKGluc3RydWN0aW9uc1tpbmRleF0uTDFfRCA9PSAzKVxcbiAgICAgICAgICAgIGluc3RydWN0aW9uc1tpbmRleF0uTDFfRCA9IDE7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSBcIkNhY2hlIEwxX0kgaGl0XCI6XFxuICAgICAgICAgIGlmIChpbnN0cnVjdGlvbnNbaW5kZXhdLkwxX0kgPT0gMClcXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnNbaW5kZXhdLkwxX0kgPSAzO1xcbiAgICAgICAgICBlbHNlIGlmIChpbnN0cnVjdGlvbnNbaW5kZXhdLkwxX0kgPT0gNClcXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnNbaW5kZXhdLkwxX0kgPSAxO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgXCJDYWNoZSBMMV9JIG1pc3NcIjpcXG4gICAgICAgICAgaWYgKGluc3RydWN0aW9uc1tpbmRleF0uTDFfSSA9PSAwKVxcbiAgICAgICAgICAgIGluc3RydWN0aW9uc1tpbmRleF0uTDFfSSA9IDQ7XFxuICAgICAgICAgIGVsc2UgaWYgKGluc3RydWN0aW9uc1tpbmRleF0uTDFfSSA9PSAzKVxcbiAgICAgICAgICAgIGluc3RydWN0aW9uc1tpbmRleF0uTDFfSSA9IDE7XFxuICAgICAgICAgIGVsc2UgaWYgKGluc3RydWN0aW9uc1tpbmRleF0uTDFfSSA9PSA0KVxcbiAgICAgICAgICAgIGluc3RydWN0aW9uc1tpbmRleF0uTDFfSSA9IDQ7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSBcIkNhY2hlIEwxX0QgaGl0XCI6XFxuICAgICAgICAgIGlmKGRhdGEgIT09IFwiXCIpIHtcXG4gICAgICAgICAgICBsZXQgbGFzdHYgPSBwYXJzZUludChkYXRhW2RhdGEubGVuZ3RoIC0gMV0sIDE2KTtcXG4gICAgICAgICAgICBpZiAobGFzdHYgPCA0KSBkYXRhID0gZGF0YS5zbGljZSgwLCAtMSkgKyBcIjBcIjtcXG4gICAgICAgICAgICBlbHNlIGlmIChsYXN0diA8IDgpIGRhdGEgPSBkYXRhLnNsaWNlKDAsIC0xKSArIFwiNFwiO1xcbiAgICAgICAgICAgIGVsc2UgaWYgKGxhc3R2IDwgMTIpIGRhdGEgPSBkYXRhLnNsaWNlKDAsIC0xKSArICBcIjhcIjtcXG4gICAgICAgICAgICBlbHNlIGRhdGEgPSBkYXRhLnNsaWNlKDAsIC0xKSArIFwiQ1wiO1xcbiAgICAgICAgICAgIGxldCBtZW1pbmRleCA9IHBhcnNlSW50KGRhdGEsIDE2KTtcXG4gICAgICAgICAgICBpZiAobWFpbl9tZW1vcnlbbWVtaW5kZXhdLkwxX0QgPT0gMClcXG4gICAgICAgICAgICAgIG1haW5fbWVtb3J5W3BhcnNlSW50KGRhdGEsIDE2KV0uTDFfRCA9IDM7XFxuICAgICAgICAgICAgZWxzZSBpZiAobWFpbl9tZW1vcnlbbWVtaW5kZXhdLkwxX0QgPT0gMylcXG4gICAgICAgICAgICAgIG1haW5fbWVtb3J5W3BhcnNlSW50KGRhdGEsIDE2KV0uTDFfRCA9IDM7XFxuICAgICAgICAgICAgZWxzZSBpZiAobWFpbl9tZW1vcnlbbWVtaW5kZXhdLkwxX0QgPT0gNClcXG4gICAgICAgICAgICAgIG1haW5fbWVtb3J5W3BhcnNlSW50KGRhdGEsIDE2KV0uTDFfRCA9IDE7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKGluc3RydWN0aW9uc1tpbmRleF0uTDFfRCA9PSAwKVxcbiAgICAgICAgICAgIGluc3RydWN0aW9uc1tpbmRleF0uTDFfRCA9IDM7XFxuICAgICAgICAgIGVsc2UgaWYgKGluc3RydWN0aW9uc1tpbmRleF0uTDFfRCA9PSAzKVxcbiAgICAgICAgICAgIGluc3RydWN0aW9uc1tpbmRleF0uTDFfRCA9IDM7XFxuICAgICAgICAgIGVsc2UgaWYgKGluc3RydWN0aW9uc1tpbmRleF0uTDFfRCA9PSA0KVxcbiAgICAgICAgICAgIGluc3RydWN0aW9uc1tpbmRleF0uTDFfRCA9IDE7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSBcIkNhY2hlIEwxX0QgbWlzc1wiOlxcbiAgICAgICAgICBpZihkYXRhICE9PSBcIlwiKSB7XFxuICAgICAgICAgICAgbGV0IGxhc3R2ID0gcGFyc2VJbnQoZGF0YVtkYXRhLmxlbmd0aCAtIDFdLCAxNik7XFxuICAgICAgICAgICAgaWYgKGxhc3R2IDwgNCkgZGF0YSA9IGRhdGEuc2xpY2UoMCwgLTEpICsgXCIwXCI7XFxuICAgICAgICAgICAgZWxzZSBpZiAobGFzdHYgPCA4KSBkYXRhID0gZGF0YS5zbGljZSgwLCAtMSkgKyBcIjRcIjtcXG4gICAgICAgICAgICBlbHNlIGlmIChsYXN0diA8IDEyKSBkYXRhID0gZGF0YS5zbGljZSgwLCAtMSkgKyAgXCI4XCI7XFxuICAgICAgICAgICAgZWxzZSBkYXRhID0gZGF0YS5zbGljZSgwLCAtMSkgKyBcIkNcIjtcXG4gICAgICAgICAgICBsZXQgbWVtaW5kZXggPSBwYXJzZUludChkYXRhLCAxNik7XFxuICAgICAgICAgICAgaWYgKG1haW5fbWVtb3J5W21lbWluZGV4XS5MMV9EID09IDApXFxuICAgICAgICAgICAgICBtYWluX21lbW9yeVtwYXJzZUludChkYXRhLCAxNildLkwxX0QgPSA0O1xcbiAgICAgICAgICAgIGVsc2UgaWYgKG1haW5fbWVtb3J5W21lbWluZGV4XS5MMV9EID09IDQpXFxuICAgICAgICAgICAgICBtYWluX21lbW9yeVtwYXJzZUludChkYXRhLCAxNildLkwxX0QgPSA0O1xcbiAgICAgICAgICAgIGVsc2UgaWYgKG1haW5fbWVtb3J5W21lbWluZGV4XS5MMV9EID09IDMpXFxuICAgICAgICAgICAgICBtYWluX21lbW9yeVtwYXJzZUludChkYXRhLCAxNildLkwxX0QgPSAxO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChpbnN0cnVjdGlvbnNbaW5kZXhdLkwxX0QgPT0gMClcXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnNbaW5kZXhdLkwxX0QgPSA0O1xcbiAgICAgICAgICBlbHNlIGlmIChpbnN0cnVjdGlvbnNbaW5kZXhdLkwxX0QgPT0gNClcXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnNbaW5kZXhdLkwxX0QgPSA0O1xcbiAgICAgICAgICBlbHNlIGlmIChpbnN0cnVjdGlvbnNbaW5kZXhdLkwxX0QgPT0gMylcXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnNbaW5kZXhdLkwxX0QgPSAxO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgXCJDYWNoZSBMMiBoaXQgaW5zdFwiOlxcbiAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9JID09IDApXFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9JID0gMztcXG4gICAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9JID09IDMpXFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9JID0gMztcXG4gICAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9JID09IDQpXFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9JID0gMTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlIFwiQ2FjaGUgTDIgbWlzcyBpbnN0XCI6XFxuICAgICAgICAgIGlmIChpbnN0cnVjdGlvbnNbaW5kZXhdLkwyX0kgPT0gMClcXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnNbaW5kZXhdLkwyX0kgPSA0O1xcbiAgICAgICAgICBlbHNlIGlmIChpbnN0cnVjdGlvbnNbaW5kZXhdLkwyX0kgPT0gNClcXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnNbaW5kZXhdLkwyX0kgPSA0O1xcbiAgICAgICAgICBlbHNlIGlmIChpbnN0cnVjdGlvbnNbaW5kZXhdLkwyX0kgPT0gMylcXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnNbaW5kZXhdLkwyX0kgPSAxO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgXCJDYWNoZSBMMl9JIGhpdFwiOlxcbiAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9JID09IDApXFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9JID0gMztcXG4gICAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9JID09IDMpXFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9JID0gMztcXG4gICAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9JID09IDQpXFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9JID0gMTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlIFwiQ2FjaGUgTDJfSSBtaXNzXCI6XFxuICAgICAgICAgIGlmIChpbnN0cnVjdGlvbnNbaW5kZXhdLkwyX0kgPT0gMClcXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnNbaW5kZXhdLkwyX0kgPSA0O1xcbiAgICAgICAgICBlbHNlIGlmIChpbnN0cnVjdGlvbnNbaW5kZXhdLkwyX0kgPT0gNClcXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnNbaW5kZXhdLkwyX0kgPSA0O1xcbiAgICAgICAgICBlbHNlIGlmIChpbnN0cnVjdGlvbnNbaW5kZXhdLkwyX0kgPT0gMylcXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnNbaW5kZXhdLkwyX0kgPSAxO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgXCJDYWNoZSBMMiBoaXQgZGF0YVwiOlxcbiAgICAgICAgICBpZihkYXRhICE9PSBcIlwiKSB7XFxuICAgICAgICAgICAgbGV0IGxhc3R2ID0gcGFyc2VJbnQoZGF0YVtkYXRhLmxlbmd0aCAtIDFdLCAxNik7XFxuICAgICAgICAgICAgaWYgKGxhc3R2IDwgNCkgZGF0YSA9IGRhdGEuc2xpY2UoMCwgLTEpICsgXCIwXCI7XFxuICAgICAgICAgICAgZWxzZSBpZiAobGFzdHYgPCA4KSBkYXRhID0gZGF0YS5zbGljZSgwLCAtMSkgKyBcIjRcIjtcXG4gICAgICAgICAgICBlbHNlIGlmIChsYXN0diA8IDEyKSBkYXRhID0gZGF0YS5zbGljZSgwLCAtMSkgKyAgXCI4XCI7XFxuICAgICAgICAgICAgZWxzZSBkYXRhID0gZGF0YS5zbGljZSgwLCAtMSkgKyBcIkNcIjtcXG4gICAgICAgICAgICBsZXQgbWVtaW5kZXggPSBwYXJzZUludChkYXRhLCAxNik7XFxuICAgICAgICAgICAgaWYgKG1haW5fbWVtb3J5W21lbWluZGV4XS5MMl9EID09IDApXFxuICAgICAgICAgICAgICBtYWluX21lbW9yeVtwYXJzZUludChkYXRhLCAxNildLkwyX0QgPSAzO1xcbiAgICAgICAgICAgIGVsc2UgaWYgKG1haW5fbWVtb3J5W21lbWluZGV4XS5MMl9EID09IDMpXFxuICAgICAgICAgICAgICBtYWluX21lbW9yeVtwYXJzZUludChkYXRhLCAxNildLkwyX0QgPSAzO1xcbiAgICAgICAgICAgIGVsc2UgaWYgKG1haW5fbWVtb3J5W21lbWluZGV4XS5MMl9EID09IDQpXFxuICAgICAgICAgICAgICBtYWluX21lbW9yeVtwYXJzZUludChkYXRhLCAxNildLkwyX0QgPSAxO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChpbnN0cnVjdGlvbnNbaW5kZXhdLkwyX0QgPT0gMClcXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnNbaW5kZXhdLkwyX0QgPSAzO1xcbiAgICAgICAgICBlbHNlIGlmIChpbnN0cnVjdGlvbnNbaW5kZXhdLkwyX0QgPT0gMylcXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnNbaW5kZXhdLkwyX0QgPSAzO1xcbiAgICAgICAgICBlbHNlIGlmIChpbnN0cnVjdGlvbnNbaW5kZXhdLkwyX0QgPT0gNClcXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnNbaW5kZXhdLkwyX0QgPSAxO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgXCJDYWNoZSBMMiBtaXNzIGRhdGFcIjpcXG4gICAgICAgICAgaWYoZGF0YSAhPT0gXCJcIikge1xcbiAgICAgICAgICAgIGxldCBsYXN0diA9IHBhcnNlSW50KGRhdGFbZGF0YS5sZW5ndGggLSAxXSwgMTYpO1xcbiAgICAgICAgICAgIGlmIChsYXN0diA8IDQpIGRhdGEgPSBkYXRhLnNsaWNlKDAsIC0xKSArIFwiMFwiO1xcbiAgICAgICAgICAgIGVsc2UgaWYgKGxhc3R2IDwgOCkgZGF0YSA9IGRhdGEuc2xpY2UoMCwgLTEpICsgXCI0XCI7XFxuICAgICAgICAgICAgZWxzZSBpZiAobGFzdHYgPCAxMikgZGF0YSA9IGRhdGEuc2xpY2UoMCwgLTEpICsgIFwiOFwiO1xcbiAgICAgICAgICAgIGVsc2UgZGF0YSA9IGRhdGEuc2xpY2UoMCwgLTEpICsgXCJDXCI7XFxuICAgICAgICAgICAgbGV0IG1lbWluZGV4ID0gcGFyc2VJbnQoZGF0YSwgMTYpO1xcbiAgICAgICAgICAgIGlmIChtYWluX21lbW9yeVttZW1pbmRleF0uTDJfRCA9PSAwKVxcbiAgICAgICAgICAgICAgbWFpbl9tZW1vcnlbcGFyc2VJbnQoZGF0YSwgMTYpXS5MMl9EID0gNDtcXG4gICAgICAgICAgICBlbHNlIGlmIChtYWluX21lbW9yeVttZW1pbmRleF0uTDJfRCA9PSA0KVxcbiAgICAgICAgICAgICAgbWFpbl9tZW1vcnlbcGFyc2VJbnQoZGF0YSwgMTYpXS5MMl9EID0gNDtcXG4gICAgICAgICAgICBlbHNlIGlmIChtYWluX21lbW9yeVttZW1pbmRleF0uTDJfRCA9PSAzKVxcbiAgICAgICAgICAgICAgbWFpbl9tZW1vcnlbcGFyc2VJbnQoZGF0YSwgMTYpXS5MMl9EID0gMTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9EID09IDApXFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9EID0gNDtcXG4gICAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9EID09IDQpXFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9EID0gNDtcXG4gICAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9EID09IDMpXFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9EID0gMTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlIFwiQ2FjaGUgTDJfRCBoaXRcIjpcXG4gICAgICAgICAgaWYoZGF0YSAhPT0gXCJcIikge1xcbiAgICAgICAgICAgIGxldCBsYXN0diA9IHBhcnNlSW50KGRhdGFbZGF0YS5sZW5ndGggLSAxXSwgMTYpO1xcbiAgICAgICAgICAgIGlmIChsYXN0diA8IDQpIGRhdGEgPSBkYXRhLnNsaWNlKDAsIC0xKSArIFwiMFwiO1xcbiAgICAgICAgICAgIGVsc2UgaWYgKGxhc3R2IDwgOCkgZGF0YSA9IGRhdGEuc2xpY2UoMCwgLTEpICsgXCI0XCI7XFxuICAgICAgICAgICAgZWxzZSBpZiAobGFzdHYgPCAxMikgZGF0YSA9IGRhdGEuc2xpY2UoMCwgLTEpICsgIFwiOFwiO1xcbiAgICAgICAgICAgIGVsc2UgZGF0YSA9IGRhdGEuc2xpY2UoMCwgLTEpICsgXCJDXCI7XFxuICAgICAgICAgICAgbGV0IG1lbWluZGV4ID0gcGFyc2VJbnQoZGF0YSwgMTYpO1xcbiAgICAgICAgICAgIGlmIChtYWluX21lbW9yeVttZW1pbmRleF0uTDJfRCA9PSAwKVxcbiAgICAgICAgICAgICAgbWFpbl9tZW1vcnlbcGFyc2VJbnQoZGF0YSwgMTYpXS5MMl9EID0gMztcXG4gICAgICAgICAgICBlbHNlIGlmIChtYWluX21lbW9yeVttZW1pbmRleF0uTDJfRCA9PSAzKVxcbiAgICAgICAgICAgICAgbWFpbl9tZW1vcnlbcGFyc2VJbnQoZGF0YSwgMTYpXS5MMl9EID0gMztcXG4gICAgICAgICAgICBlbHNlIGlmIChtYWluX21lbW9yeVttZW1pbmRleF0uTDJfRCA9PSA0KVxcbiAgICAgICAgICAgICAgbWFpbl9tZW1vcnlbcGFyc2VJbnQoZGF0YSwgMTYpXS5MMl9EID0gMTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9EID09IDApXFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9EID0gMztcXG4gICAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9EID09IDMpXFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9EID0gMztcXG4gICAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9EID09IDQpXFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2luZGV4XS5MMl9EID0gMTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlIFwiQ2FjaGUgTDJfRCBtaXNzXCI6XFxuICAgICAgICAgIGlmKGRhdGEgIT09IFwiXCIpIHtcXG4gICAgICAgICAgICBsZXQgbGFzdHYgPSBwYXJzZUludChkYXRhW2RhdGEubGVuZ3RoIC0gMV0sIDE2KTtcXG4gICAgICAgICAgICBpZiAobGFzdHYgPCA0KSBkYXRhID0gZGF0YS5zbGljZSgwLCAtMSkgKyBcIjBcIjtcXG4gICAgICAgICAgICBlbHNlIGlmIChsYXN0diA8IDgpIGRhdGEgPSBkYXRhLnNsaWNlKDAsIC0xKSArIFwiNFwiO1xcbiAgICAgICAgICAgIGVsc2UgaWYgKGxhc3R2IDwgMTIpIGRhdGEgPSBkYXRhLnNsaWNlKDAsIC0xKSArICBcIjhcIjtcXG4gICAgICAgICAgICBlbHNlIGRhdGEgPSBkYXRhLnNsaWNlKDAsIC0xKSArIFwiQ1wiO1xcbiAgICAgICAgICAgIGxldCBtZW1pbmRleCA9IHBhcnNlSW50KGRhdGEsIDE2KTtcXG4gICAgICAgICAgICBpZiAobWFpbl9tZW1vcnlbbWVtaW5kZXhdLkwyX0QgPT0gMClcXG4gICAgICAgICAgICAgIG1haW5fbWVtb3J5W3BhcnNlSW50KGRhdGEsIDE2KV0uTDJfRCA9IDQ7XFxuICAgICAgICAgICAgZWxzZSBpZiAobWFpbl9tZW1vcnlbbWVtaW5kZXhdLkwyX0QgPT0gNClcXG4gICAgICAgICAgICAgIG1haW5fbWVtb3J5W3BhcnNlSW50KGRhdGEsIDE2KV0uTDJfRCA9IDQ7XFxuICAgICAgICAgICAgZWxzZSBpZiAobWFpbl9tZW1vcnlbbWVtaW5kZXhdLkwyX0QgPT0gMylcXG4gICAgICAgICAgICAgIG1haW5fbWVtb3J5W3BhcnNlSW50KGRhdGEsIDE2KV0uTDJfRCA9IDE7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKGluc3RydWN0aW9uc1tpbmRleF0uTDJfRCA9PSAwKVxcbiAgICAgICAgICAgIGluc3RydWN0aW9uc1tpbmRleF0uTDJfRCA9IDQ7XFxuICAgICAgICAgIGVsc2UgaWYgKGluc3RydWN0aW9uc1tpbmRleF0uTDJfRCA9PSA0KVxcbiAgICAgICAgICAgIGluc3RydWN0aW9uc1tpbmRleF0uTDJfRCA9IDQ7XFxuICAgICAgICAgIGVsc2UgaWYgKGluc3RydWN0aW9uc1tpbmRleF0uTDJfRCA9PSAzKVxcbiAgICAgICAgICAgIGluc3RydWN0aW9uc1tpbmRleF0uTDJfRCA9IDE7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG5cXG4gICAgfVxcblxcblxcbiAgICBhc3luYyBmdW5jdGlvbiBjaGVja19jYWxsX2NvbnZlbnRpb25fdGVtcF9yZWdzKGluc3RNYXRjaCkge1xcbiAgICAgIGlmKCgoaW5zdE1hdGNoWzddICE9IHVuZGVmaW5lZCAmJiAoaW5zdE1hdGNoWzddLmluY2x1ZGVzKFwidFwiKSB8fCAoaW5zdE1hdGNoWzddLmluY2x1ZGVzKFwic1wiKSAmJiAhaW5zdE1hdGNoWzddLmluY2x1ZGVzKFwic3BcIikpICkgKSB8fCAoaW5zdE1hdGNoWzhdICE9IHVuZGVmaW5lZCAmJiAoaW5zdE1hdGNoWzhdLmluY2x1ZGVzKFwidFwiKSB8fCAoaW5zdE1hdGNoWzhdLmluY2x1ZGVzKFwic1wiKSAmJiAhaW5zdE1hdGNoWzhdLmluY2x1ZGVzKFwic3BcIikpICkpKSAmJiBpbnN0TWF0Y2hbNl0gIT09IHVuZGVmaW5lZCAmJiBpbnNpZGVfZnVuY3Rpb24pIHtcXG4gICAgICAgIGlmKChpbnN0TWF0Y2hbNV0gIT0gXCJsaVwiICYmIGluc3RNYXRjaFs1XSAhPSBcImx1aVwiICYmIGluc3RNYXRjaFs1XSAhPSBcImxhXCIpICl7XFxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbHN0YWNrX2NvbnZlbnRpb25bY2FsbHN0YWNrX2NvbnZlbnRpb24ubGVuZ3RoIC0gMV0ubGVuZ3RoOyBpKysgKXtcXG4gICAgICAgICAgICAoY2FsbHN0YWNrX2NvbnZlbnRpb25bY2FsbHN0YWNrX2NvbnZlbnRpb24ubGVuZ3RoIC0gMV1baV0ubmFtZSA9PT0gaW5zdE1hdGNoWzddIHx8IGNhbGxzdGFja19jb252ZW50aW9uW2NhbGxzdGFja19jb252ZW50aW9uLmxlbmd0aCAtIDFdW2ldLm5hbWUgPT09IGluc3RNYXRjaFs4XSkgJiZcXG4gICAgICAgICAgICAoY2FsbHN0YWNrX2NvbnZlbnRpb25bY2FsbHN0YWNrX2NvbnZlbnRpb24ubGVuZ3RoIC0gMV1baV0uY2FuX29wZXJhdGUgPT09IGZhbHNlKSA/IHNob3dfbm90aWZpY2F0aW9uKFwiUG9zc2libGUgZmFpbHVyZSBpbiB0aGUgcGFyYW1ldGVyIHBhc3NpbmcgY29udmVudGlvblwiLCBcImRhbmdlclwiKSA6IDAgOyBcXG4gICAgICAgICAgfVxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIC8vIGNhbGxzdGFja19jb252ZW50aW9uW2NhbGxzdGFja19jb252ZW50aW9uLmxlbmd0aCAtIDFdLm5hbWUgXFxuXFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGlmIChpbnN0TWF0Y2hbNl0gIT09IHVuZGVmaW5lZCAmJiAoaW5zdE1hdGNoWzZdLmluY2x1ZGVzKFwidFwiKSB8fCAoaW5zdE1hdGNoWzZdLmluY2x1ZGVzKFwic1wiKSAmJiAhaW5zdE1hdGNoWzZdLmluY2x1ZGVzKFwic3BcIikpKSAmJiBpbnNpZGVfZnVuY3Rpb24pIHtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbHN0YWNrX2NvbnZlbnRpb25bY2FsbHN0YWNrX2NvbnZlbnRpb24ubGVuZ3RoIC0gMV0ubGVuZ3RoOyBpKysgKXtcXG4gICAgICAgICAgY2FsbHN0YWNrX2NvbnZlbnRpb25bY2FsbHN0YWNrX2NvbnZlbnRpb24ubGVuZ3RoIC0gMV1baV0uY2FuX29wZXJhdGUgPSAoY2FsbHN0YWNrX2NvbnZlbnRpb25bY2FsbHN0YWNrX2NvbnZlbnRpb24ubGVuZ3RoIC0gMV1baV0ubmFtZSA9PT0gaW5zdE1hdGNoWzZdKSA/IHRydWUgOiBjYWxsc3RhY2tfY29udmVudGlvbltjYWxsc3RhY2tfY29udmVudGlvbi5sZW5ndGggLSAxXVtpXS5jYW5fb3BlcmF0ZTsgXFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIFxcblxcbiAgICAvLyB2YXIgdG9fbWVhc3VyZSA9IFwiXCI7XFxuICAgIHZhciBzdGFydF9tLCBzdGFydF9tO1xcbiAgICB2YXIgY2FjaGVfaW5zdDtcXG5cXG4gICAgZnVuY3Rpb24gd3JpdGVNZW1vcnkodmFsdWUsIGFkZHIpIHtcXG4gICAgICAvLyBQcmltZXJvIHBhc2FyIGVsIHZhbG9yIGFsIGZvcm1hdG8gaGV4YWRlY2ltYWwgcG9yIHBhcmVzXFxuICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoXCIweFwiKSlcXG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMik7XFxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCAlIDIgIT09IDApXFxuICAgICAgICB2YWx1ZSA9IFwiMFwiICsgdmFsdWU7XFxuXFxuICAgICAgLy8gY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSh2YWx1ZS5sZW5ndGggLyAyKTtcXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aCAvIDI7IGkgKyspIHtcXG4gICAgICAgIG1haW5fbWVtb3J5LndyaXRlKChhZGRyICsgQmlnSW50KGkpKSwgTnVtYmVyKFwiMHhcIiArIHZhbHVlLnN1YnN0cmluZyhpKjIsIGkgKiAyICsgMikpKTtcXG4gICAgICB9XFxuXFxuICAgICAgLy8gaWYgKG1lbW9NYXRjaFsyXSA9PT0gXFwnPC1cXCcpe1xcbiAgICAgIC8vICAgICBzd2l0Y2gob3Ape1xcbiAgICAgIC8vICAgICAgIGNhc2UgXFwnc2hcXCc6IC8vIFBhcmEgYWxtYWNlbmFyIHVuIGhhbGZcXG4gICAgICAvLyAgICAgICB3cml0ZU1lbW9yeShtZW1vTWF0Y2hbM10sIHBhcnNlSW50KG1lbW9NYXRjaFsxXSwgMTYpLCBcXCdoYWxmXFwnKTtcXG4gICAgICAvLyAgICAgICBicmVhaztcXG4gICAgICAvLyAgICAgICBjYXNlIFxcJ3NiXFwnOiAvLyBQYXJhIGFsbWFjZW5hciB1biBieXRlXFxuICAgICAgLy8gICAgICAgd3JpdGVNZW1vcnkobWVtb01hdGNoWzNdLCBwYXJzZUludChtZW1vTWF0Y2hbMV0sIDE2KSwgXFwnYnl0ZVxcJyk7XFxuICAgICAgLy8gICAgICAgYnJlYWs7XFxuICAgICAgLy8gICAgICAgY2FzZSBcXCdzd1xcJzogLy8gUGFyYSBhbG1hY2VuYXIgdW4gaW50L3dvcmRcXG4gICAgICAvLyAgICAgICB3cml0ZU1lbW9yeShtZW1vTWF0Y2hbM10sIHBhcnNlSW50KG1lbW9NYXRjaFsxXSwgMTYpLCBcXCd3b3JkXFwnKTtcXG4gICAgICAvLyAgICAgICBicmVhaztcXG4gICAgICAvLyAgICAgICBjYXNlIFxcJ2Zzd1xcJzogLy8gUGFyYSBhbG1hY2VuYXIgdW4gZmxvYXRcXG4gICAgICAvLyAgICAgICB3cml0ZU1lbW9yeShtZW1vTWF0Y2hbM10sIHBhcnNlSW50KG1lbW9NYXRjaFsxXSwgMTYpLCBcXCdmbG9hdFxcJyk7XFxuICAgICAgLy8gICAgICAgYnJlYWs7XFxuICAgICAgLy8gICAgICAgY2FzZSBcXCdmc2RcXCc6IC8vIFBhcmEgYWxtYWNlbmFyIHVuIGRvdWJsZVxcbiAgICAgIC8vICAgICAgIHdyaXRlTWVtb3J5KG1lbW9NYXRjaFszXSwgcGFyc2VJbnQobWVtb01hdGNoWzFdLCAxNiksIFxcJ2RvdWJsZVxcJyk7XFxuICAgICAgLy8gICAgICAgYnJlYWs7XFxuICAgICAgLy8gICAgICAgY2FzZSBcXCd2c2U4LnZcXCc6XFxuICAgICAgLy8gICAgICAgd3JpdGVNZW1vcnkobWVtb01hdGNoWzNdLCBwYXJzZUludChtZW1vTWF0Y2hbMV0sIDE2KSwgXFwnYnl0ZVxcJyk7XFxuICAgICAgLy8gICAgICAgICBicmVhaztcXG4gICAgICAvLyAgICAgICBjYXNlIFxcJ3ZzZTE2LnZcXCc6XFxuICAgICAgLy8gICAgICAgd3JpdGVNZW1vcnkobWVtb01hdGNoWzNdLCBwYXJzZUludChtZW1vTWF0Y2hbMV0sIDE2KSwgXFwnaGFsZlxcJyk7XFxuICAgICAgLy8gICAgICAgICBicmVhaztcXG4gICAgICAvLyAgICAgICBjYXNlIFxcJ3ZzZTMyLnZcXCc6XFxuICAgICAgLy8gICAgICAgd3JpdGVNZW1vcnkobWVtb01hdGNoWzNdLCBwYXJzZUludChtZW1vTWF0Y2hbMV0sIDE2KSwgXFwnd29yZFxcJyk7XFxuICAgICAgLy8gICAgICAgICBicmVhaztcXG4gICAgICAvLyAgICAgICBjYXNlIFxcJ3ZzZTY0LnZcXCc6XFxuICAgICAgLy8gICAgICAgICB3cml0ZU1lbW9yeShtZW1vTWF0Y2hbM10sIHBhcnNlSW50KG1lbW9NYXRjaFsxXSwgMTYpLCBcXCdkb3VibGVcXCcpO1xcbiAgICAgIC8vICAgICAgICAgYnJlYWs7XFxuICAgICAgLy8gICAgICAgZGVmYXVsdDpcXG4gICAgICAvLyAgICAgICAgIGJyZWFrO1xcbiAgICAgIC8vICAgICB9XFxuICAgICAgLy8gICB9XFxuICAgIH1cXG5cXG4gICAgLy8gdmFyIG5vX3ByaW50X21vcmUgPSBmYWxzZTtcXG4gICAgTW9kdWxlW1xcJ3ByaW50XFwnXSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XFxuICAgICAgLy8gY29uc29sZS5sb2cobWVzc2FnZSk7XFxuICAgICAgaWYgKG1lc3NhZ2UgPT09IFwiRGl2ZXJnZW5jZSBleGVjdXRpb24gZGV0ZWN0ZWQ6IEFib3J0ZWQuXCIpXFxuICAgICAgICBzaG93X25vdGlmaWNhdGlvbihtZXNzYWdlLCBcImRhbmdlclwiKTtcXG4gICAgICBpZiAobWVzc2FnZSA9PT0gXCJlcnIgY2FsbF9jb252ZW5jdGlvblwiKVxcbiAgICAgICAgc2hvd19ub3RpZmljYXRpb24oXCJQb3NzaWJsZSBmYWlsdXJlIGluIHRoZSBwYXJhbWV0ZXIgcGFzc2luZyBjb252ZW50aW9uXCIsIFwid2FybmluZ1wiKTtcXG4gICAgICBcXG4gICAgICBpZiAobWVzc2FnZSA9PT0gXCJNYXkgeW91ciBleGVjdXRpb24gaGFzIGFuIGluZmluaXR5IGxvb3AuXCIpe1xcbiAgICAgICAgZG9jdW1lbnQuYXBwLiRkYXRhLmV4ZWN1dGlvbl9tb2RlX3J1biA9IDE7XFxuICAgICAgICBzaG93X25vdGlmaWNhdGlvbihcIk1heSB5b3VyIGV4ZWN1dGlvbiBoYXMgYW4gaW5maW5pdHkgbG9vcFwiLCBcImRhbmdlclwiKTtcXG4gICAgICAgIGluc3RydWN0aW9uc1toaWRlbl9leGVjdXRlZF0uX3Jvd1ZhcmlhbnQgPSBcImluZm9cIjtcXG4gICAgICAgIGluc3RydWN0aW9uc1toaWRlbl9uZXh0X2V4ZWN1dGVdLl9yb3dWYXJpYW50ID0gXCJzdWNjZXNzXCI7XFxuICAgICAgfVxcbiAgICAgIFxcbiAgICAgIHZhciBuZXh0X2FkZF90b19qdW1wO1xcbiAgICAgIGxldCBpbnN0TWF0Y2ggICAgICAgID0gbWVzc2FnZS5tYXRjaChpbnN0cnVjdGlvbkV4cCk7XFxuICAgICAgbGV0IHJlZ2lNYXRjaCAgICAgICAgPSBtZXNzYWdlLm1hdGNoKHJlZ2lzdGVyRXhwKTtcXG4gICAgICBsZXQgbWVtb01hdGNoICAgICAgICA9IG1lc3NhZ2UubWF0Y2gobWVtb3J5RXhwKTtcXG4gICAgICBsZXQgcHJpbnRNYXRjaCAgICAgICA9IG1lc3NhZ2UubWF0Y2goZGlzcGxheUV4cCk7XFxuICAgICAgbGV0IENTUk1hdGNoICAgICAgICAgPSBtZXNzYWdlLm1hdGNoKENTUlR5cGVFeHApO1xcbiAgICAgIGxldCBDU1JFTWF0Y2ggICAgICAgID0gbWVzc2FnZS5tYXRjaChDU1JFeHApO1xcbiAgICAgIGxldCB2ZWN0b3JNYXRjaCAgICAgID0gbWVzc2FnZS5tYXRjaCh2ZWN0b3JFeHApO1xcbiAgICAgIGxldCBqdW1wTWF0Y2ggICAgICAgID0gbWVzc2FnZS5tYXRjaChqdW1wRXhwKTtcXG4gICAgICBsZXQgY2FjaGVNYXRjaCAgICAgICA9IG1lc3NhZ2UubWF0Y2goY2FjaGVFeHApO1xcbiAgICAgIGxldCBjb25maWdDYWNoZU1hdGNoID0gbWVzc2FnZS5tYXRjaChjb25maWdDYWNoZUV4cCk7XFxuXFxuICAgICAgaWYgKG1lc3NhZ2Uuc3RhcnRzV2l0aChcIkNhY2hlXCIpIHx8IG1lc3NhZ2Uuc3RhcnRzV2l0aChcIk5leHRfUEM6XCIpKXtcXG4gICAgICAgIGlmIChtZXNzYWdlLmluY2x1ZGVzKFwiQ2FjaGUgcHJlZmV0Y2hcIikpIHtcXG4gICAgICAgICAgbGV0IG5ld3BjID0gbWVzc2FnZS5zdWJzdHJpbmcoMTUsbWVzc2FnZS5sZW5ndGgpLnRvTG93ZXJDYXNlKCk7XFxuICAgICAgICAgIGNhY2hlX2luc3QgPSBpbnN0cnVjdGlvbnMuZmluZEluZGV4KGluc24gPT4gaW5zbi5BZGRyZXNzID09PSAoXCIweFwiICsgQmlnSW50KG5ld3BjKS50b1N0cmluZygxNikpKTtcXG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5pbmNsdWRlcyhcIk5leHRfUEM6XCIpKSB7XFxuICAgICAgICAgIGxldCBuZXdwYyA9IG1lc3NhZ2Uuc3Vic3RyaW5nKDksIG1lc3NhZ2UubGVuZ3RoKS50b0xvd2VyQ2FzZSgpO1xcbiAgICAgICAgICBjYWNoZV9pbnN0ID0gaW5zdHJ1Y3Rpb25zLmZpbmRJbmRleChpbnNuID0+IGluc24uQWRkcmVzcyA9PSAoXCIweFwiICsgQmlnSW50KG5ld3BjKS50b1N0cmluZygxNikpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChjYWNoZV9pbnN0ICE9IC0xICYmIGRvY3VtZW50LmFwcC4kZGF0YS5leGVjdXRpb25fbW9kZV9ydW4gPT09IDEpIHtcXG4gICAgICAgICAgbGV0IGhleG1hdGNoID0gbWVzc2FnZS5tYXRjaCgvMHhbMC05QS1GYS1mXSskLyk7XFxuICAgICAgICAgIGlmIChoZXhtYXRjaCAmJiAhbWVzc2FnZS5zdGFydHNXaXRoKFwiQ2FjaGUgcHJlZmV0Y2hcIikpIHtcXG4gICAgICAgICAgICBsZXQgaGV4YSA9IGhleG1hdGNoWzBdO1xcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoL29uOlxcXFxzKjB4WzAtOUEtRmEtZl0rJC8sIFwiXCIpLnRyaW0oKTtcXG4gICAgICAgICAgICB1cGRhdGVDYWNoZVN0YXQoY2FjaGVfaW5zdCwgbWVzc2FnZSwgaGV4YSk7XFxuICAgICAgICAgIH1lbHNlIHtcXG4gICAgICAgICAgICB1cGRhdGVDYWNoZVN0YXQoY2FjaGVfaW5zdCwgbWVzc2FnZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgXFxuICAgICAgICB9XFxuICAgICAgfVxcblxcblxcbiAgICAgIGlmIChqdW1wTWF0Y2gpe1xcbiAgICAgICAganVtcE1hdGNoWzFdID0gXCIweFwiICsganVtcE1hdGNoWzFdLnJlcGxhY2UoL14wKy8sIFxcJ1xcJyk7XFxuICAgICAgICBpZiAoanVtcE1hdGNoWzFdID09PSBcIjB4XCIpIGp1bXBNYXRjaFsxXSA9IFwiMHgwXCI7XFxuICAgICAgICAvLyBjb25zb2xlLmxvZyhqdW1wTWF0Y2gpO1xcbiAgICAgICAgY29uc3QgY3VycmVudF9pbnMgPSBpbnN0cnVjdGlvbnMuZmluZEluZGV4KGluc24gPT4gaW5zbi5BZGRyZXNzID09PSAoanVtcE1hdGNoWzFdLnRvTG93ZXJDYXNlKCkpKTtcXG4gICAgICAgIFxcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKyl7XFxuICAgICAgICAgICAgaWYoaW5zdHJ1Y3Rpb25zW2ldLl9yb3dWYXJpYW50ID09PSBcInN1Y2Nlc3NcIiAmJiBkb2N1bWVudC5hcHAuJGRhdGEuZXhlY3V0aW9uX21vZGVfcnVuICE9PSAwKSAvLyBhanVzdGFyIGxvIGRlbCB1c2VyIG1vZGVcXG4gICAgICAgICAgICAgIGluc3RydWN0aW9uc1tpXS5fcm93VmFyaWFudCA9IFwiXCI7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGlmIChjdXJyZW50X2lucyAhPT0gLTEpIGluc3RydWN0aW9uc1tjdXJyZW50X2luc10uX3Jvd1ZhcmlhbnQgPSBcInN1Y2Nlc3NcIjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGNvbmZpZ0NhY2hlTWF0Y2gpIHtcXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGNvbmZpZ0NhY2hlTWF0Y2gpO1xcbiAgICAgICAgc3dpdGNoKGNvbmZpZ0NhY2hlTWF0Y2hbMV0pIHtcXG4gICAgICAgICAgY2FzZSBcIkwxX0lfU0laRVwiOlxcbiAgICAgICAgICAgIGNvbmZpZ19jYWNoZS5wdXNoKHtjb25maWd1cmF0aW9uOiBcIlNpemUgTDFfSVwiLCB2YWx1ZTogY29uZmlnQ2FjaGVNYXRjaFsyXSArIFwiIGxpbmVzXCJ9KTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgY2FzZSBcIkwxX0RfU0laRVwiOlxcbiAgICAgICAgICAgIGNvbmZpZ19jYWNoZS5wdXNoKHtjb25maWd1cmF0aW9uOiBcIlNpemUgTDFfRFwiLCB2YWx1ZTogY29uZmlnQ2FjaGVNYXRjaFsyXSArIFwiIGxpbmVzXCJ9KTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgY2FzZSBcIkwxX1NJWkVcIjpcXG4gICAgICAgICAgICBjb25maWdfY2FjaGUucHVzaCh7Y29uZmlndXJhdGlvbjogXCJTaXplIEwxXCIsIHZhbHVlOiBjb25maWdDYWNoZU1hdGNoWzJdICsgXCIgbGluZXNcIn0pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlIFwiTDJfSV9TSVpFXCI6XFxuICAgICAgICAgICAgY29uZmlnX2NhY2hlLnB1c2goe2NvbmZpZ3VyYXRpb246IFwiU2l6ZSBMMl9JXCIsIHZhbHVlOiBjb25maWdDYWNoZU1hdGNoWzJdICsgXCIgbGluZXNcIn0pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlIFwiTDJfRF9TSVpFXCI6XFxuICAgICAgICAgICAgY29uZmlnX2NhY2hlLnB1c2goe2NvbmZpZ3VyYXRpb246IFwiU2l6ZSBMMl9EXCIsIHZhbHVlOiBjb25maWdDYWNoZU1hdGNoWzJdICsgXCIgbGluZXNcIn0pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlIFwiTDJfU0laRVwiOlxcbiAgICAgICAgICAgIGNvbmZpZ19jYWNoZS5wdXNoKHtjb25maWd1cmF0aW9uOiBcIlNpemUgTDJcIiwgdmFsdWU6IGNvbmZpZ0NhY2hlTWF0Y2hbMl0gKyBcIiBsaW5lc1wifSk7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIGNhc2UgXCJSZXBfcG9saWN5XCI6XFxuICAgICAgICAgICAgY29uZmlnX2NhY2hlLnB1c2goe2NvbmZpZ3VyYXRpb246IFwiUmVwbGFjZW1lbnQgcG9saWN5XCIsIHZhbHVlOiBjb25maWdDYWNoZU1hdGNoWzJdfSk7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIGNhc2UgXCJMMV9JX0JMT0NLX1NJWkVcIjpcXG4gICAgICAgICAgICBjb25maWdfY2FjaGUucHVzaCh7Y29uZmlndXJhdGlvbjogXCJTaXplIENhY2hlIEwxX0kgYmxvY2tcIiwgdmFsdWU6IGNvbmZpZ0NhY2hlTWF0Y2hbMl0gKyBcIiBiaXRzXCJ9KTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgY2FzZSBcIkwxX0RfQkxPQ0tfU0laRVwiOlxcbiAgICAgICAgICAgIGNvbmZpZ19jYWNoZS5wdXNoKHtjb25maWd1cmF0aW9uOiBcIlNpemUgQ2FjaGUgTDFfRCBibG9ja1wiLCB2YWx1ZTogY29uZmlnQ2FjaGVNYXRjaFsyXSArIFwiIGJpdHNcIn0pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlIFwiTDFfQkxPQ0tfU0laRVwiOlxcbiAgICAgICAgICAgIGNvbmZpZ19jYWNoZS5wdXNoKHtjb25maWd1cmF0aW9uOiBcIlNpemUgQ2FjaGUgTDEgYmxvY2tcIiwgdmFsdWU6IGNvbmZpZ0NhY2hlTWF0Y2hbMl0gKyBcIiBiaXRzXCJ9KTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgY2FzZSBcIkwyX0lfQkxPQ0tfU0laRVwiOlxcbiAgICAgICAgICAgIGNvbmZpZ19jYWNoZS5wdXNoKHtjb25maWd1cmF0aW9uOiBcIlNpemUgQ2FjaGUgTDJfSSBibG9ja1wiLCB2YWx1ZTogY29uZmlnQ2FjaGVNYXRjaFsyXSArIFwiIGJpdHNcIn0pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlIFwiTDJfRF9CTE9DS19TSVpFXCI6XFxuICAgICAgICAgICAgY29uZmlnX2NhY2hlLnB1c2goe2NvbmZpZ3VyYXRpb246IFwiU2l6ZSBDYWNoZSBMMl9EIGJsb2NrXCIsIHZhbHVlOiBjb25maWdDYWNoZU1hdGNoWzJdICsgXCIgYml0c1wifSk7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIGNhc2UgXCJMMl9CTE9DS19TSVpFXCI6XFxuICAgICAgICAgICAgY29uZmlnX2NhY2hlLnB1c2goe2NvbmZpZ3VyYXRpb246IFwiU2l6ZSBDYWNoZSBMMiBibG9ja1wiLCB2YWx1ZTogY29uZmlnQ2FjaGVNYXRjaFsyXSArIFwiIGJpdHNcIn0pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoY2FjaGVNYXRjaCkge1xcbiAgICAgICAgY29uc29sZS5sb2coY2FjaGVNYXRjaCk7XFxuICAgICAgICAvLyB1cGRhdGVDYWNoZU1lbShwYXJzZUludChjYWNoZU1hdGNoWzFdLDEwKSwgY2FjaGVNYXRjaFsyXSwgY2FjaGVNYXRjaFszXSwgcGFyc2VJbnQoY2FjaGVNYXRjaFs0XSwgMTApKTtcXG4gICAgICAgIHN3aXRjaChjYWNoZU1hdGNoWzJdKSB7XFxuICAgICAgICAgIGNhc2UgXCJMMV9JXCI6XFxuICAgICAgICAgICAgdXBkYXRlQ2FjaGVNZW0ocGFyc2VJbnQoY2FjaGVNYXRjaFsxXSwxMCksIGNhY2hlTWF0Y2hbMl0sIGNhY2hlTWF0Y2hbM10sIGRvY3VtZW50LmFwcC4kZGF0YS5MMV9JX3NpemVfYmxvY2spO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgY2FzZSBcIkwxX0RcIjpcXG4gICAgICAgICAgICB1cGRhdGVDYWNoZU1lbShwYXJzZUludChjYWNoZU1hdGNoWzFdLDEwKSwgY2FjaGVNYXRjaFsyXSwgY2FjaGVNYXRjaFszXSwgZG9jdW1lbnQuYXBwLiRkYXRhLkwxX0Rfc2l6ZV9ibG9jayk7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlIFwiTDFcIjpcXG4gICAgICAgICAgICB1cGRhdGVDYWNoZU1lbShwYXJzZUludChjYWNoZU1hdGNoWzFdLDEwKSwgY2FjaGVNYXRjaFsyXSwgY2FjaGVNYXRjaFszXSwgZG9jdW1lbnQuYXBwLiRkYXRhLkwxX3NpemVfYmxvY2spO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgY2FzZSBcIkwyX0lcIjpcXG4gICAgICAgICAgICB1cGRhdGVDYWNoZU1lbShwYXJzZUludChjYWNoZU1hdGNoWzFdLDEwKSwgY2FjaGVNYXRjaFsyXSwgY2FjaGVNYXRjaFszXSwgZG9jdW1lbnQuYXBwLiRkYXRhLkwyX0lfc2l6ZV9ibG9jayk7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlIFwiTDJfRFwiOlxcbiAgICAgICAgICAgIHVwZGF0ZUNhY2hlTWVtKHBhcnNlSW50KGNhY2hlTWF0Y2hbMV0sMTApLCBjYWNoZU1hdGNoWzJdLCBjYWNoZU1hdGNoWzNdLCBkb2N1bWVudC5hcHAuJGRhdGEuTDJfRF9zaXplX2Jsb2NrKTtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIGNhc2UgXCJMMlwiOlxcbiAgICAgICAgICAgIHVwZGF0ZUNhY2hlTWVtKHBhcnNlSW50KGNhY2hlTWF0Y2hbMV0sMTApLCBjYWNoZU1hdGNoWzJdLCBjYWNoZU1hdGNoWzNdLCBkb2N1bWVudC5hcHAuJGRhdGEuTDJfc2l6ZV9ibG9jayk7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZihDU1JFTWF0Y2gpe1xcbiAgICAgICAgY29uc29sZS5sb2coQ1NSRU1hdGNoKTtcXG4gICAgICAgIGlmIChDU1JFTWF0Y2hbMl0gIT09IFwidnR5cGVcIiAmJiBDU1JFTWF0Y2hbMl0gIT09IFwidmxcIil7XFxuICAgICAgICAgIGxldCByZWd0b3dyaXRlID0gY3JleF9maW5kUmVnKENTUkVNYXRjaFsyXSk7XFxuICAgICAgICAgIGlmKHJlZ3Rvd3JpdGUubWF0Y2ggIT09IDApXFxuICAgICAgICAgICAgd3JpdGVSZWdpc3RlcihDU1JFTWF0Y2hbNF0sIHJlZ3Rvd3JpdGUuaW5kZXhDb21wLCByZWd0b3dyaXRlLmluZGV4RWxlbSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGlmIChDU1JNYXRjaCl7XFxuICAgICAgICBpZiAoQ1NSTWF0Y2hbMl0gPT09IFwidnR5cGVcIil7XFxuICAgICAgICAgIHZhciBzaXplX2VsZW0gPSBwYXJzZUludChDU1JNYXRjaFs1XSwgMTYpLnRvU3RyaW5nKDIpLnBhZFN0YXJ0KDMyLCBcXCcwXFwnKTtcXG4gICAgICAgICAgc2l6ZV9lbGVtID0gc2l6ZV9lbGVtLnNsaWNlKDI2LCAyOSk7XFxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiVGFtYcOxbzogXCIsIHNpemVfZWxlbSk7XFxuICAgICAgICAgIGlmKHNpemVfZWxlbSA9PT0gXCIwMDBcIil7XFxuICAgICAgICAgICAgZG9jdW1lbnQuYXBwLiRkYXRhLnZfbGVuZ3RoID0gODtcXG4gICAgICAgICAgICAvLyBsZW5ndGhfdmV4dCA9IDg7XFxuICAgICAgICAgICAgLy8gYXJjaGl0ZWN0dXJlLmNvbXBvbmVudHNbM10udG90YWxfZWxlbWVudHMgPSA2NDtcXG4gICAgICAgICAgfSBlbHNlIGlmIChzaXplX2VsZW0gPT09IFwiMDAxXCIpIHtcXG4gICAgICAgICAgICBkb2N1bWVudC5hcHAuJGRhdGEudl9sZW5ndGggPSAxNjtcXG4gICAgICAgICAgICAvLyBsZW5ndGhfdmV4dCA9IDE2O1xcbiAgICAgICAgICAgIC8vIGFyY2hpdGVjdHVyZS5jb21wb25lbnRzWzNdLnRvdGFsX2VsZW1lbnRzID0gMzI7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoc2l6ZV9lbGVtID09PSBcIjAxMFwiKXtcXG4gICAgICAgICAgICBkb2N1bWVudC5hcHAuJGRhdGEudl9sZW5ndGggPSAzMjtcXG4gICAgICAgICAgICAvLyBsZW5ndGhfdmV4dCA9IDMyO1xcbiAgICAgICAgICAgIC8vIGFyY2hpdGVjdHVyZS5jb21wb25lbnRzWzNdLnRvdGFsX2VsZW1lbnRzID0gMTY7XFxuICAgICAgICAgIH1lbHNlIHtcXG4gICAgICAgICAgICBkb2N1bWVudC5hcHAuJGRhdGEudl9sZW5ndGggPSA2NDtcXG4gICAgICAgICAgICAvLyBsZW5ndGhfdmV4dCA9IDY0O1xcbiAgICAgICAgICAgIC8vIGFyY2hpdGVjdHVyZS5jb21wb25lbnRzWzNdLnRvdGFsX2VsZW1lbnRzID0gODtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICAvLyBhcmNoaXRlY3R1cmUuY29tcG9uZW50c1szXS5sZW5ndGhfZWxlbSA9IGxlbmd0aF92ZXh0O1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoQ1NSTWF0Y2hbMl0gPT09IFwidmxcIil7XFxuICAgICAgICAgIC8vIGFyY2hpdGVjdHVyZS5jb21wb25lbnRzWzNdLmVsZW1zX29wID0gcGFyc2VJbnQoQ1NSTWF0Y2hbNV0sIDE2KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgaWYgKHZlY3Rvck1hdGNoKXtcXG4gICAgICAgIGxldCByZWd0b3dyaXRlID0gY3JleF9maW5kUmVnKHZlY3Rvck1hdGNoWzFdKTtcXG4gICAgICAgIHdyaXRlUmVnaXN0ZXIodmVjdG9yTWF0Y2hbM10sIHJlZ3Rvd3JpdGUuaW5kZXhDb21wLCByZWd0b3dyaXRlLmluZGV4RWxlbSk7XFxuICAgICAgfVxcbiAgICAgIGlmIChpbnN0TWF0Y2ggJiYgLyooaW5zdE1hdGNoWzJdID09PSBcXCdVXFwnIHx8Ki8gKChwYXJzZUludChpbnN0TWF0Y2hbM10sIDE2KSA+PSBwY19taW4pICYmIHBhcnNlSW50KGluc3RNYXRjaFszXSwgMTYpIDwgcGFyc2VJbnQoXCIweDIwMDAwXCIsIDE2KSApKXtcXG4gICAgICAgIGNsZWFyQWxsUmVnaXN0ZXJHbG93cygpO1xcbiAgICAgICAgY29yZUV2ZW50cy5lbWl0KFwic3RlcC1hYm91dC10by1leGVjdXRlXCIpO1xcbiAgICAgICAgdXNlck1vZGU2NCA9IHRydWU7XFxuICAgICAgICBpZiAoaW5zaWRlX2Z1bmN0aW9uKSBcXG4gICAgICAgICAgY2hlY2tfY2FsbF9jb252ZW50aW9uX3RlbXBfcmVncyhpbnN0TWF0Y2gpO1xcblxcblxcbiAgICAgICAgLy9BY3R1YWxpemFtb3MgZWwgcGNcXG4gICAgICAgIHdyaXRlUmVnaXN0ZXIoQmlnSW50KHBhcnNlSW50KGluc3RNYXRjaFszXSwgMTYpKSwgcGNfc2FpbC5pbmRleENvbXAsIHBjX3NhaWwuaW5kZXhFbGVtKTtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIGlmIChpbnN0cnVjdGlvbnNbaV0uX3Jvd1ZhcmlhbnQgPT09IFwiaW5mb1wiKVxcbiAgICAgICAgICAgIGluc3RydWN0aW9uc1tpXS5fcm93VmFyaWFudCA9IFwiXCI7XFxuICAgICAgICB9XFxuICAgICAgICBpbnN0b3BlciA9IFwiXCI7XFxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlBDIGFjdHVhbDpcIixwY19zYWlsKTtcXG4gICAgICAgIC8vIGlmICgoaW5zdE1hdGNoWzVdLmluY2x1ZGVzKFwid1wiKSB8fCBpbnN0TWF0Y2hbNV0uaW5jbHVkZXMoXCIuc1wiKSB8fCBpbnN0TWF0Y2hbNV0uaW5jbHVkZXMoXCIud1wiKSkgJiYgIWluc3RNYXRjaC5pbmNsdWRlcyhcIi5kXCIpKVxcbiAgICAgICAgLy8gICB0eXBlX3RvV3JpdGUgPSAzMjtcXG4gICAgICAgIC8vIGVsc2UgaWYgKGluc3RNYXRjaFs1XS5pbmNsdWRlcyhcImRcIikpXFxuICAgICAgICAvLyAgIHR5cGVfdG9Xcml0ZSA9IDY0O1xcbiAgICAgICAgLy8gZWxzZSBcXG4gICAgICAgIC8vICAgdHlwZV90b1dyaXRlID0gMDtcXG4gICAgICAgIGNvbnNvbGUubG9nKFwiSW5zdHJ1Y2Npb246IFwiLCBpbnN0TWF0Y2gpO1xcbiAgICAgICAgY29uc3QgY3VycmVudF9pbnMgPSBpbnN0cnVjdGlvbnMuZmluZEluZGV4KGluc24gPT4gKCBcXCcweFxcJyArIChpbnNuLkFkZHJlc3Muc2xpY2UoMikpLnBhZFN0YXJ0KDE2LCBcXCcwXFwnKSkgPT09IChcIjB4XCIraW5zdE1hdGNoWzNdLnRvTG93ZXJDYXNlKCkpKTtcXG4gICAgICAgIGlmIChjdXJyZW50X2lucyAhPT0gLTEpIHtcXG4gICAgICAgIGlmKHByZXZfYWRkX3RvX2p1bXAgIT09IHVuZGVmaW5lZCl7XFxuICAgICAgICAgIGluc3RydWN0aW9uc1twcmV2X2FkZF90b19qdW1wXS5fcm93VmFyaWFudCA9IFwiXCI7XFxuICAgICAgICAgIHByZXZfYWRkX3RvX2p1bXAgPSB1bmRlZmluZWQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoaW5zdHJ1Y3Rpb25zW2N1cnJlbnRfaW5zXS5sb2FkZWQuaW5jbHVkZXMoXCJqYWxyXCIpKXtcXG4gICAgICAgICAgdmFyIG5leHRfYWRkID0gaW5zdHJ1Y3Rpb25zW2N1cnJlbnRfaW5zXS5sb2FkZWQuc3BsaXQoXCJcXFxcdFwiKTtcXG4gICAgICAgICAgdmFyIG1hdGNoID0gbmV4dF9hZGRbMV0ubWF0Y2goLygtP1xcXFxkKylcXFxcKChcXFxcdyspXFxcXCkvKTtcXG5cXG4gICAgICAgICAgaWYgKG1hdGNoID09PSB1bmRlZmluZWQgfHwgbWF0Y2ggPT09IG51bGwpIHtcXG4gICAgICAgICAgICBtYXRjaCA9IFwiemVyb1wiO1xcbiAgICAgICAgICAgIHZhciBhdXhfcmVnID0gY3JleF9maW5kUmVnKG1hdGNoKTtcXG4gICAgICAgICAgICB2YXIgYXV4X3ZhbCA9IHJlYWRSZWdpc3RlcihhdXhfcmVnLmluZGV4Q29tcCwgYXV4X3JlZy5pbmRleEVsZW0pO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIG5leHRfYWRkX3RvX2p1bXAgPSBhdXhfdmFsLnRvU3RyaW5nKDE2KTtcXG4gICAgICAgICAgICBuZXh0X2FkZF90b19qdW1wID0gaW5zdHJ1Y3Rpb25zLmZpbmRJbmRleChpbnNuID0+IGluc24uQWRkcmVzcyA9PT0gKFwiMHhcIituZXh0X2FkZF90b19qdW1wLnRvTG93ZXJDYXNlKCkpKTtcXG4gICAgICAgICAgICBwcmV2X2FkZF90b19qdW1wID0gY3VycmVudF9pbnM7XFxuICAgICAgICAgIH1lbHNlIHtcXG4gICAgICAgICAgICB2YXIgYXV4X3JlZyA9IGNyZXhfZmluZFJlZyhtYXRjaFsyXSk7XFxuICAgICAgICAgICAgdmFyIGF1eF92YWwgPSByZWFkUmVnaXN0ZXIoYXV4X3JlZy5pbmRleENvbXAsIGF1eF9yZWcuaW5kZXhFbGVtKTtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBuZXh0X2FkZF90b19qdW1wID0gKGF1eF92YWwgKyBCaWdJbnQocGFyc2VJbnQobWF0Y2hbMV0sIDEwKSkpLnRvU3RyaW5nKDE2KTtcXG4gICAgICAgICAgICBuZXh0X2FkZF90b19qdW1wID0gaW5zdHJ1Y3Rpb25zLmZpbmRJbmRleChpbnNuID0+IGluc24uQWRkcmVzcyA9PT0gKFwiMHhcIituZXh0X2FkZF90b19qdW1wLnRvTG93ZXJDYXNlKCkpKTtcXG4gICAgICAgICAgICBwcmV2X2FkZF90b19qdW1wID0gY3VycmVudF9pbnM7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgLy8gY3JlYXRvcl9jYWxsc3RhY2tfZW50ZXIoaW5zdHJ1Y3Rpb25zW25leHRfYWRkX3RvX2p1bXBdLkxhYmVsKTsgXFxuICAgICAgICAgIC8vIHRyYWNrX3N0YWNrX2VudGVyKGluc3RydWN0aW9uc1tuZXh0X2FkZF90b19qdW1wXS5MYWJlbCk7XFxuICAgICAgICAgIC8vIGNhbGxzdGFja19jb252ZW50aW9uLnB1c2goc3RydWN0dXJlZENsb25lKHJlZ2lzdGVyc19iZWZvcmVfZnVuY3Rpb24pKTtcXG4gICAgICAgICAgLy8gaW5zaWRlX2Z1bmN0aW9uID0gdHJ1ZTtcXG5cXG4gICAgICAgICAgY29uc29sZS5sb2coXCJTaWd1aWVudGUgZGlyZWNjaW9uIGRlbCBqYWxyOiBcIiwgbmV4dF9hZGQpO1xcbiAgICAgICAgfSBcXG4gICAgICAgIGlmIChpbnN0cnVjdGlvbnNbY3VycmVudF9pbnNdLmxvYWRlZC5pbmNsdWRlcyhcImphbFwiKSAmJiAhaW5zdHJ1Y3Rpb25zW2N1cnJlbnRfaW5zXS5sb2FkZWQuaW5jbHVkZXMoXCJqYWxyXCIpKXtcXG4gICAgICAgICAgdmFyIG5leHRfYWRkID0gaW5zdHJ1Y3Rpb25zW2N1cnJlbnRfaW5zXS5sb2FkZWQuc3BsaXQoXCJcXFxcdFwiKTtcXG4gICAgICAgICAgY29uc29sZS5sb2coXCJTaWd1aWVudGUgZGlyZWNjaW9uIGRlbCBqYWw6IFwiLCBuZXh0X2FkZCk7XFxuXFxuICAgICAgICB9IFxcbiAgICAgICAgaWYgKGluc3RydWN0aW9uc1tjdXJyZW50X2luc10ubG9hZGVkLmluY2x1ZGVzKFwicmV0XCIpICYmICFpbnN0cnVjdGlvbnNbY3VycmVudF9pbnNdLmxvYWRlZC5pbmNsdWRlcyhcIm1yZXRcIikpe1xcbiAgICAgICAgICAvLyBNaXJhciBlbCByYVxcbiAgICAgICAgICB2YXIgYXV4X3JlZyA9IGNyZXhfZmluZFJlZyhcInJhXCIpO1xcbiAgICAgICAgICBuZXh0X2FkZF90b19qdW1wID0gcmVhZFJlZ2lzdGVyKGF1eF9yZWcuaW5kZXhDb21wLCBhdXhfcmVnLmluZGV4RWxlbSkudG9TdHJpbmcoMTYpO1xcbiAgICAgICAgICBuZXh0X2FkZF90b19qdW1wID0gaW5zdHJ1Y3Rpb25zLmZpbmRJbmRleChpbnNuID0+ICggXFwnMHhcXCcgKyAoaW5zbi5BZGRyZXNzLnNsaWNlKDIpKSkgPT09IChcIjB4XCIrbmV4dF9hZGRfdG9fanVtcC50b0xvd2VyQ2FzZSgpKSk7XFxuICAgICAgICAgIGlmIChuZXh0X2FkZF90b19qdW1wICE9PSAtMSkge1xcbiAgICAgICAgICAgIHByZXZfYWRkX3RvX2p1bXAgPSBjdXJyZW50X2lucztcXG4gICAgICAgICAgICAvLyB0cmFja19zdGFja19sZWF2ZSgpO1xcbiAgICAgICAgICAgIC8vIGNyZWF0b3JfY2FsbHN0YWNrX2xlYXZlKCk7XFxuICAgICAgICAgICAgLy8gY2FsbHN0YWNrX2NvbnZlbnRpb24ucG9wKCk7XFxuICAgICAgICAgICAgLy8gaW5zaWRlX2Z1bmN0aW9uID0gKGNhbGxzdGFja19jb252ZW50aW9uLmxlbmd0aCA+IDApOyBcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBuZXh0X2FkZF90b19qdW1wID0gdW5kZWZpbmVkO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IFxcbiAgICAgICAgLy8gUHJpbWVybyBjYXNvIGRlIHBhc28gYSBwYXNvXFxuICAgICAgICBpZiAoZG9jdW1lbnQuYXBwLiRkYXRhLmV4ZWN1dGlvbl9tb2RlX3J1biA9PT0gMSl7XFxuICAgICAgICAgIGluc3RydWN0aW9uc1tjdXJyZW50X2luc10uX3Jvd1ZhcmlhbnQgPSBcXCdpbmZvXFwnO1xcbiAgICAgICAgICBpZiAoY3VycmVudF9pbnMgPCBpbnN0cnVjdGlvbnMubGVuZ3RoIC0gMSB8fCBuZXh0X2FkZF90b19qdW1wICE9PSB1bmRlZmluZWQpe1xcbiAgICAgICAgICAgIGluc3RydWN0aW9uc1sobmV4dF9hZGRfdG9fanVtcCAhPT0gdW5kZWZpbmVkKSA/IG5leHRfYWRkX3RvX2p1bXAgOiAoY3VycmVudF9pbnMgKyAxKV0uX3Jvd1ZhcmlhbnQgPSBcXCdzdWNjZXNzXFwnO1xcbiAgICAgICAgICAgIGRvY3VtZW50LmFwcC4kZGF0YS5pc19icmVha3BvaW50ID0gaW5zdHJ1Y3Rpb25zWyhuZXh0X2FkZF90b19qdW1wICE9PSB1bmRlZmluZWQpID8gbmV4dF9hZGRfdG9fanVtcCA6IChjdXJyZW50X2lucyArIDEpXS5CcmVhaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoY3VycmVudF9pbnMgPiAwIHx8IHByZXZfYWRkX3RvX2p1bXAgIT09IHVuZGVmaW5lZClcXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnNbKHByZXZfYWRkX3RvX2p1bXAgIT09IHVuZGVmaW5lZCAmJiBwcmV2X2FkZF90b19qdW1wICE9PSBjdXJyZW50X2lucykgPyBwcmV2X2FkZF90b19qdW1wIDogKChjdXJyZW50X2lucyA+IDApID8gY3VycmVudF9pbnMgLTEgOiAwKV0uX3Jvd1ZhcmlhbnQgPSBcXCdcXCc7XFxuICAgICAgICB9XFxuICAgICAgICAvLyBQYXJhIGVsIGNhc28gZGUgcnVuIHdpdGhvdXQgc3RvcCB5IGxhIHNpZ3VpZW50ZSBpbnN0cnVjY2lvbiBlcyB1biBicmVha3BvaW50XFxuICAgICAgICBlbHNlIGlmIChkb2N1bWVudC5hcHAuJGRhdGEuZXhlY3V0aW9uX21vZGVfcnVuID09PSAwKXtcXG4gICAgICAgICAgLy8gc2UgYWxtYWNlbmEgZWwgZXN0YWRvIGRlIGxhIGluc3RydWNjaW9uIGVuIGNhc28gZGUgcXVlIGhheWEgdW5hIHBhcmFkYSBwb3IgaW5maW5pdHkgbG9vcFxcbiAgICAgICAgICBoaWRlbl9leGVjdXRlZCA9IGN1cnJlbnRfaW5zO1xcbiAgICAgICAgICBpZiAoY3VycmVudF9pbnMgPCBpbnN0cnVjdGlvbnMubGVuZ3RoIC0gMSAgfHwgbmV4dF9hZGRfdG9fanVtcCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgaGlkZW5fbmV4dF9leGVjdXRlID0gKG5leHRfYWRkX3RvX2p1bXAgIT09IHVuZGVmaW5lZCkgPyBuZXh0X2FkZF90b19qdW1wIDogY3VycmVudF9pbnMgKyAxO1xcbiAgICAgICAgICB9IGVsc2UgXFxuICAgICAgICAgICAgaGlkZW5fbmV4dF9leGVjdXRlID0gY3VycmVudF9pbnMgKyAxO1xcblxcblxcbiAgICAgICAgICBpZiAoY3VycmVudF9pbnMgPCBpbnN0cnVjdGlvbnMubGVuZ3RoIC0gMSB8fCBuZXh0X2FkZF90b19qdW1wICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICBkb2N1bWVudC5hcHAuJGRhdGEuaXNfYnJlYWtwb2ludCA9IGluc3RydWN0aW9uc1sobmV4dF9hZGRfdG9fanVtcCAhPT0gdW5kZWZpbmVkKSA/IG5leHRfYWRkX3RvX2p1bXAgOiAoY3VycmVudF9pbnMgKyAxKV0uQnJlYWs7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYoZG9jdW1lbnQuYXBwLiRkYXRhLmlzX2JyZWFrcG9pbnQpe1xcbiAgICAgICAgICAgIGluc3RydWN0aW9uc1tjdXJyZW50X2luc10uX3Jvd1ZhcmlhbnQgPSBcXCdpbmZvXFwnO1xcbiAgICAgICAgICAgIGlmIChjdXJyZW50X2lucyA8IGluc3RydWN0aW9ucy5sZW5ndGggLSAxICB8fCBuZXh0X2FkZF90b19qdW1wICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICAgIGluc3RydWN0aW9uc1sobmV4dF9hZGRfdG9fanVtcCAhPT0gdW5kZWZpbmVkKSA/IG5leHRfYWRkX3RvX2p1bXAgOiAoY3VycmVudF9pbnMgKyAxKV0uX3Jvd1ZhcmlhbnQgPSBcXCdzdWNjZXNzXFwnO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjb3JlRXZlbnRzLmVtaXQoXCJwYXVzZS1leGVjdXRpb25cIik7XFxuICAgICAgICAgIH1lbHNlIHtcXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnNbY3VycmVudF9pbnNdLl9yb3dWYXJpYW50ID0gXFwnXFwnO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChjdXJyZW50X2lucyA+IDAgIHx8IHByZXZfYWRkX3RvX2p1bXAgIT09IHVuZGVmaW5lZClcXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnNbKHByZXZfYWRkX3RvX2p1bXAgIT09IHVuZGVmaW5lZCAmJiBwcmV2X2FkZF90b19qdW1wICE9PSBjdXJyZW50X2lucykgPyBwcmV2X2FkZF90b19qdW1wIDogKChjdXJyZW50X2lucyA+IDApID8gY3VycmVudF9pbnMgLTEgOiAwKV0uX3Jvd1ZhcmlhbnQgPSBcXCdcXCc7XFxuXFxuICAgICAgICB9XFxuICAgICAgICBlbHNlXFxuICAgICAgICAgIGluc3RydWN0aW9uc1tjdXJyZW50X2luc10uX3Jvd1ZhcmlhbnQgPSBcXCdcXCc7XFxuICAgICAgICBcXG4gICAgICAgIGlmIChpbnN0TWF0Y2hbNV0gPT09IFwiZWNhbGxcIil7XFxuICAgICAgICAgIGxldCBhcmd1bWVudF9yZWdpc3RlciA9IGNyZXhfZmluZFJlZyhcImE3XCIpOyAvLyBvYnRlbmVtb3MgZWwgcmVnaXN0cm8gcGFyYSB2ZXIgcXVlIGxsYW1hZGEgYWwgc2lzdGVtYSBlc1xcbiAgICAgICAgICBsZXQgc3lzY2FsbF9jb2RlID0gcmVhZFJlZ2lzdGVyKGFyZ3VtZW50X3JlZ2lzdGVyLmluZGV4Q29tcCwgYXJndW1lbnRfcmVnaXN0ZXIuaW5kZXhFbGVtKTsgLy8gTGVjdHVyYSBkZWwgcmVnaXN0cm8gcGFyYSBvYnRlbmVyIGVsIHZhbG9yXFxuICAgICAgXFxuICAgICAgICAgIHN3aXRjaChzeXNjYWxsX2NvZGUpe1xcbiAgICAgICAgICAgIGNhc2UgNW46XFxuICAgICAgICAgICAgICBpZihkb2N1bWVudC5hcHAuJGRhdGEuZXhlY3V0aW9uX21vZGVfcnVuID09PSAwKXtcXG4gICAgICAgICAgICAgICAgaW5zbl9udW1iZXIgPSBjdXJyZW50X2lucztcXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2N1cnJlbnRfaW5zXS5fcm93VmFyaWFudCA9IFwiaW5mb1wiO1xcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudF9pbnMgPCBpbnN0cnVjdGlvbnMubGVuZ3RoIC0xICB8fCBuZXh0X2FkZF90b19qdW1wICE9PSB1bmRlZmluZWQpXFxuICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zWyhuZXh0X2FkZF90b19qdW1wICE9PSB1bmRlZmluZWQpID8gbmV4dF9hZGRfdG9fanVtcCA6IChjdXJyZW50X2lucyArIDEpXS5fcm93VmFyaWFudCA9IFxcJ3N1Y2Nlc3NcXCc7XFxuICAgICAgICAgICAgICAgICAgLy8gaW5zdHJ1Y3Rpb25zW2N1cnJlbnRfaW5zICsxXS5fcm93VmFyaWFudCA9IFwic3VjY2Vzc1wiO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgZG9jdW1lbnQuYXBwLiRkYXRhLmxhc3RfZXhlY3V0aW9uX21vZGVfcnVuID0gZG9jdW1lbnQuYXBwLiRkYXRhLmV4ZWN1dGlvbl9tb2RlX3J1bjtcXG4gICAgICAgICAgICAgIGRvY3VtZW50LmFwcC4kZGF0YS5leGVjdXRpb25fbW9kZV9ydW4gPSAyO1xcbiAgICAgICAgICAgICAgLy8gbGFzdF9leGVjdXRpb25fbW9kZV9ydW4gPSBkb2N1bWVudC5hcHAuJGRhdGEuZXhlY3V0aW9uX21vZGVfcnVuO1xcbiAgICAgICAgICAgICAgLy8gZG9jdW1lbnQuYXBwLiRkYXRhLmV4ZWN1dGlvbl9tb2RlX3J1biA9IDI7XFxuICAgICAgICAgICAgICAvLyBNYW5lam8gcGFyYSBlbnRlcm9zXFxuICAgICAgICAgICAgICAvLyBjYXBpX3JlYWRfaW50KFxcJ2EwXFwnKTtcXG4gICAgICAgICAgICAgIFNZU0NBTEwucmVhZChcXCdhMFxcJywgXCJpbnRcIik7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICBjYXNlIDZuOlxcbiAgICAgICAgICAgICAgaWYoZG9jdW1lbnQuYXBwLiRkYXRhLmV4ZWN1dGlvbl9tb2RlX3J1biA9PT0gMCl7XFxuICAgICAgICAgICAgICAgIGluc25fbnVtYmVyID0gY3VycmVudF9pbnM7XFxuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uc1tjdXJyZW50X2luc10uX3Jvd1ZhcmlhbnQgPSBcImluZm9cIjtcXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRfaW5zIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aCAtMSB8fCBuZXh0X2FkZF90b19qdW1wICE9PSB1bmRlZmluZWQpXFxuICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zWyhuZXh0X2FkZF90b19qdW1wICE9PSB1bmRlZmluZWQpID8gbmV4dF9hZGRfdG9fanVtcCA6IChjdXJyZW50X2lucyArIDEpXS5fcm93VmFyaWFudCA9IFxcJ3N1Y2Nlc3NcXCc7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgLy8gaW5zdHJ1Y3Rpb25zW2N1cnJlbnRfaW5zICsxXS5fcm93VmFyaWFudCA9IFwic3VjY2Vzc1wiO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgZG9jdW1lbnQuYXBwLiRkYXRhLmxhc3RfZXhlY3V0aW9uX21vZGVfcnVuID0gZG9jdW1lbnQuYXBwLiRkYXRhLmV4ZWN1dGlvbl9tb2RlX3J1bjtcXG4gICAgICAgICAgICAgIGRvY3VtZW50LmFwcC4kZGF0YS5leGVjdXRpb25fbW9kZV9ydW4gPSAyO1xcbiAgICAgICAgICAgICAgLy8gbGFzdF9leGVjdXRpb25fbW9kZV9ydW4gPSBkb2N1bWVudC5hcHAuJGRhdGEuZXhlY3V0aW9uX21vZGVfcnVuO1xcbiAgICAgICAgICAgICAgLy8gZG9jdW1lbnQuYXBwLiRkYXRhLmV4ZWN1dGlvbl9tb2RlX3J1biA9IDI7XFxuICAgICAgICAgICAgICAvLyBNYW5lam8gcGFyYSBmbG9hdHNcXG4gICAgICAgICAgICAgIC8vIGNhcGlfcmVhZF9mbG9hdChcXCdmYTBcXCcpO1xcbiAgICAgICAgICAgICAgU1lTQ0FMTC5yZWFkKFwiZmEwXCIsIFwiZmxvYXRcIik7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICBjYXNlIDduOlxcbiAgICAgICAgICAgICAgaWYoZG9jdW1lbnQuYXBwLiRkYXRhLmV4ZWN1dGlvbl9tb2RlX3J1biA9PT0gMCl7XFxuICAgICAgICAgICAgICAgIGluc25fbnVtYmVyID0gY3VycmVudF9pbnM7XFxuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uc1tjdXJyZW50X2luc10uX3Jvd1ZhcmlhbnQgPSBcImluZm9cIjtcXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRfaW5zIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aCAtMSB8fCBuZXh0X2FkZF90b19qdW1wICE9PSB1bmRlZmluZWQpXFxuICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zWyhuZXh0X2FkZF90b19qdW1wICE9PSB1bmRlZmluZWQpID8gbmV4dF9hZGRfdG9fanVtcCA6IChjdXJyZW50X2lucyArIDEpXS5fcm93VmFyaWFudCA9IFxcJ3N1Y2Nlc3NcXCc7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgLy8gaW5zdHJ1Y3Rpb25zW2N1cnJlbnRfaW5zICsxXS5fcm93VmFyaWFudCA9IFwic3VjY2Vzc1wiO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgZG9jdW1lbnQuYXBwLiRkYXRhLmxhc3RfZXhlY3V0aW9uX21vZGVfcnVuID0gZG9jdW1lbnQuYXBwLiRkYXRhLmV4ZWN1dGlvbl9tb2RlX3J1bjtcXG4gICAgICAgICAgICAgIGRvY3VtZW50LmFwcC4kZGF0YS5leGVjdXRpb25fbW9kZV9ydW4gPSAyO1xcbiAgICAgICAgICAgICAgLy8gTWFuZWpvIHBhcmEgZG91YmxlXFxuICAgICAgICAgICAgICAvLyBjYXBpX3JlYWRfZG91YmxlKFxcJ2ZhMFxcJyk7XFxuICAgICAgICAgICAgICBTWVNDQUxMLnJlYWQoXCJmYTBcIiwgXCJkb3VibGVcIik7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICBjYXNlIDhuOlxcbiAgICAgICAgICAgICAgaWYoZG9jdW1lbnQuYXBwLiRkYXRhLmV4ZWN1dGlvbl9tb2RlX3J1biA9PT0gMCl7XFxuICAgICAgICAgICAgICAgIGluc25fbnVtYmVyID0gY3VycmVudF9pbnM7XFxuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uc1tjdXJyZW50X2luc10uX3Jvd1ZhcmlhbnQgPSBcImluZm9cIjtcXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRfaW5zIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aCAtMSB8fCBuZXh0X2FkZF90b19qdW1wICE9PSB1bmRlZmluZWQpXFxuICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zWyhuZXh0X2FkZF90b19qdW1wICE9PSB1bmRlZmluZWQpID8gbmV4dF9hZGRfdG9fanVtcCA6IChjdXJyZW50X2lucyArIDEpXS5fcm93VmFyaWFudCA9IFxcJ3N1Y2Nlc3NcXCc7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgLy8gaW5zdHJ1Y3Rpb25zW2N1cnJlbnRfaW5zICsxXS5fcm93VmFyaWFudCA9IFwic3VjY2Vzc1wiO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgZG9jdW1lbnQuYXBwLiRkYXRhLmxhc3RfZXhlY3V0aW9uX21vZGVfcnVuID0gZG9jdW1lbnQuYXBwLiRkYXRhLmV4ZWN1dGlvbl9tb2RlX3J1bjtcXG4gICAgICAgICAgICAgIGRvY3VtZW50LmFwcC4kZGF0YS5leGVjdXRpb25fbW9kZV9ydW4gPSAyO1xcbiAgICAgICAgICAgICAgLy8gTWFuZWpvIHBhcmEgc3RyaW5nc1xcbiAgICAgICAgICAgICAgLy8gY2FwaV9yZWFkX3N0cmluZyhcXCdhMFxcJyxcXCdhMVxcJyk7XFxuICAgICAgICAgICAgICBTWVNDQUxMLnJlYWQoXCJhMFwiLCBcInN0cmluZ1wiLCBcImExXCIpO1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgXFxuICAgICAgICAgICAgY2FzZSAxMm46XFxuICAgICAgICAgICAgICBpZihkb2N1bWVudC5hcHAuJGRhdGEuZXhlY3V0aW9uX21vZGVfcnVuID09PSAwKXtcXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2N1cnJlbnRfaW5zXS5fcm93VmFyaWFudCA9IFwiaW5mb1wiO1xcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudF9pbnMgPCBpbnN0cnVjdGlvbnMubGVuZ3RoIC0xIHx8IG5leHRfYWRkX3RvX2p1bXAgIT09IHVuZGVmaW5lZClcXG4gICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnNbKG5leHRfYWRkX3RvX2p1bXAgIT09IHVuZGVmaW5lZCkgPyBuZXh0X2FkZF90b19qdW1wIDogKGN1cnJlbnRfaW5zICsgMSldLl9yb3dWYXJpYW50ID0gXFwnc3VjY2Vzc1xcJztcXG4gICAgICAgICAgICAgICAgICAvLyBpbnN0cnVjdGlvbnNbY3VycmVudF9pbnMgKzFdLl9yb3dWYXJpYW50ID0gXCJzdWNjZXNzXCI7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBkb2N1bWVudC5hcHAuJGRhdGEubGFzdF9leGVjdXRpb25fbW9kZV9ydW4gPSBkb2N1bWVudC5hcHAuJGRhdGEuZXhlY3V0aW9uX21vZGVfcnVuO1xcbiAgICAgICAgICAgICAgZG9jdW1lbnQuYXBwLiRkYXRhLmV4ZWN1dGlvbl9tb2RlX3J1biA9IDI7XFxuICAgICAgICAgICAgICAvLyBsYXN0X2V4ZWN1dGlvbl9tb2RlX3J1biA9IGRvY3VtZW50LmFwcC4kZGF0YS5leGVjdXRpb25fbW9kZV9ydW47XFxuICAgICAgICAgICAgICAvLyBkb2N1bWVudC5hcHAuJGRhdGEuZXhlY3V0aW9uX21vZGVfcnVuID0gMjtcXG4gICAgICAgICAgICAgIC8vIE1hbmVqbyBwYXJhIGNoYXJcXG4gICAgICAgICAgICAgIC8vIGNhcGlfcmVhZF9jaGFyKFxcJ2EwXFwnKTtcXG4gICAgICAgICAgICAgIFNZU0NBTEwucmVhZChcImEwXCIsIFwiY2hhclwiKTtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIk5vIGhhZ28gbmFkYS5cIik7XFxuICAgICAgICAgICAgICBzeXNjYWxsX3ByaW50X2NvZGUgPSBzeXNjYWxsX2NvZGU7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgfVxcbiAgICAgIFxcbiAgICAgICAgICBuZXh0X2FkZF90b19qdW1wID0gdW5kZWZpbmVkO1xcbiAgICAgICAgfVxcblxcblxcblxcbiAgICAgICAgaW5zdG9wZXIgPSBpbnN0TWF0Y2hbNV07XFxuXFxuICAgICAgfVxcblxcbiAgICAgIH0gZWxzZSBpZiAoaW5zdE1hdGNoICYmIChwYXJzZUludChpbnN0TWF0Y2hbM10sIDE2KSA8PSBwY19taW4gfHwgcGFyc2VJbnQoaW5zdE1hdGNoWzNdLCAxNikgPj0gcGNfbWF4ICkpXFxuICAgICAgICB1c2VyTW9kZTY0ID0gZmFsc2U7XFxuXFxuXFxuICAgICAgaWYgKHJlZ2lNYXRjaCAvKiYmIHVzZXJNb2RlID09PSB0cnVlKi8pIHtcXG4gICAgICAgIC8vIEVuIGNhc28gZGUgc2VyIGVzY3JpdHVyYSBcXCc8LVxcJyBwaW50YW1vcyBlbCB2YWxvciBlbiBlbCByZWdpc3RybyBxdWUgY29ycmVzcG9uZGVcXG4gICAgICAgIGlmIChyZWdpTWF0Y2hbMl0gPT09IFxcJzwtXFwnKXtcXG4gICAgICAgICAgbGV0IHJlZ3Rvd3JpdGUgPSBjcmV4X2ZpbmRSZWcocmVnaU1hdGNoWzFdKTtcXG4gICAgICAgICAgaWYgKHJlZ3Rvd3JpdGUuaW5kZXhDb21wID09PSAyKXtcXG4gICAgICAgICAgICBpZiAocmVnaU1hdGNoWzNdLnN0YXJ0c1dpdGgoXCIweFwiKSkgcmVnaU1hdGNoWzNdID0gcmVnaU1hdGNoWzNdLnNsaWNlKDIpLnJlcGxhY2UoL14wKy8sIFxcJ1xcJyk7XFxuICAgICAgICAgICAgZWxzZSByZWdpTWF0Y2hbM10gPSByZWdpTWF0Y2hbM10ucmVwbGFjZSgvXjArLywgXFwnXFwnKTtcXG4gICAgICAgICAgICBpZiAocmVnaU1hdGNoWzNdLmxlbmd0aCA8PSA4KXtcXG4gICAgICAgICAgICAgIHJlZ2lNYXRjaFszXSA9IHJlZ2lNYXRjaFszXS5wYWRTdGFydCg4LCBcIjBcIik7XFxuICAgICAgICAgICAgICB3cml0ZVJlZ2lzdGVyKEJpZ0ludChcIjB4XCIgKyByZWdpTWF0Y2hbM10pLCByZWd0b3dyaXRlLmluZGV4Q29tcCwgcmVndG93cml0ZS5pbmRleEVsZW0sIFwiU0ZQLVJlZ1wiKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZXtcXG4gICAgICAgICAgICAgIC8vIGlmICh0eXBlX3RvV3JpdGUgPT09IDMyKXtcXG4gICAgICAgICAgICAgIC8vICAgcmVnaU1hdGNoWzNdID0gcmVnaU1hdGNoWzNdLnNsaWNlKDgsMTYpO1xcbiAgICAgICAgICAgICAgLy8gICB3cml0ZVJlZ2lzdGVyKGhleDJmbG9hdChyZWdpTWF0Y2hbM10pLCByZWd0b3dyaXRlLmluZGV4Q29tcCwgcmVndG93cml0ZS5pbmRleEVsZW0sIFwiU0ZQLVJlZ1wiKTtcXG4gICAgICAgICAgICAgIC8vIH1cXG4gICAgICAgICAgICAgIC8vIGVsc2UgaWYgKHR5cGVfdG9Xcml0ZSA9PT0gNjQpXFxuICAgICAgICAgICAgICAvLyAgIHdyaXRlUmVnaXN0ZXIoaGV4MmRvdWJsZShyZWdpTWF0Y2hbM10pLCByZWd0b3dyaXRlLmluZGV4Q29tcCwgcmVndG93cml0ZS5pbmRleEVsZW0sIFwiREZQLVJlZ1wiKTtcXG4gICAgICAgICAgICAgIC8vIGVsc2UgXFxuICAgICAgICAgICAgICAgIHdyaXRlUmVnaXN0ZXIoQmlnSW50KFwiMHhcIiArIHJlZ2lNYXRjaFszXSksIHJlZ3Rvd3JpdGUuaW5kZXhDb21wLCByZWd0b3dyaXRlLmluZGV4RWxlbSwgXCJERlAtUmVnXCIpO1xcbiAgICAgICAgICAgICAgLy8gdHlwZV90b193cml0ZSA9IDA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIGVsc2UgIFxcbiAgICAgICAgICAgIHdyaXRlUmVnaXN0ZXIoQmlnSW50KHBhcnNlSW50KHJlZ2lNYXRjaFszXSwgMTYpKSwgcmVndG93cml0ZS5pbmRleENvbXAsIHJlZ3Rvd3JpdGUuaW5kZXhFbGVtKTtcXG4gICAgICAgIH1cXG4gICAgICAgIFxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAobWVtb01hdGNoIC8qJiYgdXNlck1vZGUgPT09IHRydWUqLykge1xcbiAgICAgICAgLy8gRW4gY2FzbyBkZSBzZXIgZXNjcml0dXJhIFxcJzwtXFwnIHBpbnRhbW9zIGVsIHZhbG9yIGVuIGxhIHBvc2ljaW9uIGRlIG1lbW9yaWFcXG4gICAgICAgIGlmIChtZW1vTWF0Y2hbMl0gPT09IFxcJzwtXFwnKXtcXG5cXG4gICAgICAgICAgd3JpdGVNZW1vcnkobWVtb01hdGNoWzNdLCBCaWdJbnQocGFyc2VJbnQobWVtb01hdGNoWzFdLCAxNikpKTtcXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coXCJPcGVyYWRvcjogXCIsIGluc3RvcGVyKTtcXG4gICAgICAgICAgLy8gc3dpdGNoKGluc3RvcGVyKXtcXG4gICAgICAgICAgLy8gICBjYXNlIFxcJ3NoXFwnOiAvLyBQYXJhIGFsbWFjZW5hciB1biBoYWxmXFxuICAgICAgICAgIC8vIHdyaXRlTWVtb3J5KG1lbW9NYXRjaFszXSwgcGFyc2VJbnQobWVtb01hdGNoWzFdLCAxNiksIFxcJ2hhbGZcXCcpO1xcbiAgICAgICAgICAgICAgXFxuICAgICAgICAgIC8vICAgYnJlYWs7XFxuICAgICAgICAgIC8vICAgY2FzZSBcXCdzYlxcJzogLy8gUGFyYSBhbG1hY2VuYXIgdW4gYnl0ZVxcbiAgICAgICAgICAvLyAgICAgd3JpdGVNZW1vcnkobWVtb01hdGNoWzNdLCBwYXJzZUludChtZW1vTWF0Y2hbMV0sIDE2KSwgXFwnYnl0ZVxcJyk7XFxuICAgICAgICAgIC8vICAgYnJlYWs7XFxuICAgICAgICAgIC8vICAgY2FzZSBcXCdzZFxcJzpcXG4gICAgICAgICAgLy8gICAgIHdyaXRlTWVtb3J5KG1lbW9NYXRjaFszXSwgcGFyc2VJbnQobWVtb01hdGNoWzFdLCAxNiksIFxcJ2R3b3JkXFwnKTtcXG4gICAgICAgICAgLy8gICBicmVhaztcXG4gICAgICAgICAgLy8gICBjYXNlIFxcJ3N3XFwnOiAvLyBQYXJhIGFsbWFjZW5hciB1biBpbnQvd29yZFxcbiAgICAgICAgICAvLyAgICAgd3JpdGVNZW1vcnkobWVtb01hdGNoWzNdLCBwYXJzZUludChtZW1vTWF0Y2hbMV0sIDE2KSwgXFwnd29yZFxcJyk7XFxuICAgICAgICAgIC8vICAgYnJlYWs7XFxuICAgICAgICAgIC8vICAgY2FzZSBcXCdmc3dcXCc6IC8vIFBhcmEgYWxtYWNlbmFyIHVuIGZsb2F0XFxuICAgICAgICAgIC8vICAgICB3cml0ZU1lbW9yeShtZW1vTWF0Y2hbM10sIHBhcnNlSW50KG1lbW9NYXRjaFsxXSwgMTYpLCBcXCdmbG9hdFxcJyk7XFxuICAgICAgICAgIC8vICAgYnJlYWs7XFxuICAgICAgICAgIC8vICAgY2FzZSBcXCdmc2RcXCc6IC8vIFBhcmEgYWxtYWNlbmFyIHVuIGRvdWJsZVxcbiAgICAgICAgICAvLyAgICAgd3JpdGVNZW1vcnkobWVtb01hdGNoWzNdLCBwYXJzZUludChtZW1vTWF0Y2hbMV0sIDE2KSwgXFwnZG91YmxlXFwnKTtcXG4gICAgICAgICAgLy8gICBicmVhaztcXG4gICAgICAgICAgLy8gICBjYXNlIFxcJ3ZzZTgudlxcJzpcXG4gICAgICAgICAgLy8gICAgIHdyaXRlTWVtb3J5KG1lbW9NYXRjaFszXSwgcGFyc2VJbnQobWVtb01hdGNoWzFdLCAxNiksIFxcJ2J5dGVcXCcpO1xcbiAgICAgICAgICAvLyAgICAgYnJlYWs7XFxuICAgICAgICAgIC8vICAgY2FzZSBcXCd2c2UxNi52XFwnOlxcbiAgICAgICAgICAvLyAgICAgd3JpdGVNZW1vcnkobWVtb01hdGNoWzNdLCBwYXJzZUludChtZW1vTWF0Y2hbMV0sIDE2KSwgXFwnaGFsZlxcJyk7XFxuICAgICAgICAgIC8vICAgICBicmVhaztcXG4gICAgICAgICAgLy8gICBjYXNlIFxcJ3ZzZTMyLnZcXCc6XFxuICAgICAgICAgIC8vICAgICB3cml0ZU1lbW9yeShtZW1vTWF0Y2hbM10sIHBhcnNlSW50KG1lbW9NYXRjaFsxXSwgMTYpLCBcXCd3b3JkXFwnKTtcXG4gICAgICAgICAgLy8gICAgIGJyZWFrO1xcbiAgICAgICAgICAvLyAgIGNhc2UgXFwndnNlNjQudlxcJzpcXG4gICAgICAgICAgLy8gICAgIHdyaXRlTWVtb3J5KG1lbW9NYXRjaFszXSwgcGFyc2VJbnQobWVtb01hdGNoWzFdLCAxNiksIFxcJ2RvdWJsZVxcJyk7XFxuICAgICAgICAgIC8vICAgICBicmVhaztcXG4gICAgICAgICAgLy8gICBkZWZhdWx0OlxcbiAgICAgICAgICAvLyAgICAgYnJlYWs7XFxuICAgICAgICAgIC8vIH1cXG5cXG4gICAgICAgICAgLy8gaW5zdG9wZXIgPSBcIlwiO1xcbiAgICAgICAgfVxcbiAgICAgIFxcbiAgICAgIH1cXG5cXG4gICAgICBcXG5cXG4gICAgICBpZihwcmludE1hdGNoICYmIHN5c2NhbGxfcHJpbnRfY29kZSAhPT0gLTEpe1xcblxcbiAgICAgICAgbGV0IHZhbHVlXzJfcHJpbnQgPSBwcmludE1hdGNoWzJdLnRyaW0oKTtcXG4gICAgICAgIGNvbnNvbGUubG9nKFwiRXN0b3kgZGVudHJvIGRlIGVjYWxsIGEgaW1wcmltaXJcIik7XFxuICAgICAgICAvLyBjb25zb2xlLmxvZyhtZXNzYWdlKTtcXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVmFsb3IgYSBpbXByaW1pcjogXCIsIHZhbHVlXzJfcHJpbnQpOyBcXG4gICAgICAgIHN3aXRjaChzeXNjYWxsX3ByaW50X2NvZGUpe1xcblxcbiAgICAgICAgICBjYXNlIDFuOiAvLyBQcmludCBpbnRcXG4gICAgICAgICAgICAvLyBTWVNDQUxMLnByaW50KE51bWJlcihwYXJzZUludCh2YWx1ZV8yX3ByaW50KSksIFwiaW50MzJcIik7XFxuXFxuICAgICAgICAgICAgZGlzcGxheV9wcmludCh2YWx1ZV8yX3ByaW50KTtcXG4gICAgICAgICAgICAvLyBkaXNwbGF5X3ByaW50KGZ1bGxfcHJpbnQocGFyc2VJbnQodmFsdWVfMl9wcmludCksIG51bGwsIGZhbHNlKSk7XFxuICAgICAgICAgICAgc3lzY2FsbF9wcmludF9jb2RlID0gLTE7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIGNhc2UgMm46IC8vIFByaW50IGZsb2F0XFxuICAgICAgICAgICAgLy8gU1lTQ0FMTC5wcmludChOdW1iZXIocGFyc2VGbG9hdCh2YWx1ZV8yX3ByaW50KSksIFwiZmxvYXRcIik7XFxuICAgICAgICAgICAgZGlzcGxheV9wcmludCh2YWx1ZV8yX3ByaW50KTtcXG4gICAgICAgICAgICAvLyBkaXNwbGF5X3ByaW50KGZ1bGxfcHJpbnQocGFyc2VGbG9hdCh2YWx1ZV8yX3ByaW50KSwgMCwgdHJ1ZSkpO1xcbiAgICAgICAgICAgIHN5c2NhbGxfcHJpbnRfY29kZSA9IC0xO1xcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBjYXNlIDNuOiAvLyBQcmludCBkb3VibGVcXG4gICAgICAgICAgICAvLyBTWVNDQUxMLnByaW50KE51bWJlcihwYXJzZUZsb2F0KHZhbHVlXzJfcHJpbnQpKSwgXCJkb3VibGVcIik7XFxuICAgICAgICAgICAgZGlzcGxheV9wcmludCh2YWx1ZV8yX3ByaW50KTtcXG4gICAgICAgICAgICAvLyBkaXNwbGF5X3ByaW50KGZ1bGxfcHJpbnQocGFyc2VGbG9hdCh2YWx1ZV8yX3ByaW50KSwgMCwgdHJ1ZSkpO1xcbiAgICAgICAgICAgIHN5c2NhbGxfcHJpbnRfY29kZSA9IC0xO1xcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBjYXNlIDRuOiAvLyBQcmludCBTdHJpbmcgXFxuICAgICAgICAgICAgZGlzcGxheV9wcmludCh2YWx1ZV8yX3ByaW50KTtcXG4gICAgICAgICAgICBzeXNjYWxsX3ByaW50X2NvZGUgPSAtMTtcXG4gICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgY2FzZSAxMW46IC8vIFByaW50IGNoYXJcXG4gICAgICAgICAgICAvLyBTWVNDQUxMLnByaW50KEJpZ0ludCh2YWx1ZV8yX3ByaW50LmNoYXJDb2RlQXQoMCkpLCBjaGFyKTtcXG4gICAgICAgICAgICBkaXNwbGF5X3ByaW50KHZhbHVlXzJfcHJpbnQpO1xcbiAgICAgICAgICAgIHN5c2NhbGxfcHJpbnRfY29kZSA9IC0xO1xcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBkZWZhdWx0OiAvLyBSZXN0IG9mIHN5c2NhbGwgY29kZXMgbm90IGFibGUgdG8gcHJpbnRcXG4gICAgICAgICAgc3lzY2FsbF9wcmludF9jb2RlID0gLTE7XFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICB9XFxuXFxuICAgICAgfVxcblxcblxcblxcbiAgICAgIC8vIGlmICghbm9fcHJpbnRfbW9yZSlcXG4gICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xcblxcbiAgICB9XFxuXFxuICAgIE1vZHVsZVtcXCdwcmludEVyclxcJ10gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xcbiAgICAgIC8vIGlmIChtZXNzYWdlLmluY2x1ZGVzKFwiRXhlY3V0aW9uOlwiKSB8fCBtZXNzYWdlLmluY2x1ZGVzKFwiSW5zdHJ1Y3Rpb25zOlwiKSB8fCBtZXNzYWdlLmluY2x1ZGVzKFwiUGVyZjpcIikpXFxuICAgICAgLy8gICBzaG93X25vdGlmaWNhdGlvbihtZXNzYWdlLCBcInN1Y2Nlc3NcIik7XFxuICAgICAgLy8gZWxzZSBcXG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XFxuICAgIH1cXG5cXG5cXG4gICAgdmFyIG91dCA9IE1vZHVsZVtcInByaW50XCJdIC8qfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKSovO1xcbiAgICB2YXIgZXJyID0gTW9kdWxlW1wicHJpbnRFcnJcIl0gLyp8fCBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSkqLztcXG5cXG5cXG4gICAgT2JqZWN0LmFzc2lnbihNb2R1bGUsIG1vZHVsZU92ZXJyaWRlcyk7XFxuICAgIG1vZHVsZU92ZXJyaWRlcyA9IG51bGw7XFxuICAgIGNoZWNrSW5jb21pbmdNb2R1bGVBUEkoKTtcXG4gICAgaWYgKE1vZHVsZVtcImFyZ3VtZW50c1wiXSkgYXJndW1lbnRzXyA9IE1vZHVsZVtcImFyZ3VtZW50c1wiXTtcXG4gICAgbGVnYWN5TW9kdWxlUHJvcChcImFyZ3VtZW50c1wiLCBcImFyZ3VtZW50c19cIik7XFxuICAgIGlmIChNb2R1bGVbXCJ0aGlzUHJvZ3JhbVwiXSkgdGhpc1Byb2dyYW0gPSBNb2R1bGVbXCJ0aGlzUHJvZ3JhbVwiXTtcXG4gICAgbGVnYWN5TW9kdWxlUHJvcChcInRoaXNQcm9ncmFtXCIsIFwidGhpc1Byb2dyYW1cIik7XFxuICAgIGFzc2VydChcXG4gICAgICB0eXBlb2YgTW9kdWxlW1wibWVtb3J5SW5pdGlhbGl6ZXJQcmVmaXhVUkxcIl0gPT0gXCJ1bmRlZmluZWRcIixcXG4gICAgICBcIk1vZHVsZS5tZW1vcnlJbml0aWFsaXplclByZWZpeFVSTCBvcHRpb24gd2FzIHJlbW92ZWQsIHVzZSBNb2R1bGUubG9jYXRlRmlsZSBpbnN0ZWFkXCIsXFxuICAgICk7XFxuICAgIGFzc2VydChcXG4gICAgICB0eXBlb2YgTW9kdWxlW1wicHRocmVhZE1haW5QcmVmaXhVUkxcIl0gPT0gXCJ1bmRlZmluZWRcIixcXG4gICAgICBcIk1vZHVsZS5wdGhyZWFkTWFpblByZWZpeFVSTCBvcHRpb24gd2FzIHJlbW92ZWQsIHVzZSBNb2R1bGUubG9jYXRlRmlsZSBpbnN0ZWFkXCIsXFxuICAgICk7XFxuICAgIGFzc2VydChcXG4gICAgICB0eXBlb2YgTW9kdWxlW1wiY2RJbml0aWFsaXplclByZWZpeFVSTFwiXSA9PSBcInVuZGVmaW5lZFwiLFxcbiAgICAgIFwiTW9kdWxlLmNkSW5pdGlhbGl6ZXJQcmVmaXhVUkwgb3B0aW9uIHdhcyByZW1vdmVkLCB1c2UgTW9kdWxlLmxvY2F0ZUZpbGUgaW5zdGVhZFwiLFxcbiAgICApO1xcbiAgICBhc3NlcnQoXFxuICAgICAgdHlwZW9mIE1vZHVsZVtcImZpbGVQYWNrYWdlUHJlZml4VVJMXCJdID09IFwidW5kZWZpbmVkXCIsXFxuICAgICAgXCJNb2R1bGUuZmlsZVBhY2thZ2VQcmVmaXhVUkwgb3B0aW9uIHdhcyByZW1vdmVkLCB1c2UgTW9kdWxlLmxvY2F0ZUZpbGUgaW5zdGVhZFwiLFxcbiAgICApO1xcbiAgICBhc3NlcnQoXFxuICAgICAgdHlwZW9mIE1vZHVsZVtcInJlYWRcIl0gPT0gXCJ1bmRlZmluZWRcIixcXG4gICAgICBcIk1vZHVsZS5yZWFkIG9wdGlvbiB3YXMgcmVtb3ZlZFwiLFxcbiAgICApO1xcbiAgICBhc3NlcnQoXFxuICAgICAgdHlwZW9mIE1vZHVsZVtcInJlYWRBc3luY1wiXSA9PSBcInVuZGVmaW5lZFwiLFxcbiAgICAgIFwiTW9kdWxlLnJlYWRBc3luYyBvcHRpb24gd2FzIHJlbW92ZWQgKG1vZGlmeSByZWFkQXN5bmMgaW4gSlMpXCIsXFxuICAgICk7XFxuICAgIGFzc2VydChcXG4gICAgICB0eXBlb2YgTW9kdWxlW1wicmVhZEJpbmFyeVwiXSA9PSBcInVuZGVmaW5lZFwiLFxcbiAgICAgIFwiTW9kdWxlLnJlYWRCaW5hcnkgb3B0aW9uIHdhcyByZW1vdmVkIChtb2RpZnkgcmVhZEJpbmFyeSBpbiBKUylcIixcXG4gICAgKTtcXG4gICAgYXNzZXJ0KFxcbiAgICAgIHR5cGVvZiBNb2R1bGVbXCJzZXRXaW5kb3dUaXRsZVwiXSA9PSBcInVuZGVmaW5lZFwiLFxcbiAgICAgIFwiTW9kdWxlLnNldFdpbmRvd1RpdGxlIG9wdGlvbiB3YXMgcmVtb3ZlZCAobW9kaWZ5IGVtc2NyaXB0ZW5fc2V0X3dpbmRvd190aXRsZSBpbiBKUylcIixcXG4gICAgKTtcXG4gICAgYXNzZXJ0KFxcbiAgICAgIHR5cGVvZiBNb2R1bGVbXCJUT1RBTF9NRU1PUllcIl0gPT0gXCJ1bmRlZmluZWRcIixcXG4gICAgICBcIk1vZHVsZS5UT1RBTF9NRU1PUlkgaGFzIGJlZW4gcmVuYW1lZCBNb2R1bGUuSU5JVElBTF9NRU1PUllcIixcXG4gICAgKTtcXG4gICAgbGVnYWN5TW9kdWxlUHJvcChcImFzbVwiLCBcIndhc21FeHBvcnRzXCIpO1xcbiAgICBsZWdhY3lNb2R1bGVQcm9wKFwicmVhZEFzeW5jXCIsIFwicmVhZEFzeW5jXCIpO1xcbiAgICBsZWdhY3lNb2R1bGVQcm9wKFwicmVhZEJpbmFyeVwiLCBcInJlYWRCaW5hcnlcIik7XFxuICAgIGxlZ2FjeU1vZHVsZVByb3AoXCJzZXRXaW5kb3dUaXRsZVwiLCBcInNldFdpbmRvd1RpdGxlXCIpO1xcbiAgICBhc3NlcnQoXFxuICAgICAgIUVOVklST05NRU5UX0lTX1dPUktFUixcXG4gICAgICBcIndvcmtlciBlbnZpcm9ubWVudCBkZXRlY3RlZCBidXQgbm90IGVuYWJsZWQgYXQgYnVpbGQgdGltZS4gIEFkZCBgd29ya2VyYCB0byBgLXNFTlZJUk9OTUVOVGAgdG8gZW5hYmxlLlwiLFxcbiAgICApO1xcbiAgICBhc3NlcnQoXFxuICAgICAgIUVOVklST05NRU5UX0lTX05PREUsXFxuICAgICAgXCJub2RlIGVudmlyb25tZW50IGRldGVjdGVkIGJ1dCBub3QgZW5hYmxlZCBhdCBidWlsZCB0aW1lLiAgQWRkIGBub2RlYCB0byBgLXNFTlZJUk9OTUVOVGAgdG8gZW5hYmxlLlwiLFxcbiAgICApO1xcbiAgICBhc3NlcnQoXFxuICAgICAgIUVOVklST05NRU5UX0lTX1NIRUxMLFxcbiAgICAgIFwic2hlbGwgZW52aXJvbm1lbnQgZGV0ZWN0ZWQgYnV0IG5vdCBlbmFibGVkIGF0IGJ1aWxkIHRpbWUuICBBZGQgYHNoZWxsYCB0byBgLXNFTlZJUk9OTUVOVGAgdG8gZW5hYmxlLlwiLFxcbiAgICApO1xcbiAgICB2YXIgd2FzbUJpbmFyeSA9IE1vZHVsZVtcIndhc21CaW5hcnlcIl07XFxuICAgIGxlZ2FjeU1vZHVsZVByb3AoXCJ3YXNtQmluYXJ5XCIsIFwid2FzbUJpbmFyeVwiKTtcXG4gICAgaWYgKHR5cGVvZiBXZWJBc3NlbWJseSAhPSBcIm9iamVjdFwiKSB7XFxuICAgICAgZXJyKFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTtcXG4gICAgfVxcbiAgICB2YXIgd2FzbU1lbW9yeTtcXG4gICAgdmFyIEFCT1JUID0gZmFsc2U7XFxuICAgIHZhciBFWElUU1RBVFVTO1xcbiAgICBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCB0ZXh0KSB7XFxuICAgICAgaWYgKCFjb25kaXRpb24pIHtcXG4gICAgICAgIGFib3J0KFwiQXNzZXJ0aW9uIGZhaWxlZFwiICsgKHRleHQgPyBcIjogXCIgKyB0ZXh0IDogXCJcIikpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICB2YXIgSEVBUDgsXFxuICAgICAgSEVBUFU4LFxcbiAgICAgIEhFQVAxNixcXG4gICAgICBIRUFQVTE2LFxcbiAgICAgIEhFQVAzMixcXG4gICAgICBIRUFQVTMyLFxcbiAgICAgIEhFQVBGMzIsXFxuICAgICAgSEVBUDY0LFxcbiAgICAgIEhFQVBVNjQsXFxuICAgICAgSEVBUEY2NDtcXG4gICAgdmFyIHJ1bnRpbWVJbml0aWFsaXplZCA9IGZhbHNlO1xcbiAgICB2YXIgaXNGaWxlVVJJID0gKGZpbGVuYW1lKSA9PiBmaWxlbmFtZS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKTtcXG4gICAgZnVuY3Rpb24gd3JpdGVTdGFja0Nvb2tpZSgpIHtcXG4gICAgICB2YXIgbWF4ID0gX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZCgpO1xcbiAgICAgIGFzc2VydCgobWF4ICYgMykgPT0gMCk7XFxuICAgICAgaWYgKG1heCA9PSAwKSB7XFxuICAgICAgICBtYXggKz0gNDtcXG4gICAgICB9XFxuICAgICAgSEVBUFUzMlttYXggLyA0XSA9IDM0ODIxMjIzO1xcbiAgICAgIEhFQVBVMzJbKG1heCArIDQpIC8gNF0gPSAyMzEwNzIxMDIyO1xcbiAgICAgIEhFQVBVMzJbMCAvIDRdID0gMTY2ODUwOTAyOTtcXG4gICAgfVxcbiAgICBmdW5jdGlvbiBjaGVja1N0YWNrQ29va2llKCkge1xcbiAgICAgIGlmIChBQk9SVCkgcmV0dXJuO1xcbiAgICAgIHZhciBtYXggPSBfZW1zY3JpcHRlbl9zdGFja19nZXRfZW5kKCk7XFxuICAgICAgaWYgKG1heCA9PSAwKSB7XFxuICAgICAgICBtYXggKz0gNDtcXG4gICAgICB9XFxuICAgICAgdmFyIGNvb2tpZTEgPSBIRUFQVTMyW21heCAvIDRdO1xcbiAgICAgIHZhciBjb29raWUyID0gSEVBUFUzMlsobWF4ICsgNCkgLyA0XTtcXG4gICAgICBpZiAoY29va2llMSAhPSAzNDgyMTIyMyB8fCBjb29raWUyICE9IDIzMTA3MjEwMjIpIHtcXG4gICAgICAgIGFib3J0KFxcbiAgICAgICAgICBgU3RhY2sgb3ZlcmZsb3chIFN0YWNrIGNvb2tpZSBoYXMgYmVlbiBvdmVyd3JpdHRlbiBhdCAke3B0clRvU3RyaW5nKG1heCl9LCBleHBlY3RlZCBoZXggZHdvcmRzIDB4ODlCQUNERkUgYW5kIDB4MjEzNTQ2NywgYnV0IHJlY2VpdmVkICR7cHRyVG9TdHJpbmcoY29va2llMil9ICR7cHRyVG9TdHJpbmcoY29va2llMSl9YCxcXG4gICAgICAgICk7XFxuICAgICAgfVxcbiAgICAgIGlmIChIRUFQVTMyWzAgLyA0XSAhPSAxNjY4NTA5MDI5KSB7XFxuICAgICAgICBhYm9ydChcXG4gICAgICAgICAgXCJSdW50aW1lIGVycm9yOiBUaGUgYXBwbGljYXRpb24gaGFzIGNvcnJ1cHRlZCBpdHMgaGVhcCBtZW1vcnkgYXJlYSAoYWRkcmVzcyB6ZXJvKSFcIixcXG4gICAgICAgICk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgICgoKSA9PiB7XFxuICAgICAgdmFyIGgxNiA9IG5ldyBJbnQxNkFycmF5KDEpO1xcbiAgICAgIHZhciBoOCA9IG5ldyBJbnQ4QXJyYXkoaDE2LmJ1ZmZlcik7XFxuICAgICAgaDE2WzBdID0gMjU0NTk7XFxuICAgICAgaWYgKGg4WzBdICE9PSAxMTUgfHwgaDhbMV0gIT09IDk5KVxcbiAgICAgICAgdGhyb3cgXCJSdW50aW1lIGVycm9yOiBleHBlY3RlZCB0aGUgc3lzdGVtIHRvIGJlIGxpdHRsZS1lbmRpYW4hIChSdW4gd2l0aCAtc1NVUFBPUlRfQklHX0VORElBTiB0byBieXBhc3MpXCI7XFxuICAgIH0pKCk7XFxuICAgIGlmIChNb2R1bGVbXCJFTlZJUk9OTUVOVFwiXSkge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihcXG4gICAgICAgIFwiTW9kdWxlLkVOVklST05NRU5UIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFRvIGZvcmNlIHRoZSBlbnZpcm9ubWVudCwgdXNlIHRoZSBFTlZJUk9OTUVOVCBjb21waWxlLXRpbWUgb3B0aW9uIChmb3IgZXhhbXBsZSwgLXNFTlZJUk9OTUVOVD13ZWIgb3IgLXNFTlZJUk9OTUVOVD1ub2RlKVwiLFxcbiAgICAgICk7XFxuICAgIH1cXG4gICAgZnVuY3Rpb24gbGVnYWN5TW9kdWxlUHJvcChwcm9wLCBuZXdOYW1lLCBpbmNvbWluZyA9IHRydWUpIHtcXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlLCBwcm9wKSkge1xcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZSwgcHJvcCwge1xcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICAgIGdldCgpIHtcXG4gICAgICAgICAgICBsZXQgZXh0cmEgPSBpbmNvbWluZ1xcbiAgICAgICAgICAgICAgPyBcIiAodGhlIGluaXRpYWwgdmFsdWUgY2FuIGJlIHByb3ZpZGVkIG9uIE1vZHVsZSwgYnV0IGFmdGVyIHN0YXJ0dXAgdGhlIHZhbHVlIGlzIG9ubHkgbG9va2VkIGZvciBvbiBhIGxvY2FsIHZhcmlhYmxlIG9mIHRoYXQgbmFtZSlcIlxcbiAgICAgICAgICAgICAgOiBcIlwiO1xcbiAgICAgICAgICAgIGFib3J0KFxcbiAgICAgICAgICAgICAgYFxcXFxgTW9kdWxlLiR7cHJvcH1cXFxcYCBoYXMgYmVlbiByZXBsYWNlZCBieSBcXFxcYCR7bmV3TmFtZX1cXFxcYGAgKyBleHRyYSxcXG4gICAgICAgICAgICApO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGZ1bmN0aW9uIGlnbm9yZWRNb2R1bGVQcm9wKHByb3ApIHtcXG4gICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGUsIHByb3ApKSB7XFxuICAgICAgICBhYm9ydChcXG4gICAgICAgICAgYFxcXFxgTW9kdWxlLiR7cHJvcH1cXFxcYCB3YXMgc3VwcGxpZWQgYnV0IFxcXFxgJHtwcm9wfVxcXFxgIG5vdCBpbmNsdWRlZCBpbiBJTkNPTUlOR19NT0RVTEVfSlNfQVBJYCxcXG4gICAgICAgICk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGZ1bmN0aW9uIGlzRXhwb3J0ZWRCeUZvcmNlRmlsZXN5c3RlbShuYW1lKSB7XFxuICAgICAgcmV0dXJuIChcXG4gICAgICAgIG5hbWUgPT09IFwiRlNfY3JlYXRlUGF0aFwiIHx8XFxuICAgICAgICBuYW1lID09PSBcIkZTX2NyZWF0ZURhdGFGaWxlXCIgfHxcXG4gICAgICAgIG5hbWUgPT09IFwiRlNfY3JlYXRlUHJlbG9hZGVkRmlsZVwiIHx8XFxuICAgICAgICBuYW1lID09PSBcIkZTX3VubGlua1wiIHx8XFxuICAgICAgICBuYW1lID09PSBcImFkZFJ1bkRlcGVuZGVuY3lcIiB8fFxcbiAgICAgICAgbmFtZSA9PT0gXCJGU19jcmVhdGVMYXp5RmlsZVwiIHx8XFxuICAgICAgICBuYW1lID09PSBcIkZTX2NyZWF0ZURldmljZVwiIHx8XFxuICAgICAgICBuYW1lID09PSBcInJlbW92ZVJ1bkRlcGVuZGVuY3lcIlxcbiAgICAgICk7XFxuICAgIH1cXG4gICAgZnVuY3Rpb24gaG9va0dsb2JhbFN5bWJvbEFjY2VzcyhzeW0sIGZ1bmMpIHtcXG4gICAgICBpZiAoXFxuICAgICAgICB0eXBlb2YgZ2xvYmFsVGhpcyAhPSBcInVuZGVmaW5lZFwiICYmXFxuICAgICAgICAhT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihnbG9iYWxUaGlzLCBzeW0pXFxuICAgICAgKSB7XFxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgc3ltLCB7XFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgZ2V0KCkge1xcbiAgICAgICAgICAgIGZ1bmMoKTtcXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGZ1bmN0aW9uIG1pc3NpbmdHbG9iYWwoc3ltLCBtc2cpIHtcXG4gICAgICBob29rR2xvYmFsU3ltYm9sQWNjZXNzKHN5bSwgKCkgPT4ge1xcbiAgICAgICAgd2Fybk9uY2UoYFxcXFxgJHtzeW19XFxcXGAgaXMgbm90IGxvbmdlciBkZWZpbmVkIGJ5IGVtc2NyaXB0ZW4uICR7bXNnfWApO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIG1pc3NpbmdHbG9iYWwoXCJidWZmZXJcIiwgXCJQbGVhc2UgdXNlIEhFQVA4LmJ1ZmZlciBvciB3YXNtTWVtb3J5LmJ1ZmZlclwiKTtcXG4gICAgbWlzc2luZ0dsb2JhbChcImFzbVwiLCBcIlBsZWFzZSB1c2Ugd2FzbUV4cG9ydHMgaW5zdGVhZFwiKTtcXG4gICAgZnVuY3Rpb24gbWlzc2luZ0xpYnJhcnlTeW1ib2woc3ltKSB7XFxuICAgICAgaG9va0dsb2JhbFN5bWJvbEFjY2VzcyhzeW0sICgpID0+IHtcXG4gICAgICAgIHZhciBtc2cgPSBgXFxcXGAke3N5bX1cXFxcYCBpcyBhIGxpYnJhcnkgc3ltYm9sIGFuZCBub3QgaW5jbHVkZWQgYnkgZGVmYXVsdDsgYWRkIGl0IHRvIHlvdXIgbGlicmFyeS5qcyBfX2RlcHMgb3IgdG8gREVGQVVMVF9MSUJSQVJZX0ZVTkNTX1RPX0lOQ0xVREUgb24gdGhlIGNvbW1hbmQgbGluZWA7XFxuICAgICAgICB2YXIgbGlicmFyeVN5bWJvbCA9IHN5bTtcXG4gICAgICAgIGlmICghbGlicmFyeVN5bWJvbC5zdGFydHNXaXRoKFwiX1wiKSkge1xcbiAgICAgICAgICBsaWJyYXJ5U3ltYm9sID0gXCIkXCIgKyBzeW07XFxuICAgICAgICB9XFxuICAgICAgICBtc2cgKz0gYCAoZS5nLiAtc0RFRkFVTFRfTElCUkFSWV9GVU5DU19UT19JTkNMVURFPVxcJyR7bGlicmFyeVN5bWJvbH1cXCcpYDtcXG4gICAgICAgIGlmIChpc0V4cG9ydGVkQnlGb3JjZUZpbGVzeXN0ZW0oc3ltKSkge1xcbiAgICAgICAgICBtc2cgKz1cXG4gICAgICAgICAgICBcIi4gQWx0ZXJuYXRpdmVseSwgZm9yY2luZyBmaWxlc3lzdGVtIHN1cHBvcnQgKC1zRk9SQ0VfRklMRVNZU1RFTSkgY2FuIGV4cG9ydCB0aGlzIGZvciB5b3VcIjtcXG4gICAgICAgIH1cXG4gICAgICAgIHdhcm5PbmNlKG1zZyk7XFxuICAgICAgfSk7XFxuICAgICAgdW5leHBvcnRlZFJ1bnRpbWVTeW1ib2woc3ltKTtcXG4gICAgfVxcbiAgICBmdW5jdGlvbiB1bmV4cG9ydGVkUnVudGltZVN5bWJvbChzeW0pIHtcXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlLCBzeW0pKSB7XFxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlLCBzeW0sIHtcXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICBnZXQoKSB7XFxuICAgICAgICAgICAgdmFyIG1zZyA9IGBcXCcke3N5bX1cXCcgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBFbXNjcmlwdGVuIEZBUSlgO1xcbiAgICAgICAgICAgIGlmIChpc0V4cG9ydGVkQnlGb3JjZUZpbGVzeXN0ZW0oc3ltKSkge1xcbiAgICAgICAgICAgICAgbXNnICs9XFxuICAgICAgICAgICAgICAgIFwiLiBBbHRlcm5hdGl2ZWx5LCBmb3JjaW5nIGZpbGVzeXN0ZW0gc3VwcG9ydCAoLXNGT1JDRV9GSUxFU1lTVEVNKSBjYW4gZXhwb3J0IHRoaXMgZm9yIHlvdVwiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBhYm9ydChtc2cpO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGZ1bmN0aW9uIHVwZGF0ZU1lbW9yeVZpZXdzKCkge1xcbiAgICAgIHZhciBiID0gd2FzbU1lbW9yeS5idWZmZXI7XFxuICAgICAgTW9kdWxlW1wiSEVBUDhcIl0gPSBIRUFQOCA9IG5ldyBJbnQ4QXJyYXkoYik7XFxuICAgICAgTW9kdWxlW1wiSEVBUDE2XCJdID0gSEVBUDE2ID0gbmV3IEludDE2QXJyYXkoYik7XFxuICAgICAgTW9kdWxlW1wiSEVBUFU4XCJdID0gSEVBUFU4ID0gbmV3IFVpbnQ4QXJyYXkoYik7XFxuICAgICAgTW9kdWxlW1wiSEVBUFUxNlwiXSA9IEhFQVBVMTYgPSBuZXcgVWludDE2QXJyYXkoYik7XFxuICAgICAgTW9kdWxlW1wiSEVBUDMyXCJdID0gSEVBUDMyID0gbmV3IEludDMyQXJyYXkoYik7XFxuICAgICAgTW9kdWxlW1wiSEVBUFUzMlwiXSA9IEhFQVBVMzIgPSBuZXcgVWludDMyQXJyYXkoYik7XFxuICAgICAgTW9kdWxlW1wiSEVBUEYzMlwiXSA9IEhFQVBGMzIgPSBuZXcgRmxvYXQzMkFycmF5KGIpO1xcbiAgICAgIE1vZHVsZVtcIkhFQVBGNjRcIl0gPSBIRUFQRjY0ID0gbmV3IEZsb2F0NjRBcnJheShiKTtcXG4gICAgICBNb2R1bGVbXCJIRUFQNjRcIl0gPSBIRUFQNjQgPSBuZXcgQmlnSW50NjRBcnJheShiKTtcXG4gICAgICBNb2R1bGVbXCJIRUFQVTY0XCJdID0gSEVBUFU2NCA9IG5ldyBCaWdVaW50NjRBcnJheShiKTtcXG4gICAgfVxcbiAgICBhc3NlcnQoXFxuICAgICAgIU1vZHVsZVtcIlNUQUNLX1NJWkVcIl0sXFxuICAgICAgXCJTVEFDS19TSVpFIGNhbiBubyBsb25nZXIgYmUgc2V0IGF0IHJ1bnRpbWUuICBVc2UgLXNTVEFDS19TSVpFIGF0IGxpbmsgdGltZVwiLFxcbiAgICApO1xcbiAgICBhc3NlcnQoXFxuICAgICAgdHlwZW9mIEludDMyQXJyYXkgIT0gXCJ1bmRlZmluZWRcIiAmJlxcbiAgICAgICAgdHlwZW9mIEZsb2F0NjRBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxcbiAgICAgICAgSW50MzJBcnJheS5wcm90b3R5cGUuc3ViYXJyYXkgIT0gdW5kZWZpbmVkICYmXFxuICAgICAgICBJbnQzMkFycmF5LnByb3RvdHlwZS5zZXQgIT0gdW5kZWZpbmVkLFxcbiAgICAgIFwiSlMgZW5naW5lIGRvZXMgbm90IHByb3ZpZGUgZnVsbCB0eXBlZCBhcnJheSBzdXBwb3J0XCIsXFxuICAgICk7XFxuICAgIGFzc2VydChcXG4gICAgICAhTW9kdWxlW1wid2FzbU1lbW9yeVwiXSxcXG4gICAgICBcIlVzZSBvZiBgd2FzbU1lbW9yeWAgZGV0ZWN0ZWQuICBVc2UgLXNJTVBPUlRFRF9NRU1PUlkgdG8gZGVmaW5lIHdhc21NZW1vcnkgZXh0ZXJuYWxseVwiLFxcbiAgICApO1xcbiAgICBhc3NlcnQoXFxuICAgICAgIU1vZHVsZVtcIklOSVRJQUxfTUVNT1JZXCJdLFxcbiAgICAgIFwiRGV0ZWN0ZWQgcnVudGltZSBJTklUSUFMX01FTU9SWSBzZXR0aW5nLiAgVXNlIC1zSU1QT1JURURfTUVNT1JZIHRvIGRlZmluZSB3YXNtTWVtb3J5IGR5bmFtaWNhbGx5XCIsXFxuICAgICk7XFxuICAgIGZ1bmN0aW9uIHByZVJ1bigpIHtcXG4gICAgICBpZiAoTW9kdWxlW1wicHJlUnVuXCJdKSB7XFxuICAgICAgICBpZiAodHlwZW9mIE1vZHVsZVtcInByZVJ1blwiXSA9PSBcImZ1bmN0aW9uXCIpXFxuICAgICAgICAgIE1vZHVsZVtcInByZVJ1blwiXSA9IFtNb2R1bGVbXCJwcmVSdW5cIl1dO1xcbiAgICAgICAgd2hpbGUgKE1vZHVsZVtcInByZVJ1blwiXS5sZW5ndGgpIHtcXG4gICAgICAgICAgYWRkT25QcmVSdW4oTW9kdWxlW1wicHJlUnVuXCJdLnNoaWZ0KCkpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBjYWxsUnVudGltZUNhbGxiYWNrcyhvblByZVJ1bnMpO1xcbiAgICB9XFxuICAgIGZ1bmN0aW9uIGluaXRSdW50aW1lKCkge1xcbiAgICAgIGFzc2VydCghcnVudGltZUluaXRpYWxpemVkKTtcXG4gICAgICBydW50aW1lSW5pdGlhbGl6ZWQgPSB0cnVlO1xcbiAgICAgIGNoZWNrU3RhY2tDb29raWUoKTtcXG4gICAgICBpZiAoIU1vZHVsZVtcIm5vRlNJbml0XCJdICYmICFGUy5pbml0aWFsaXplZCkgRlMuaW5pdCgpO1xcbiAgICAgIFRUWS5pbml0KCk7XFxuICAgICAgd2FzbUV4cG9ydHNbXCJfX3dhc21fY2FsbF9jdG9yc1wiXSgpO1xcbiAgICAgIEZTLmlnbm9yZVBlcm1pc3Npb25zID0gZmFsc2U7XFxuICAgIH1cXG4gICAgZnVuY3Rpb24gcHJlTWFpbigpIHtcXG4gICAgICBjaGVja1N0YWNrQ29va2llKCk7XFxuICAgIH1cXG4gICAgZnVuY3Rpb24gcG9zdFJ1bigpIHtcXG4gICAgICBjaGVja1N0YWNrQ29va2llKCk7XFxuICAgICAgaWYgKE1vZHVsZVtcInBvc3RSdW5cIl0pIHtcXG4gICAgICAgIGlmICh0eXBlb2YgTW9kdWxlW1wicG9zdFJ1blwiXSA9PSBcImZ1bmN0aW9uXCIpXFxuICAgICAgICAgIE1vZHVsZVtcInBvc3RSdW5cIl0gPSBbTW9kdWxlW1wicG9zdFJ1blwiXV07XFxuICAgICAgICB3aGlsZSAoTW9kdWxlW1wicG9zdFJ1blwiXS5sZW5ndGgpIHtcXG4gICAgICAgICAgYWRkT25Qb3N0UnVuKE1vZHVsZVtcInBvc3RSdW5cIl0uc2hpZnQoKSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGNhbGxSdW50aW1lQ2FsbGJhY2tzKG9uUG9zdFJ1bnMpO1xcbiAgICB9XFxuICAgIHZhciBydW5EZXBlbmRlbmNpZXMgPSAwO1xcbiAgICB2YXIgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gbnVsbDtcXG4gICAgdmFyIHJ1bkRlcGVuZGVuY3lUcmFja2luZyA9IHt9O1xcbiAgICB2YXIgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBudWxsO1xcbiAgICBmdW5jdGlvbiBnZXRVbmlxdWVSdW5EZXBlbmRlbmN5KGlkKSB7XFxuICAgICAgdmFyIG9yaWcgPSBpZDtcXG4gICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgaWYgKCFydW5EZXBlbmRlbmN5VHJhY2tpbmdbaWRdKSByZXR1cm4gaWQ7XFxuICAgICAgICBpZCA9IG9yaWcgKyBNYXRoLnJhbmRvbSgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBmdW5jdGlvbiBhZGRSdW5EZXBlbmRlbmN5KGlkKSB7XFxuICAgICAgcnVuRGVwZW5kZW5jaWVzKys7XFxuICAgICAgTW9kdWxlW1wibW9uaXRvclJ1bkRlcGVuZGVuY2llc1wiXT8uKHJ1bkRlcGVuZGVuY2llcyk7XFxuICAgICAgaWYgKGlkKSB7XFxuICAgICAgICBhc3NlcnQoIXJ1bkRlcGVuZGVuY3lUcmFja2luZ1tpZF0pO1xcbiAgICAgICAgcnVuRGVwZW5kZW5jeVRyYWNraW5nW2lkXSA9IDE7XFxuICAgICAgICBpZiAoXFxuICAgICAgICAgIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID09PSBudWxsICYmXFxuICAgICAgICAgIHR5cGVvZiBzZXRJbnRlcnZhbCAhPSBcInVuZGVmaW5lZFwiXFxuICAgICAgICApIHtcXG4gICAgICAgICAgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XFxuICAgICAgICAgICAgaWYgKEFCT1JUKSB7XFxuICAgICAgICAgICAgICBjbGVhckludGVydmFsKHJ1bkRlcGVuZGVuY3lXYXRjaGVyKTtcXG4gICAgICAgICAgICAgIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gbnVsbDtcXG4gICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdmFyIHNob3duID0gZmFsc2U7XFxuICAgICAgICAgICAgZm9yICh2YXIgZGVwIGluIHJ1bkRlcGVuZGVuY3lUcmFja2luZykge1xcbiAgICAgICAgICAgICAgaWYgKCFzaG93bikge1xcbiAgICAgICAgICAgICAgICBzaG93biA9IHRydWU7XFxuICAgICAgICAgICAgICAgIGVycihcInN0aWxsIHdhaXRpbmcgb24gcnVuIGRlcGVuZGVuY2llczpcIik7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBlcnIoYGRlcGVuZGVuY3k6ICR7ZGVwfWApO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoc2hvd24pIHtcXG4gICAgICAgICAgICAgIGVycihcIihlbmQgb2YgbGlzdClcIik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9LCAxZTQpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBlcnIoXCJ3YXJuaW5nOiBydW4gZGVwZW5kZW5jeSBhZGRlZCB3aXRob3V0IElEXCIpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBmdW5jdGlvbiByZW1vdmVSdW5EZXBlbmRlbmN5KGlkKSB7XFxuICAgICAgcnVuRGVwZW5kZW5jaWVzLS07XFxuICAgICAgTW9kdWxlW1wibW9uaXRvclJ1bkRlcGVuZGVuY2llc1wiXT8uKHJ1bkRlcGVuZGVuY2llcyk7XFxuICAgICAgaWYgKGlkKSB7XFxuICAgICAgICBhc3NlcnQocnVuRGVwZW5kZW5jeVRyYWNraW5nW2lkXSk7XFxuICAgICAgICBkZWxldGUgcnVuRGVwZW5kZW5jeVRyYWNraW5nW2lkXTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZXJyKFwid2FybmluZzogcnVuIGRlcGVuZGVuY3kgcmVtb3ZlZCB3aXRob3V0IElEXCIpO1xcbiAgICAgIH1cXG4gICAgICBpZiAocnVuRGVwZW5kZW5jaWVzID09IDApIHtcXG4gICAgICAgIGlmIChydW5EZXBlbmRlbmN5V2F0Y2hlciAhPT0gbnVsbCkge1xcbiAgICAgICAgICBjbGVhckludGVydmFsKHJ1bkRlcGVuZGVuY3lXYXRjaGVyKTtcXG4gICAgICAgICAgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGRlcGVuZGVuY2llc0Z1bGZpbGxlZCkge1xcbiAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBkZXBlbmRlbmNpZXNGdWxmaWxsZWQ7XFxuICAgICAgICAgIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IG51bGw7XFxuICAgICAgICAgIGNhbGxiYWNrKCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGZ1bmN0aW9uIGFib3J0KHdoYXQpIHtcXG4gICAgICBNb2R1bGVbXCJvbkFib3J0XCJdPy4od2hhdCk7XFxuICAgICAgd2hhdCA9IFwiQWJvcnRlZChcIiArIHdoYXQgKyBcIilcIjtcXG4gICAgICBlcnIod2hhdCk7XFxuICAgICAgQUJPUlQgPSB0cnVlO1xcbiAgICAgIGlmICh3aGF0LmluZGV4T2YoXCJSdW50aW1lRXJyb3I6IHVucmVhY2hhYmxlXCIpID49IDApIHtcXG4gICAgICAgIHdoYXQgKz1cXG4gICAgICAgICAgXFwnLiBcInVucmVhY2hhYmxlXCIgbWF5IGJlIGR1ZSB0byBBU1lOQ0lGWV9TVEFDS19TSVpFIG5vdCBiZWluZyBsYXJnZSBlbm91Z2ggKHRyeSBpbmNyZWFzaW5nIGl0KVxcJztcXG4gICAgICB9XFxuICAgICAgdmFyIGUgPSBuZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHdoYXQpO1xcbiAgICAgIHJlYWR5UHJvbWlzZVJlamVjdChlKTtcXG4gICAgICB0aHJvdyBlO1xcbiAgICB9XFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV4cG9ydFdyYXBwZXIobmFtZSwgbmFyZ3MpIHtcXG4gICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcXG4gICAgICAgIGFzc2VydChcXG4gICAgICAgICAgcnVudGltZUluaXRpYWxpemVkLFxcbiAgICAgICAgICBgbmF0aXZlIGZ1bmN0aW9uIFxcXFxgJHtuYW1lfVxcXFxgIGNhbGxlZCBiZWZvcmUgcnVudGltZSBpbml0aWFsaXphdGlvbmAsXFxuICAgICAgICApO1xcbiAgICAgICAgdmFyIGYgPSB3YXNtRXhwb3J0c1tuYW1lXTtcXG4gICAgICAgIGFzc2VydChmLCBgZXhwb3J0ZWQgbmF0aXZlIGZ1bmN0aW9uIFxcXFxgJHtuYW1lfVxcXFxgIG5vdCBmb3VuZGApO1xcbiAgICAgICAgYXNzZXJ0KFxcbiAgICAgICAgICBhcmdzLmxlbmd0aCA8PSBuYXJncyxcXG4gICAgICAgICAgYG5hdGl2ZSBmdW5jdGlvbiBcXFxcYCR7bmFtZX1cXFxcYCBjYWxsZWQgd2l0aCAke2FyZ3MubGVuZ3RofSBhcmdzIGJ1dCBleHBlY3RzICR7bmFyZ3N9YCxcXG4gICAgICAgICk7XFxuICAgICAgICByZXR1cm4gZiguLi5hcmdzKTtcXG4gICAgICB9O1xcbiAgICB9XFxuICAgIHZhciB3YXNtQmluYXJ5RmlsZTtcXG4gICAgZnVuY3Rpb24gZmluZFdhc21CaW5hcnkoKSB7XFxuICAgICAgaWYgKE1vZHVsZVtcImxvY2F0ZUZpbGVcIl0pIHtcXG4gICAgICAgIHJldHVybiBsb2NhdGVGaWxlKFwicmlzY3Zfc2ltX1JWNjQud2FzbVwiKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG5ldyBVUkwoXCJyaXNjdl9zaW1fUlY2NC53YXNtXCIsIGltcG9ydC5tZXRhLnVybCkuaHJlZjtcXG4gICAgfVxcbiAgICBmdW5jdGlvbiBnZXRCaW5hcnlTeW5jKGZpbGUpIHtcXG4gICAgICBpZiAoZmlsZSA9PSB3YXNtQmluYXJ5RmlsZSAmJiB3YXNtQmluYXJ5KSB7XFxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkod2FzbUJpbmFyeSk7XFxuICAgICAgfVxcbiAgICAgIGlmIChyZWFkQmluYXJ5KSB7XFxuICAgICAgICByZXR1cm4gcmVhZEJpbmFyeShmaWxlKTtcXG4gICAgICB9XFxuICAgICAgdGhyb3cgXCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwiO1xcbiAgICB9XFxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFdhc21CaW5hcnkoYmluYXJ5RmlsZSkge1xcbiAgICAgIGlmICghd2FzbUJpbmFyeSkge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgdmFyIHJlc3BvbnNlID0gYXdhaXQgcmVhZEFzeW5jKGJpbmFyeUZpbGUpO1xcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UpO1xcbiAgICAgICAgfSBjYXRjaCB7fVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gZ2V0QmluYXJ5U3luYyhiaW5hcnlGaWxlKTtcXG4gICAgfVxcbiAgICBhc3luYyBmdW5jdGlvbiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKGJpbmFyeUZpbGUsIGltcG9ydHMpIHtcXG4gICAgICB0cnkge1xcbiAgICAgICAgdmFyIGJpbmFyeSA9IGF3YWl0IGdldFdhc21CaW5hcnkoYmluYXJ5RmlsZSk7XFxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShiaW5hcnksIGltcG9ydHMpO1xcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xcbiAgICAgIH0gY2F0Y2ggKHJlYXNvbikge1xcbiAgICAgICAgZXJyKGBmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAke3JlYXNvbn1gKTtcXG4gICAgICAgIGlmIChpc0ZpbGVVUkkod2FzbUJpbmFyeUZpbGUpKSB7XFxuICAgICAgICAgIGVycihcXG4gICAgICAgICAgICBgd2FybmluZzogTG9hZGluZyBmcm9tIGEgZmlsZSBVUkkgKCR7d2FzbUJpbmFyeUZpbGV9KSBpcyBub3Qgc3VwcG9ydGVkIGluIG1vc3QgYnJvd3NlcnMuIFNlZSBodHRwczovL2Vtc2NyaXB0ZW4ub3JnL2RvY3MvZ2V0dGluZ19zdGFydGVkL0ZBUS5odG1sI2hvdy1kby1pLXJ1bi1hLWxvY2FsLXdlYnNlcnZlci1mb3ItdGVzdGluZy13aHktZG9lcy1teS1wcm9ncmFtLXN0YWxsLWluLWRvd25sb2FkaW5nLW9yLXByZXBhcmluZ2AsXFxuICAgICAgICAgICk7XFxuICAgICAgICB9XFxuICAgICAgICBhYm9ydChyZWFzb24pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBhc3luYyBmdW5jdGlvbiBpbnN0YW50aWF0ZUFzeW5jKGJpbmFyeSwgYmluYXJ5RmlsZSwgaW1wb3J0cykge1xcbiAgICAgIGlmICghYmluYXJ5ICYmIHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyA9PSBcImZ1bmN0aW9uXCIpIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIHZhciByZXNwb25zZSA9IGZldGNoKGJpbmFyeUZpbGUsIHsgY3JlZGVudGlhbHM6IFwic2FtZS1vcmlnaW5cIiB9KTtcXG4gICAgICAgICAgdmFyIGluc3RhbnRpYXRpb25SZXN1bHQgPSBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhcXG4gICAgICAgICAgICByZXNwb25zZSxcXG4gICAgICAgICAgICBpbXBvcnRzLFxcbiAgICAgICAgICApO1xcbiAgICAgICAgICByZXR1cm4gaW5zdGFudGlhdGlvblJlc3VsdDtcXG4gICAgICAgIH0gY2F0Y2ggKHJlYXNvbikge1xcbiAgICAgICAgICBlcnIoYHdhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAke3JlYXNvbn1gKTtcXG4gICAgICAgICAgZXJyKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIik7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKGJpbmFyeUZpbGUsIGltcG9ydHMpO1xcbiAgICB9XFxuICAgIGZ1bmN0aW9uIGdldFdhc21JbXBvcnRzKCkge1xcbiAgICAgIEFzeW5jaWZ5Lmluc3RydW1lbnRXYXNtSW1wb3J0cyh3YXNtSW1wb3J0cyk7XFxuICAgICAgcmV0dXJuIHsgZW52OiB3YXNtSW1wb3J0cywgd2FzaV9zbmFwc2hvdF9wcmV2aWV3MTogd2FzbUltcG9ydHMgfTtcXG4gICAgfVxcbiAgICBhc3luYyBmdW5jdGlvbiBjcmVhdGVXYXNtKCkge1xcbiAgICAgIGZ1bmN0aW9uIHJlY2VpdmVJbnN0YW5jZShpbnN0YW5jZSwgbW9kdWxlKSB7XFxuICAgICAgICB3YXNtRXhwb3J0cyA9IGluc3RhbmNlLmV4cG9ydHM7XFxuICAgICAgICB3YXNtRXhwb3J0cyA9IEFzeW5jaWZ5Lmluc3RydW1lbnRXYXNtRXhwb3J0cyh3YXNtRXhwb3J0cyk7XFxuICAgICAgICB3YXNtRXhwb3J0cyA9IGFwcGx5U2lnbmF0dXJlQ29udmVyc2lvbnMod2FzbUV4cG9ydHMpO1xcbiAgICAgICAgd2FzbU1lbW9yeSA9IHdhc21FeHBvcnRzW1wibWVtb3J5XCJdO1xcbiAgICAgICAgYXNzZXJ0KHdhc21NZW1vcnksIFwibWVtb3J5IG5vdCBmb3VuZCBpbiB3YXNtIGV4cG9ydHNcIik7XFxuICAgICAgICB1cGRhdGVNZW1vcnlWaWV3cygpO1xcbiAgICAgICAgcmVtb3ZlUnVuRGVwZW5kZW5jeShcIndhc20taW5zdGFudGlhdGVcIik7XFxuICAgICAgICByZXR1cm4gd2FzbUV4cG9ydHM7XFxuICAgICAgfVxcbiAgICAgIGFkZFJ1bkRlcGVuZGVuY3koXCJ3YXNtLWluc3RhbnRpYXRlXCIpO1xcbiAgICAgIHZhciB0cnVlTW9kdWxlID0gTW9kdWxlO1xcbiAgICAgIGZ1bmN0aW9uIHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KHJlc3VsdCkge1xcbiAgICAgICAgYXNzZXJ0KFxcbiAgICAgICAgICBNb2R1bGUgPT09IHRydWVNb2R1bGUsXFxuICAgICAgICAgIFwidGhlIE1vZHVsZSBvYmplY3Qgc2hvdWxkIG5vdCBiZSByZXBsYWNlZCBkdXJpbmcgYXN5bmMgY29tcGlsYXRpb24gLSBwZXJoYXBzIHRoZSBvcmRlciBvZiBIVE1MIGVsZW1lbnRzIGlzIHdyb25nP1wiLFxcbiAgICAgICAgKTtcXG4gICAgICAgIHRydWVNb2R1bGUgPSBudWxsO1xcbiAgICAgICAgcmV0dXJuIHJlY2VpdmVJbnN0YW5jZShyZXN1bHRbXCJpbnN0YW5jZVwiXSk7XFxuICAgICAgfVxcbiAgICAgIHZhciBpbmZvID0gZ2V0V2FzbUltcG9ydHMoKTtcXG4gICAgICBpZiAoTW9kdWxlW1wiaW5zdGFudGlhdGVXYXNtXCJdKSB7XFxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xcbiAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIE1vZHVsZVtcImluc3RhbnRpYXRlV2FzbVwiXShpbmZvLCAobW9kLCBpbnN0KSA9PiB7XFxuICAgICAgICAgICAgICByZWNlaXZlSW5zdGFuY2UobW9kLCBpbnN0KTtcXG4gICAgICAgICAgICAgIHJlc29sdmUobW9kLmV4cG9ydHMpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgZXJyKGBNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAke2V9YCk7XFxuICAgICAgICAgICAgcmVqZWN0KGUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgICAgd2FzbUJpbmFyeUZpbGUgPz89IGZpbmRXYXNtQmluYXJ5KCk7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIHZhciByZXN1bHQgPSBhd2FpdCBpbnN0YW50aWF0ZUFzeW5jKHdhc21CaW5hcnksIHdhc21CaW5hcnlGaWxlLCBpbmZvKTtcXG4gICAgICAgIHZhciBleHBvcnRzID0gcmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQocmVzdWx0KTtcXG4gICAgICAgIHJldHVybiBleHBvcnRzO1xcbiAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIHJlYWR5UHJvbWlzZVJlamVjdChlKTtcXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgY2xhc3MgRXhpdFN0YXR1cyB7XFxuICAgICAgbmFtZSA9IFwiRXhpdFN0YXR1c1wiO1xcbiAgICAgIGNvbnN0cnVjdG9yKHN0YXR1cykge1xcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gYFByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoJHtzdGF0dXN9KWA7XFxuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcXG4gICAgICB9XFxuICAgIH1cXG4gICAgdmFyIGNhbGxSdW50aW1lQ2FsbGJhY2tzID0gKGNhbGxiYWNrcykgPT4ge1xcbiAgICAgIHdoaWxlIChjYWxsYmFja3MubGVuZ3RoID4gMCkge1xcbiAgICAgICAgY2FsbGJhY2tzLnNoaWZ0KCkoTW9kdWxlKTtcXG4gICAgICB9XFxuICAgIH07XFxuICAgIHZhciBvblBvc3RSdW5zID0gW107XFxuICAgIHZhciBhZGRPblBvc3RSdW4gPSAoY2IpID0+IG9uUG9zdFJ1bnMudW5zaGlmdChjYik7XFxuICAgIHZhciBvblByZVJ1bnMgPSBbXTtcXG4gICAgdmFyIGFkZE9uUHJlUnVuID0gKGNiKSA9PiBvblByZVJ1bnMudW5zaGlmdChjYik7XFxuICAgIHZhciBub0V4aXRSdW50aW1lID0gTW9kdWxlW1wibm9FeGl0UnVudGltZVwiXSB8fCB0cnVlO1xcbiAgICB2YXIgcHRyVG9TdHJpbmcgPSAocHRyKSA9PiB7XFxuICAgICAgYXNzZXJ0KHR5cGVvZiBwdHIgPT09IFwibnVtYmVyXCIpO1xcbiAgICAgIHJldHVybiBcIjB4XCIgKyBwdHIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsIFwiMFwiKTtcXG4gICAgfTtcXG4gICAgdmFyIHN0YWNrUmVzdG9yZSA9ICh2YWwpID0+IF9fZW1zY3JpcHRlbl9zdGFja19yZXN0b3JlKHZhbCk7XFxuICAgIHZhciBzdGFja1NhdmUgPSAoKSA9PiBfZW1zY3JpcHRlbl9zdGFja19nZXRfY3VycmVudCgpO1xcbiAgICB2YXIgd2Fybk9uY2UgPSAodGV4dCkgPT4ge1xcbiAgICAgIHdhcm5PbmNlLnNob3duIHx8PSB7fTtcXG4gICAgICBpZiAoIXdhcm5PbmNlLnNob3duW3RleHRdKSB7XFxuICAgICAgICB3YXJuT25jZS5zaG93blt0ZXh0XSA9IDE7XFxuICAgICAgICBlcnIodGV4dCk7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgICB2YXIgSU5UNTNfTUFYID0gOTAwNzE5OTI1NDc0MDk5MjtcXG4gICAgdmFyIElOVDUzX01JTiA9IC05MDA3MTk5MjU0NzQwOTkyO1xcbiAgICB2YXIgYmlnaW50VG9JNTNDaGVja2VkID0gKG51bSkgPT5cXG4gICAgICBudW0gPCBJTlQ1M19NSU4gfHwgbnVtID4gSU5UNTNfTUFYID8gTmFOIDogTnVtYmVyKG51bSk7XFxuICAgIHZhciBVVEY4RGVjb2RlciA9XFxuICAgICAgdHlwZW9mIFRleHREZWNvZGVyICE9IFwidW5kZWZpbmVkXCIgPyBuZXcgVGV4dERlY29kZXIoKSA6IHVuZGVmaW5lZDtcXG4gICAgdmFyIFVURjhBcnJheVRvU3RyaW5nID0gKGhlYXBPckFycmF5LCBpZHggPSAwLCBtYXhCeXRlc1RvUmVhZCA9IE5hTikgPT4ge1xcbiAgICAgIHZhciBlbmRJZHggPSBpZHggKyBtYXhCeXRlc1RvUmVhZDtcXG4gICAgICB2YXIgZW5kUHRyID0gaWR4O1xcbiAgICAgIHdoaWxlIChoZWFwT3JBcnJheVtlbmRQdHJdICYmICEoZW5kUHRyID49IGVuZElkeCkpICsrZW5kUHRyO1xcbiAgICAgIGlmIChlbmRQdHIgLSBpZHggPiAxNiAmJiBoZWFwT3JBcnJheS5idWZmZXIgJiYgVVRGOERlY29kZXIpIHtcXG4gICAgICAgIHJldHVybiBVVEY4RGVjb2Rlci5kZWNvZGUoaGVhcE9yQXJyYXkuc3ViYXJyYXkoaWR4LCBlbmRQdHIpKTtcXG4gICAgICB9XFxuICAgICAgdmFyIHN0ciA9IFwiXCI7XFxuICAgICAgd2hpbGUgKGlkeCA8IGVuZFB0cikge1xcbiAgICAgICAgdmFyIHUwID0gaGVhcE9yQXJyYXlbaWR4KytdO1xcbiAgICAgICAgaWYgKCEodTAgJiAxMjgpKSB7XFxuICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgdTEgPSBoZWFwT3JBcnJheVtpZHgrK10gJiA2MztcXG4gICAgICAgIGlmICgodTAgJiAyMjQpID09IDE5Mikge1xcbiAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKHUwICYgMzEpIDw8IDYpIHwgdTEpO1xcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciB1MiA9IGhlYXBPckFycmF5W2lkeCsrXSAmIDYzO1xcbiAgICAgICAgaWYgKCh1MCAmIDI0MCkgPT0gMjI0KSB7XFxuICAgICAgICAgIHUwID0gKCh1MCAmIDE1KSA8PCAxMikgfCAodTEgPDwgNikgfCB1MjtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGlmICgodTAgJiAyNDgpICE9IDI0MClcXG4gICAgICAgICAgICB3YXJuT25jZShcXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBVVEYtOCBsZWFkaW5nIGJ5dGUgXCIgK1xcbiAgICAgICAgICAgICAgICBwdHJUb1N0cmluZyh1MCkgK1xcbiAgICAgICAgICAgICAgICBcIiBlbmNvdW50ZXJlZCB3aGVuIGRlc2VyaWFsaXppbmcgYSBVVEYtOCBzdHJpbmcgaW4gd2FzbSBtZW1vcnkgdG8gYSBKUyBzdHJpbmchXCIsXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgICAgdTAgPVxcbiAgICAgICAgICAgICgodTAgJiA3KSA8PCAxOCkgfFxcbiAgICAgICAgICAgICh1MSA8PCAxMikgfFxcbiAgICAgICAgICAgICh1MiA8PCA2KSB8XFxuICAgICAgICAgICAgKGhlYXBPckFycmF5W2lkeCsrXSAmIDYzKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh1MCA8IDY1NTM2KSB7XFxuICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHZhciBjaCA9IHUwIC0gNjU1MzY7XFxuICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2IHwgKGNoID4+IDEwKSwgNTYzMjAgfCAoY2ggJiAxMDIzKSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBzdHI7XFxuICAgIH07XFxuICAgIHZhciBVVEY4VG9TdHJpbmcgPSAocHRyLCBtYXhCeXRlc1RvUmVhZCkgPT4ge1xcbiAgICAgIGFzc2VydChcXG4gICAgICAgIHR5cGVvZiBwdHIgPT0gXCJudW1iZXJcIixcXG4gICAgICAgIGBVVEY4VG9TdHJpbmcgZXhwZWN0cyBhIG51bWJlciAoZ290ICR7dHlwZW9mIHB0cn0pYCxcXG4gICAgICApO1xcbiAgICAgIHJldHVybiBwdHIgPyBVVEY4QXJyYXlUb1N0cmluZyhIRUFQVTgsIHB0ciwgbWF4Qnl0ZXNUb1JlYWQpIDogXCJcIjtcXG4gICAgfTtcXG4gICAgZnVuY3Rpb24gX19fYXNzZXJ0X2ZhaWwoY29uZGl0aW9uLCBmaWxlbmFtZSwgbGluZSwgZnVuYykge1xcbiAgICAgIGNvbmRpdGlvbiA9IGJpZ2ludFRvSTUzQ2hlY2tlZChjb25kaXRpb24pO1xcbiAgICAgIGZpbGVuYW1lID0gYmlnaW50VG9JNTNDaGVja2VkKGZpbGVuYW1lKTtcXG4gICAgICBmdW5jID0gYmlnaW50VG9JNTNDaGVja2VkKGZ1bmMpO1xcbiAgICAgIHJldHVybiBhYm9ydChcXG4gICAgICAgIGBBc3NlcnRpb24gZmFpbGVkOiAke1VURjhUb1N0cmluZyhjb25kaXRpb24pfSwgYXQ6IGAgK1xcbiAgICAgICAgICBbXFxuICAgICAgICAgICAgZmlsZW5hbWUgPyBVVEY4VG9TdHJpbmcoZmlsZW5hbWUpIDogXCJ1bmtub3duIGZpbGVuYW1lXCIsXFxuICAgICAgICAgICAgbGluZSxcXG4gICAgICAgICAgICBmdW5jID8gVVRGOFRvU3RyaW5nKGZ1bmMpIDogXCJ1bmtub3duIGZ1bmN0aW9uXCIsXFxuICAgICAgICAgIF0sXFxuICAgICAgKTtcXG4gICAgfVxcbiAgICB2YXIgc3lzY2FsbEdldFZhcmFyZ1AgPSAoKSA9PiB7XFxuICAgICAgYXNzZXJ0KFNZU0NBTExTLnZhcmFyZ3MgIT0gdW5kZWZpbmVkKTtcXG4gICAgICB2YXIgcmV0ID0gTnVtYmVyKEhFQVBVNjRbU1lTQ0FMTFMudmFyYXJncyAvIDhdKTtcXG4gICAgICBTWVNDQUxMUy52YXJhcmdzICs9IDg7XFxuICAgICAgcmV0dXJuIHJldDtcXG4gICAgfTtcXG4gICAgdmFyIHN5c2NhbGxHZXRWYXJhcmdJID0gKCkgPT4ge1xcbiAgICAgIGFzc2VydChTWVNDQUxMUy52YXJhcmdzICE9IHVuZGVmaW5lZCk7XFxuICAgICAgdmFyIHJldCA9IEhFQVAzMlsrU1lTQ0FMTFMudmFyYXJncyAvIDRdO1xcbiAgICAgIFNZU0NBTExTLnZhcmFyZ3MgKz0gNDtcXG4gICAgICByZXR1cm4gcmV0O1xcbiAgICB9O1xcbiAgICB2YXIgUEFUSCA9IHtcXG4gICAgICBpc0FiczogKHBhdGgpID0+IHBhdGguY2hhckF0KDApID09PSBcIi9cIixcXG4gICAgICBzcGxpdFBhdGg6IChmaWxlbmFtZSkgPT4ge1xcbiAgICAgICAgdmFyIHNwbGl0UGF0aFJlID1cXG4gICAgICAgICAgL14oXFxcXC8/fCkoW1xcXFxzXFxcXFNdKj8pKCg/OlxcXFwuezEsMn18W15cXFxcL10rP3wpKFxcXFwuW14uXFxcXC9dKnwpKSg/OltcXFxcL10qKSQvO1xcbiAgICAgICAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xcbiAgICAgIH0sXFxuICAgICAgbm9ybWFsaXplQXJyYXk6IChwYXJ0cywgYWxsb3dBYm92ZVJvb3QpID0+IHtcXG4gICAgICAgIHZhciB1cCA9IDA7XFxuICAgICAgICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcXG4gICAgICAgICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcXG4gICAgICAgICAgaWYgKGxhc3QgPT09IFwiLlwiKSB7XFxuICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKGxhc3QgPT09IFwiLi5cIikge1xcbiAgICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcXG4gICAgICAgICAgICB1cCsrO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKHVwKSB7XFxuICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xcbiAgICAgICAgICAgIHVwLS07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xcbiAgICAgICAgICBmb3IgKDsgdXA7IHVwLS0pIHtcXG4gICAgICAgICAgICBwYXJ0cy51bnNoaWZ0KFwiLi5cIik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBwYXJ0cztcXG4gICAgICB9LFxcbiAgICAgIG5vcm1hbGl6ZTogKHBhdGgpID0+IHtcXG4gICAgICAgIHZhciBpc0Fic29sdXRlID0gUEFUSC5pc0FicyhwYXRoKSxcXG4gICAgICAgICAgdHJhaWxpbmdTbGFzaCA9IHBhdGguc2xpY2UoLTEpID09PSBcIi9cIjtcXG4gICAgICAgIHBhdGggPSBQQVRILm5vcm1hbGl6ZUFycmF5KFxcbiAgICAgICAgICBwYXRoLnNwbGl0KFwiL1wiKS5maWx0ZXIoKHApID0+ICEhcCksXFxuICAgICAgICAgICFpc0Fic29sdXRlLFxcbiAgICAgICAgKS5qb2luKFwiL1wiKTtcXG4gICAgICAgIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xcbiAgICAgICAgICBwYXRoID0gXCIuXCI7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XFxuICAgICAgICAgIHBhdGggKz0gXCIvXCI7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gKGlzQWJzb2x1dGUgPyBcIi9cIiA6IFwiXCIpICsgcGF0aDtcXG4gICAgICB9LFxcbiAgICAgIGRpcm5hbWU6IChwYXRoKSA9PiB7XFxuICAgICAgICB2YXIgcmVzdWx0ID0gUEFUSC5zcGxpdFBhdGgocGF0aCksXFxuICAgICAgICAgIHJvb3QgPSByZXN1bHRbMF0sXFxuICAgICAgICAgIGRpciA9IHJlc3VsdFsxXTtcXG4gICAgICAgIGlmICghcm9vdCAmJiAhZGlyKSB7XFxuICAgICAgICAgIHJldHVybiBcIi5cIjtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChkaXIpIHtcXG4gICAgICAgICAgZGlyID0gZGlyLnNsaWNlKDAsIC0xKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiByb290ICsgZGlyO1xcbiAgICAgIH0sXFxuICAgICAgYmFzZW5hbWU6IChwYXRoKSA9PiBwYXRoICYmIHBhdGgubWF0Y2goLyhbXlxcXFwvXSt8XFxcXC8pXFxcXC8qJC8pWzFdLFxcbiAgICAgIGpvaW46ICguLi5wYXRocykgPT4gUEFUSC5ub3JtYWxpemUocGF0aHMuam9pbihcIi9cIikpLFxcbiAgICAgIGpvaW4yOiAobCwgcikgPT4gUEFUSC5ub3JtYWxpemUobCArIFwiL1wiICsgciksXFxuICAgIH07XFxuICAgIHZhciBpbml0UmFuZG9tRmlsbCA9ICgpID0+ICh2aWV3KSA9PiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHZpZXcpO1xcbiAgICB2YXIgcmFuZG9tRmlsbCA9ICh2aWV3KSA9PiB7XFxuICAgICAgKHJhbmRvbUZpbGwgPSBpbml0UmFuZG9tRmlsbCgpKSh2aWV3KTtcXG4gICAgfTtcXG4gICAgdmFyIFBBVEhfRlMgPSB7XFxuICAgICAgcmVzb2x2ZTogKC4uLmFyZ3MpID0+IHtcXG4gICAgICAgIHZhciByZXNvbHZlZFBhdGggPSBcIlwiLFxcbiAgICAgICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XFxuICAgICAgICBmb3IgKHZhciBpID0gYXJncy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcXG4gICAgICAgICAgdmFyIHBhdGggPSBpID49IDAgPyBhcmdzW2ldIDogRlMuY3dkKCk7XFxuICAgICAgICAgIGlmICh0eXBlb2YgcGF0aCAhPSBcInN0cmluZ1wiKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzXCIpO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArIFwiL1wiICsgcmVzb2x2ZWRQYXRoO1xcbiAgICAgICAgICByZXNvbHZlZEFic29sdXRlID0gUEFUSC5pc0FicyhwYXRoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJlc29sdmVkUGF0aCA9IFBBVEgubm9ybWFsaXplQXJyYXkoXFxuICAgICAgICAgIHJlc29sdmVkUGF0aC5zcGxpdChcIi9cIikuZmlsdGVyKChwKSA9PiAhIXApLFxcbiAgICAgICAgICAhcmVzb2x2ZWRBYnNvbHV0ZSxcXG4gICAgICAgICkuam9pbihcIi9cIik7XFxuICAgICAgICByZXR1cm4gKHJlc29sdmVkQWJzb2x1dGUgPyBcIi9cIiA6IFwiXCIpICsgcmVzb2x2ZWRQYXRoIHx8IFwiLlwiO1xcbiAgICAgIH0sXFxuICAgICAgcmVsYXRpdmU6IChmcm9tLCB0bykgPT4ge1xcbiAgICAgICAgZnJvbSA9IFBBVEhfRlMucmVzb2x2ZShmcm9tKS5zbGljZSgxKTtcXG4gICAgICAgIHRvID0gUEFUSF9GUy5yZXNvbHZlKHRvKS5zbGljZSgxKTtcXG4gICAgICAgIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XFxuICAgICAgICAgIHZhciBzdGFydCA9IDA7XFxuICAgICAgICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcXG4gICAgICAgICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gXCJcIikgYnJlYWs7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xcbiAgICAgICAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XFxuICAgICAgICAgICAgaWYgKGFycltlbmRdICE9PSBcIlwiKSBicmVhaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcXG4gICAgICAgICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoXCIvXCIpKTtcXG4gICAgICAgIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdChcIi9cIikpO1xcbiAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcXG4gICAgICAgIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcXG4gICAgICAgICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcXG4gICAgICAgIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgb3V0cHV0UGFydHMucHVzaChcIi4uXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcXG4gICAgICAgIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKFwiL1wiKTtcXG4gICAgICB9LFxcbiAgICB9O1xcbiAgICB2YXIgRlNfc3RkaW5fZ2V0Q2hhcl9idWZmZXIgPSBbXTtcXG4gICAgdmFyIGxlbmd0aEJ5dGVzVVRGOCA9IChzdHIpID0+IHtcXG4gICAgICB2YXIgbGVuID0gMDtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcXG4gICAgICAgIGlmIChjIDw9IDEyNykge1xcbiAgICAgICAgICBsZW4rKztcXG4gICAgICAgIH0gZWxzZSBpZiAoYyA8PSAyMDQ3KSB7XFxuICAgICAgICAgIGxlbiArPSAyO1xcbiAgICAgICAgfSBlbHNlIGlmIChjID49IDU1Mjk2ICYmIGMgPD0gNTczNDMpIHtcXG4gICAgICAgICAgbGVuICs9IDQ7XFxuICAgICAgICAgICsraTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGxlbiArPSAzO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gbGVuO1xcbiAgICB9O1xcbiAgICB2YXIgc3RyaW5nVG9VVEY4QXJyYXkgPSAoc3RyLCBoZWFwLCBvdXRJZHgsIG1heEJ5dGVzVG9Xcml0ZSkgPT4ge1xcbiAgICAgIGFzc2VydChcXG4gICAgICAgIHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCIsXFxuICAgICAgICBgc3RyaW5nVG9VVEY4QXJyYXkgZXhwZWN0cyBhIHN0cmluZyAoZ290ICR7dHlwZW9mIHN0cn0pYCxcXG4gICAgICApO1xcbiAgICAgIGlmICghKG1heEJ5dGVzVG9Xcml0ZSA+IDApKSByZXR1cm4gMDtcXG4gICAgICB2YXIgc3RhcnRJZHggPSBvdXRJZHg7XFxuICAgICAgdmFyIGVuZElkeCA9IG91dElkeCArIG1heEJ5dGVzVG9Xcml0ZSAtIDE7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgIHZhciB1ID0gc3RyLmNoYXJDb2RlQXQoaSk7XFxuICAgICAgICBpZiAodSA+PSA1NTI5NiAmJiB1IDw9IDU3MzQzKSB7XFxuICAgICAgICAgIHZhciB1MSA9IHN0ci5jaGFyQ29kZUF0KCsraSk7XFxuICAgICAgICAgIHUgPSAoNjU1MzYgKyAoKHUgJiAxMDIzKSA8PCAxMCkpIHwgKHUxICYgMTAyMyk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodSA8PSAxMjcpIHtcXG4gICAgICAgICAgaWYgKG91dElkeCA+PSBlbmRJZHgpIGJyZWFrO1xcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IHU7XFxuICAgICAgICB9IGVsc2UgaWYgKHUgPD0gMjA0Nykge1xcbiAgICAgICAgICBpZiAob3V0SWR4ICsgMSA+PSBlbmRJZHgpIGJyZWFrO1xcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDE5MiB8ICh1ID4+IDYpO1xcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDEyOCB8ICh1ICYgNjMpO1xcbiAgICAgICAgfSBlbHNlIGlmICh1IDw9IDY1NTM1KSB7XFxuICAgICAgICAgIGlmIChvdXRJZHggKyAyID49IGVuZElkeCkgYnJlYWs7XFxuICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gMjI0IHwgKHUgPj4gMTIpO1xcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDEyOCB8ICgodSA+PiA2KSAmIDYzKTtcXG4gICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAxMjggfCAodSAmIDYzKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGlmIChvdXRJZHggKyAzID49IGVuZElkeCkgYnJlYWs7XFxuICAgICAgICAgIGlmICh1ID4gMTExNDExMSlcXG4gICAgICAgICAgICB3YXJuT25jZShcXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBVbmljb2RlIGNvZGUgcG9pbnQgXCIgK1xcbiAgICAgICAgICAgICAgICBwdHJUb1N0cmluZyh1KSArXFxuICAgICAgICAgICAgICAgIFwiIGVuY291bnRlcmVkIHdoZW4gc2VyaWFsaXppbmcgYSBKUyBzdHJpbmcgdG8gYSBVVEYtOCBzdHJpbmcgaW4gd2FzbSBtZW1vcnkhIChWYWxpZCB1bmljb2RlIGNvZGUgcG9pbnRzIHNob3VsZCBiZSBpbiByYW5nZSAwLTB4MTBGRkZGKS5cIixcXG4gICAgICAgICAgICApO1xcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDI0MCB8ICh1ID4+IDE4KTtcXG4gICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAxMjggfCAoKHUgPj4gMTIpICYgNjMpO1xcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDEyOCB8ICgodSA+PiA2KSAmIDYzKTtcXG4gICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAxMjggfCAodSAmIDYzKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgaGVhcFtvdXRJZHhdID0gMDtcXG4gICAgICByZXR1cm4gb3V0SWR4IC0gc3RhcnRJZHg7XFxuICAgIH07XFxuICAgIHZhciBpbnRBcnJheUZyb21TdHJpbmcgPSAoc3RyaW5neSwgZG9udEFkZE51bGwsIGxlbmd0aCkgPT4ge1xcbiAgICAgIHZhciBsZW4gPSBsZW5ndGggPiAwID8gbGVuZ3RoIDogbGVuZ3RoQnl0ZXNVVEY4KHN0cmluZ3kpICsgMTtcXG4gICAgICB2YXIgdThhcnJheSA9IG5ldyBBcnJheShsZW4pO1xcbiAgICAgIHZhciBudW1CeXRlc1dyaXR0ZW4gPSBzdHJpbmdUb1VURjhBcnJheShcXG4gICAgICAgIHN0cmluZ3ksXFxuICAgICAgICB1OGFycmF5LFxcbiAgICAgICAgMCxcXG4gICAgICAgIHU4YXJyYXkubGVuZ3RoLFxcbiAgICAgICk7XFxuICAgICAgaWYgKGRvbnRBZGROdWxsKSB1OGFycmF5Lmxlbmd0aCA9IG51bUJ5dGVzV3JpdHRlbjtcXG4gICAgICByZXR1cm4gdThhcnJheTtcXG4gICAgfTtcXG4gICAgdmFyIEZTX3N0ZGluX2dldENoYXIgPSAoKSA9PiB7XFxuICAgICAgaWYgKCFGU19zdGRpbl9nZXRDaGFyX2J1ZmZlci5sZW5ndGgpIHtcXG4gICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xcbiAgICAgICAgaWYgKFxcbiAgICAgICAgICB0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIgJiZcXG4gICAgICAgICAgdHlwZW9mIHdpbmRvdy5wcm9tcHQgPT0gXCJmdW5jdGlvblwiXFxuICAgICAgICApIHtcXG4gICAgICAgICAgcmVzdWx0ID0gd2luZG93LnByb21wdChcIklucHV0OiBcIik7XFxuICAgICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcXG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXFxcblwiO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcXG4gICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICB9XFxuICAgICAgICBGU19zdGRpbl9nZXRDaGFyX2J1ZmZlciA9IGludEFycmF5RnJvbVN0cmluZyhyZXN1bHQsIHRydWUpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gRlNfc3RkaW5fZ2V0Q2hhcl9idWZmZXIuc2hpZnQoKTtcXG4gICAgfTtcXG4gICAgdmFyIFRUWSA9IHtcXG4gICAgICB0dHlzOiBbXSxcXG4gICAgICBpbml0KCkge30sXFxuICAgICAgc2h1dGRvd24oKSB7fSxcXG4gICAgICByZWdpc3RlcihkZXYsIG9wcykge1xcbiAgICAgICAgVFRZLnR0eXNbZGV2XSA9IHsgaW5wdXQ6IFtdLCBvdXRwdXQ6IFtdLCBvcHMgfTtcXG4gICAgICAgIEZTLnJlZ2lzdGVyRGV2aWNlKGRldiwgVFRZLnN0cmVhbV9vcHMpO1xcbiAgICAgIH0sXFxuICAgICAgc3RyZWFtX29wczoge1xcbiAgICAgICAgb3BlbihzdHJlYW0pIHtcXG4gICAgICAgICAgdmFyIHR0eSA9IFRUWS50dHlzW3N0cmVhbS5ub2RlLnJkZXZdO1xcbiAgICAgICAgICBpZiAoIXR0eSkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzdHJlYW0udHR5ID0gdHR5O1xcbiAgICAgICAgICBzdHJlYW0uc2Vla2FibGUgPSBmYWxzZTtcXG4gICAgICAgIH0sXFxuICAgICAgICBjbG9zZShzdHJlYW0pIHtcXG4gICAgICAgICAgc3RyZWFtLnR0eS5vcHMuZnN5bmMoc3RyZWFtLnR0eSk7XFxuICAgICAgICB9LFxcbiAgICAgICAgZnN5bmMoc3RyZWFtKSB7XFxuICAgICAgICAgIHN0cmVhbS50dHkub3BzLmZzeW5jKHN0cmVhbS50dHkpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlYWQoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MpIHtcXG4gICAgICAgICAgaWYgKCFzdHJlYW0udHR5IHx8ICFzdHJlYW0udHR5Lm9wcy5nZXRfY2hhcikge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYwKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICB2YXIgYnl0ZXNSZWFkID0gMDtcXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XFxuICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgIHJlc3VsdCA9IHN0cmVhbS50dHkub3BzLmdldF9jaGFyKHN0cmVhbS50dHkpO1xcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkICYmIGJ5dGVzUmVhZCA9PT0gMCkge1xcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB1bmRlZmluZWQpIGJyZWFrO1xcbiAgICAgICAgICAgIGJ5dGVzUmVhZCsrO1xcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IHJlc3VsdDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoYnl0ZXNSZWFkKSB7XFxuICAgICAgICAgICAgc3RyZWFtLm5vZGUuYXRpbWUgPSBEYXRlLm5vdygpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJldHVybiBieXRlc1JlYWQ7XFxuICAgICAgICB9LFxcbiAgICAgICAgd3JpdGUoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MpIHtcXG4gICAgICAgICAgaWYgKCFzdHJlYW0udHR5IHx8ICFzdHJlYW0udHR5Lm9wcy5wdXRfY2hhcikge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYwKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgIHN0cmVhbS50dHkub3BzLnB1dF9jaGFyKHN0cmVhbS50dHksIGJ1ZmZlcltvZmZzZXQgKyBpXSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChsZW5ndGgpIHtcXG4gICAgICAgICAgICBzdHJlYW0ubm9kZS5tdGltZSA9IHN0cmVhbS5ub2RlLmN0aW1lID0gRGF0ZS5ub3coKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXR1cm4gaTtcXG4gICAgICAgIH0sXFxuICAgICAgfSxcXG4gICAgICBkZWZhdWx0X3R0eV9vcHM6IHtcXG4gICAgICAgIGdldF9jaGFyKHR0eSkge1xcbiAgICAgICAgICByZXR1cm4gRlNfc3RkaW5fZ2V0Q2hhcigpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIHB1dF9jaGFyKHR0eSwgdmFsKSB7XFxuICAgICAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSAxMCkge1xcbiAgICAgICAgICAgIG91dChVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0KSk7XFxuICAgICAgICAgICAgdHR5Lm91dHB1dCA9IFtdO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGlmICh2YWwgIT0gMCkgdHR5Lm91dHB1dC5wdXNoKHZhbCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBmc3luYyh0dHkpIHtcXG4gICAgICAgICAgaWYgKHR0eS5vdXRwdXQ/Lmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgICBvdXQoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCkpO1xcbiAgICAgICAgICAgIHR0eS5vdXRwdXQgPSBbXTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGlvY3RsX3RjZ2V0cyh0dHkpIHtcXG4gICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICBjX2lmbGFnOiAyNTg1NixcXG4gICAgICAgICAgICBjX29mbGFnOiA1LFxcbiAgICAgICAgICAgIGNfY2ZsYWc6IDE5MSxcXG4gICAgICAgICAgICBjX2xmbGFnOiAzNTM4NyxcXG4gICAgICAgICAgICBjX2NjOiBbXFxuICAgICAgICAgICAgICAzLCAyOCwgMTI3LCAyMSwgNCwgMCwgMSwgMCwgMTcsIDE5LCAyNiwgMCwgMTgsIDE1LCAyMywgMjIsIDAsIDAsXFxuICAgICAgICAgICAgICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxcbiAgICAgICAgICAgIF0sXFxuICAgICAgICAgIH07XFxuICAgICAgICB9LFxcbiAgICAgICAgaW9jdGxfdGNzZXRzKHR0eSwgb3B0aW9uYWxfYWN0aW9ucywgZGF0YSkge1xcbiAgICAgICAgICByZXR1cm4gMDtcXG4gICAgICAgIH0sXFxuICAgICAgICBpb2N0bF90aW9jZ3dpbnN6KHR0eSkge1xcbiAgICAgICAgICByZXR1cm4gWzI0LCA4MF07XFxuICAgICAgICB9LFxcbiAgICAgIH0sXFxuICAgICAgZGVmYXVsdF90dHkxX29wczoge1xcbiAgICAgICAgcHV0X2NoYXIodHR5LCB2YWwpIHtcXG4gICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IDEwKSB7XFxuICAgICAgICAgICAgZXJyKFVURjhBcnJheVRvU3RyaW5nKHR0eS5vdXRwdXQpKTtcXG4gICAgICAgICAgICB0dHkub3V0cHV0ID0gW107XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgaWYgKHZhbCAhPSAwKSB0dHkub3V0cHV0LnB1c2godmFsKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGZzeW5jKHR0eSkge1xcbiAgICAgICAgICBpZiAodHR5Lm91dHB1dD8ubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgIGVycihVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0KSk7XFxuICAgICAgICAgICAgdHR5Lm91dHB1dCA9IFtdO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgIH0sXFxuICAgIH07XFxuICAgIHZhciB6ZXJvTWVtb3J5ID0gKGFkZHJlc3MsIHNpemUpID0+IHtcXG4gICAgICBIRUFQVTguZmlsbCgwLCBhZGRyZXNzLCBhZGRyZXNzICsgc2l6ZSk7XFxuICAgIH07XFxuICAgIHZhciBhbGlnbk1lbW9yeSA9IChzaXplLCBhbGlnbm1lbnQpID0+IHtcXG4gICAgICBhc3NlcnQoYWxpZ25tZW50LCBcImFsaWdubWVudCBhcmd1bWVudCBpcyByZXF1aXJlZFwiKTtcXG4gICAgICByZXR1cm4gTWF0aC5jZWlsKHNpemUgLyBhbGlnbm1lbnQpICogYWxpZ25tZW50O1xcbiAgICB9O1xcbiAgICB2YXIgbW1hcEFsbG9jID0gKHNpemUpID0+IHtcXG4gICAgICBzaXplID0gYWxpZ25NZW1vcnkoc2l6ZSwgNjU1MzYpO1xcbiAgICAgIHZhciBwdHIgPSBfZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduKDY1NTM2LCBzaXplKTtcXG4gICAgICBpZiAocHRyKSB6ZXJvTWVtb3J5KHB0ciwgc2l6ZSk7XFxuICAgICAgcmV0dXJuIHB0cjtcXG4gICAgfTtcXG4gICAgdmFyIE1FTUZTID0ge1xcbiAgICAgIG9wc190YWJsZTogbnVsbCxcXG4gICAgICBtb3VudChtb3VudCkge1xcbiAgICAgICAgcmV0dXJuIE1FTUZTLmNyZWF0ZU5vZGUobnVsbCwgXCIvXCIsIDE2ODk1LCAwKTtcXG4gICAgICB9LFxcbiAgICAgIGNyZWF0ZU5vZGUocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpIHtcXG4gICAgICAgIGlmIChGUy5pc0Jsa2Rldihtb2RlKSB8fCBGUy5pc0ZJRk8obW9kZSkpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgTUVNRlMub3BzX3RhYmxlIHx8PSB7XFxuICAgICAgICAgIGRpcjoge1xcbiAgICAgICAgICAgIG5vZGU6IHtcXG4gICAgICAgICAgICAgIGdldGF0dHI6IE1FTUZTLm5vZGVfb3BzLmdldGF0dHIsXFxuICAgICAgICAgICAgICBzZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5zZXRhdHRyLFxcbiAgICAgICAgICAgICAgbG9va3VwOiBNRU1GUy5ub2RlX29wcy5sb29rdXAsXFxuICAgICAgICAgICAgICBta25vZDogTUVNRlMubm9kZV9vcHMubWtub2QsXFxuICAgICAgICAgICAgICByZW5hbWU6IE1FTUZTLm5vZGVfb3BzLnJlbmFtZSxcXG4gICAgICAgICAgICAgIHVubGluazogTUVNRlMubm9kZV9vcHMudW5saW5rLFxcbiAgICAgICAgICAgICAgcm1kaXI6IE1FTUZTLm5vZGVfb3BzLnJtZGlyLFxcbiAgICAgICAgICAgICAgcmVhZGRpcjogTUVNRlMubm9kZV9vcHMucmVhZGRpcixcXG4gICAgICAgICAgICAgIHN5bWxpbms6IE1FTUZTLm5vZGVfb3BzLnN5bWxpbmssXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBzdHJlYW06IHsgbGxzZWVrOiBNRU1GUy5zdHJlYW1fb3BzLmxsc2VlayB9LFxcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBmaWxlOiB7XFxuICAgICAgICAgICAgbm9kZToge1xcbiAgICAgICAgICAgICAgZ2V0YXR0cjogTUVNRlMubm9kZV9vcHMuZ2V0YXR0cixcXG4gICAgICAgICAgICAgIHNldGF0dHI6IE1FTUZTLm5vZGVfb3BzLnNldGF0dHIsXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBzdHJlYW06IHtcXG4gICAgICAgICAgICAgIGxsc2VlazogTUVNRlMuc3RyZWFtX29wcy5sbHNlZWssXFxuICAgICAgICAgICAgICByZWFkOiBNRU1GUy5zdHJlYW1fb3BzLnJlYWQsXFxuICAgICAgICAgICAgICB3cml0ZTogTUVNRlMuc3RyZWFtX29wcy53cml0ZSxcXG4gICAgICAgICAgICAgIGFsbG9jYXRlOiBNRU1GUy5zdHJlYW1fb3BzLmFsbG9jYXRlLFxcbiAgICAgICAgICAgICAgbW1hcDogTUVNRlMuc3RyZWFtX29wcy5tbWFwLFxcbiAgICAgICAgICAgICAgbXN5bmM6IE1FTUZTLnN0cmVhbV9vcHMubXN5bmMsXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgbGluazoge1xcbiAgICAgICAgICAgIG5vZGU6IHtcXG4gICAgICAgICAgICAgIGdldGF0dHI6IE1FTUZTLm5vZGVfb3BzLmdldGF0dHIsXFxuICAgICAgICAgICAgICBzZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5zZXRhdHRyLFxcbiAgICAgICAgICAgICAgcmVhZGxpbms6IE1FTUZTLm5vZGVfb3BzLnJlYWRsaW5rLFxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgc3RyZWFtOiB7fSxcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgY2hyZGV2OiB7XFxuICAgICAgICAgICAgbm9kZToge1xcbiAgICAgICAgICAgICAgZ2V0YXR0cjogTUVNRlMubm9kZV9vcHMuZ2V0YXR0cixcXG4gICAgICAgICAgICAgIHNldGF0dHI6IE1FTUZTLm5vZGVfb3BzLnNldGF0dHIsXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBzdHJlYW06IEZTLmNocmRldl9zdHJlYW1fb3BzLFxcbiAgICAgICAgICB9LFxcbiAgICAgICAgfTtcXG4gICAgICAgIHZhciBub2RlID0gRlMuY3JlYXRlTm9kZShwYXJlbnQsIG5hbWUsIG1vZGUsIGRldik7XFxuICAgICAgICBpZiAoRlMuaXNEaXIobm9kZS5tb2RlKSkge1xcbiAgICAgICAgICBub2RlLm5vZGVfb3BzID0gTUVNRlMub3BzX3RhYmxlLmRpci5ub2RlO1xcbiAgICAgICAgICBub2RlLnN0cmVhbV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuZGlyLnN0cmVhbTtcXG4gICAgICAgICAgbm9kZS5jb250ZW50cyA9IHt9O1xcbiAgICAgICAgfSBlbHNlIGlmIChGUy5pc0ZpbGUobm9kZS5tb2RlKSkge1xcbiAgICAgICAgICBub2RlLm5vZGVfb3BzID0gTUVNRlMub3BzX3RhYmxlLmZpbGUubm9kZTtcXG4gICAgICAgICAgbm9kZS5zdHJlYW1fb3BzID0gTUVNRlMub3BzX3RhYmxlLmZpbGUuc3RyZWFtO1xcbiAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IDA7XFxuICAgICAgICAgIG5vZGUuY29udGVudHMgPSBudWxsO1xcbiAgICAgICAgfSBlbHNlIGlmIChGUy5pc0xpbmsobm9kZS5tb2RlKSkge1xcbiAgICAgICAgICBub2RlLm5vZGVfb3BzID0gTUVNRlMub3BzX3RhYmxlLmxpbmsubm9kZTtcXG4gICAgICAgICAgbm9kZS5zdHJlYW1fb3BzID0gTUVNRlMub3BzX3RhYmxlLmxpbmsuc3RyZWFtO1xcbiAgICAgICAgfSBlbHNlIGlmIChGUy5pc0NocmRldihub2RlLm1vZGUpKSB7XFxuICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuY2hyZGV2Lm5vZGU7XFxuICAgICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE1FTUZTLm9wc190YWJsZS5jaHJkZXYuc3RyZWFtO1xcbiAgICAgICAgfVxcbiAgICAgICAgbm9kZS5hdGltZSA9IG5vZGUubXRpbWUgPSBub2RlLmN0aW1lID0gRGF0ZS5ub3coKTtcXG4gICAgICAgIGlmIChwYXJlbnQpIHtcXG4gICAgICAgICAgcGFyZW50LmNvbnRlbnRzW25hbWVdID0gbm9kZTtcXG4gICAgICAgICAgcGFyZW50LmF0aW1lID0gcGFyZW50Lm10aW1lID0gcGFyZW50LmN0aW1lID0gbm9kZS5hdGltZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBub2RlO1xcbiAgICAgIH0sXFxuICAgICAgZ2V0RmlsZURhdGFBc1R5cGVkQXJyYXkobm9kZSkge1xcbiAgICAgICAgaWYgKCFub2RlLmNvbnRlbnRzKSByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XFxuICAgICAgICBpZiAobm9kZS5jb250ZW50cy5zdWJhcnJheSlcXG4gICAgICAgICAgcmV0dXJuIG5vZGUuY29udGVudHMuc3ViYXJyYXkoMCwgbm9kZS51c2VkQnl0ZXMpO1xcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5vZGUuY29udGVudHMpO1xcbiAgICAgIH0sXFxuICAgICAgZXhwYW5kRmlsZVN0b3JhZ2Uobm9kZSwgbmV3Q2FwYWNpdHkpIHtcXG4gICAgICAgIHZhciBwcmV2Q2FwYWNpdHkgPSBub2RlLmNvbnRlbnRzID8gbm9kZS5jb250ZW50cy5sZW5ndGggOiAwO1xcbiAgICAgICAgaWYgKHByZXZDYXBhY2l0eSA+PSBuZXdDYXBhY2l0eSkgcmV0dXJuO1xcbiAgICAgICAgdmFyIENBUEFDSVRZX0RPVUJMSU5HX01BWCA9IDEwMjQgKiAxMDI0O1xcbiAgICAgICAgbmV3Q2FwYWNpdHkgPSBNYXRoLm1heChcXG4gICAgICAgICAgbmV3Q2FwYWNpdHksXFxuICAgICAgICAgIChwcmV2Q2FwYWNpdHkgKlxcbiAgICAgICAgICAgIChwcmV2Q2FwYWNpdHkgPCBDQVBBQ0lUWV9ET1VCTElOR19NQVggPyAyIDogMS4xMjUpKSA+Pj5cXG4gICAgICAgICAgICAwLFxcbiAgICAgICAgKTtcXG4gICAgICAgIGlmIChwcmV2Q2FwYWNpdHkgIT0gMCkgbmV3Q2FwYWNpdHkgPSBNYXRoLm1heChuZXdDYXBhY2l0eSwgMjU2KTtcXG4gICAgICAgIHZhciBvbGRDb250ZW50cyA9IG5vZGUuY29udGVudHM7XFxuICAgICAgICBub2RlLmNvbnRlbnRzID0gbmV3IFVpbnQ4QXJyYXkobmV3Q2FwYWNpdHkpO1xcbiAgICAgICAgaWYgKG5vZGUudXNlZEJ5dGVzID4gMClcXG4gICAgICAgICAgbm9kZS5jb250ZW50cy5zZXQob2xkQ29udGVudHMuc3ViYXJyYXkoMCwgbm9kZS51c2VkQnl0ZXMpLCAwKTtcXG4gICAgICB9LFxcbiAgICAgIHJlc2l6ZUZpbGVTdG9yYWdlKG5vZGUsIG5ld1NpemUpIHtcXG4gICAgICAgIGlmIChub2RlLnVzZWRCeXRlcyA9PSBuZXdTaXplKSByZXR1cm47XFxuICAgICAgICBpZiAobmV3U2l6ZSA9PSAwKSB7XFxuICAgICAgICAgIG5vZGUuY29udGVudHMgPSBudWxsO1xcbiAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IDA7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB2YXIgb2xkQ29udGVudHMgPSBub2RlLmNvbnRlbnRzO1xcbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbmV3IFVpbnQ4QXJyYXkobmV3U2l6ZSk7XFxuICAgICAgICAgIGlmIChvbGRDb250ZW50cykge1xcbiAgICAgICAgICAgIG5vZGUuY29udGVudHMuc2V0KFxcbiAgICAgICAgICAgICAgb2xkQ29udGVudHMuc3ViYXJyYXkoMCwgTWF0aC5taW4obmV3U2l6ZSwgbm9kZS51c2VkQnl0ZXMpKSxcXG4gICAgICAgICAgICApO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gbmV3U2l6ZTtcXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgIG5vZGVfb3BzOiB7XFxuICAgICAgICBnZXRhdHRyKG5vZGUpIHtcXG4gICAgICAgICAgdmFyIGF0dHIgPSB7fTtcXG4gICAgICAgICAgYXR0ci5kZXYgPSBGUy5pc0NocmRldihub2RlLm1vZGUpID8gbm9kZS5pZCA6IDE7XFxuICAgICAgICAgIGF0dHIuaW5vID0gbm9kZS5pZDtcXG4gICAgICAgICAgYXR0ci5tb2RlID0gbm9kZS5tb2RlO1xcbiAgICAgICAgICBhdHRyLm5saW5rID0gMTtcXG4gICAgICAgICAgYXR0ci51aWQgPSAwO1xcbiAgICAgICAgICBhdHRyLmdpZCA9IDA7XFxuICAgICAgICAgIGF0dHIucmRldiA9IG5vZGUucmRldjtcXG4gICAgICAgICAgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHtcXG4gICAgICAgICAgICBhdHRyLnNpemUgPSA0MDk2O1xcbiAgICAgICAgICB9IGVsc2UgaWYgKEZTLmlzRmlsZShub2RlLm1vZGUpKSB7XFxuICAgICAgICAgICAgYXR0ci5zaXplID0gbm9kZS51c2VkQnl0ZXM7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoRlMuaXNMaW5rKG5vZGUubW9kZSkpIHtcXG4gICAgICAgICAgICBhdHRyLnNpemUgPSBub2RlLmxpbmsubGVuZ3RoO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGF0dHIuc2l6ZSA9IDA7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgYXR0ci5hdGltZSA9IG5ldyBEYXRlKG5vZGUuYXRpbWUpO1xcbiAgICAgICAgICBhdHRyLm10aW1lID0gbmV3IERhdGUobm9kZS5tdGltZSk7XFxuICAgICAgICAgIGF0dHIuY3RpbWUgPSBuZXcgRGF0ZShub2RlLmN0aW1lKTtcXG4gICAgICAgICAgYXR0ci5ibGtzaXplID0gNDA5NjtcXG4gICAgICAgICAgYXR0ci5ibG9ja3MgPSBNYXRoLmNlaWwoYXR0ci5zaXplIC8gYXR0ci5ibGtzaXplKTtcXG4gICAgICAgICAgcmV0dXJuIGF0dHI7XFxuICAgICAgICB9LFxcbiAgICAgICAgc2V0YXR0cihub2RlLCBhdHRyKSB7XFxuICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIFtcIm1vZGVcIiwgXCJhdGltZVwiLCBcIm10aW1lXCIsIFwiY3RpbWVcIl0pIHtcXG4gICAgICAgICAgICBpZiAoYXR0cltrZXldICE9IG51bGwpIHtcXG4gICAgICAgICAgICAgIG5vZGVba2V5XSA9IGF0dHJba2V5XTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKGF0dHIuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgTUVNRlMucmVzaXplRmlsZVN0b3JhZ2Uobm9kZSwgYXR0ci5zaXplKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGxvb2t1cChwYXJlbnQsIG5hbWUpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIG1rbm9kKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KSB7XFxuICAgICAgICAgIHJldHVybiBNRU1GUy5jcmVhdGVOb2RlKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KTtcXG4gICAgICAgIH0sXFxuICAgICAgICByZW5hbWUob2xkX25vZGUsIG5ld19kaXIsIG5ld19uYW1lKSB7XFxuICAgICAgICAgIHZhciBuZXdfbm9kZTtcXG4gICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBuZXdfbm9kZSA9IEZTLmxvb2t1cE5vZGUobmV3X2RpciwgbmV3X25hbWUpO1xcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxcbiAgICAgICAgICBpZiAobmV3X25vZGUpIHtcXG4gICAgICAgICAgICBpZiAoRlMuaXNEaXIob2xkX25vZGUubW9kZSkpIHtcXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gbmV3X25vZGUuY29udGVudHMpIHtcXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTUpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBGUy5oYXNoUmVtb3ZlTm9kZShuZXdfbm9kZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgZGVsZXRlIG9sZF9ub2RlLnBhcmVudC5jb250ZW50c1tvbGRfbm9kZS5uYW1lXTtcXG4gICAgICAgICAgbmV3X2Rpci5jb250ZW50c1tuZXdfbmFtZV0gPSBvbGRfbm9kZTtcXG4gICAgICAgICAgb2xkX25vZGUubmFtZSA9IG5ld19uYW1lO1xcbiAgICAgICAgICBuZXdfZGlyLmN0aW1lID1cXG4gICAgICAgICAgICBuZXdfZGlyLm10aW1lID1cXG4gICAgICAgICAgICBvbGRfbm9kZS5wYXJlbnQuY3RpbWUgPVxcbiAgICAgICAgICAgIG9sZF9ub2RlLnBhcmVudC5tdGltZSA9XFxuICAgICAgICAgICAgICBEYXRlLm5vdygpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIHVubGluayhwYXJlbnQsIG5hbWUpIHtcXG4gICAgICAgICAgZGVsZXRlIHBhcmVudC5jb250ZW50c1tuYW1lXTtcXG4gICAgICAgICAgcGFyZW50LmN0aW1lID0gcGFyZW50Lm10aW1lID0gRGF0ZS5ub3coKTtcXG4gICAgICAgIH0sXFxuICAgICAgICBybWRpcihwYXJlbnQsIG5hbWUpIHtcXG4gICAgICAgICAgdmFyIG5vZGUgPSBGUy5sb29rdXBOb2RlKHBhcmVudCwgbmFtZSk7XFxuICAgICAgICAgIGZvciAodmFyIGkgaW4gbm9kZS5jb250ZW50cykge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU1KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBkZWxldGUgcGFyZW50LmNvbnRlbnRzW25hbWVdO1xcbiAgICAgICAgICBwYXJlbnQuY3RpbWUgPSBwYXJlbnQubXRpbWUgPSBEYXRlLm5vdygpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlYWRkaXIobm9kZSkge1xcbiAgICAgICAgICByZXR1cm4gW1wiLlwiLCBcIi4uXCIsIC4uLk9iamVjdC5rZXlzKG5vZGUuY29udGVudHMpXTtcXG4gICAgICAgIH0sXFxuICAgICAgICBzeW1saW5rKHBhcmVudCwgbmV3bmFtZSwgb2xkcGF0aCkge1xcbiAgICAgICAgICB2YXIgbm9kZSA9IE1FTUZTLmNyZWF0ZU5vZGUocGFyZW50LCBuZXduYW1lLCA1MTEgfCA0MDk2MCwgMCk7XFxuICAgICAgICAgIG5vZGUubGluayA9IG9sZHBhdGg7XFxuICAgICAgICAgIHJldHVybiBub2RlO1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlYWRsaW5rKG5vZGUpIHtcXG4gICAgICAgICAgaWYgKCFGUy5pc0xpbmsobm9kZS5tb2RlKSkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXR1cm4gbm9kZS5saW5rO1xcbiAgICAgICAgfSxcXG4gICAgICB9LFxcbiAgICAgIHN0cmVhbV9vcHM6IHtcXG4gICAgICAgIHJlYWQoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xcbiAgICAgICAgICB2YXIgY29udGVudHMgPSBzdHJlYW0ubm9kZS5jb250ZW50cztcXG4gICAgICAgICAgaWYgKHBvc2l0aW9uID49IHN0cmVhbS5ub2RlLnVzZWRCeXRlcykgcmV0dXJuIDA7XFxuICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oc3RyZWFtLm5vZGUudXNlZEJ5dGVzIC0gcG9zaXRpb24sIGxlbmd0aCk7XFxuICAgICAgICAgIGFzc2VydChzaXplID49IDApO1xcbiAgICAgICAgICBpZiAoc2l6ZSA+IDggJiYgY29udGVudHMuc3ViYXJyYXkpIHtcXG4gICAgICAgICAgICBidWZmZXIuc2V0KGNvbnRlbnRzLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArIHNpemUpLCBvZmZzZXQpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKVxcbiAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIGldID0gY29udGVudHNbcG9zaXRpb24gKyBpXTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXR1cm4gc2l6ZTtcXG4gICAgICAgIH0sXFxuICAgICAgICB3cml0ZShzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYW5Pd24pIHtcXG4gICAgICAgICAgYXNzZXJ0KCEoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKTtcXG4gICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIgPT09IEhFQVA4LmJ1ZmZlcikge1xcbiAgICAgICAgICAgIGNhbk93biA9IGZhbHNlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmICghbGVuZ3RoKSByZXR1cm4gMDtcXG4gICAgICAgICAgdmFyIG5vZGUgPSBzdHJlYW0ubm9kZTtcXG4gICAgICAgICAgbm9kZS5tdGltZSA9IG5vZGUuY3RpbWUgPSBEYXRlLm5vdygpO1xcbiAgICAgICAgICBpZiAoYnVmZmVyLnN1YmFycmF5ICYmICghbm9kZS5jb250ZW50cyB8fCBub2RlLmNvbnRlbnRzLnN1YmFycmF5KSkge1xcbiAgICAgICAgICAgIGlmIChjYW5Pd24pIHtcXG4gICAgICAgICAgICAgIGFzc2VydChcXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPT09IDAsXFxuICAgICAgICAgICAgICAgIFwiY2FuT3duIG11c3QgaW1wbHkgbm8gd2VpcmQgcG9zaXRpb24gaW5zaWRlIHRoZSBmaWxlXCIsXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgbm9kZS5jb250ZW50cyA9IGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XFxuICAgICAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IGxlbmd0aDtcXG4gICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLnVzZWRCeXRlcyA9PT0gMCAmJiBwb3NpdGlvbiA9PT0gMCkge1xcbiAgICAgICAgICAgICAgbm9kZS5jb250ZW50cyA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XFxuICAgICAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IGxlbmd0aDtcXG4gICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiArIGxlbmd0aCA8PSBub2RlLnVzZWRCeXRlcykge1xcbiAgICAgICAgICAgICAgbm9kZS5jb250ZW50cy5zZXQoXFxuICAgICAgICAgICAgICAgIGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCksXFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLFxcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIE1FTUZTLmV4cGFuZEZpbGVTdG9yYWdlKG5vZGUsIHBvc2l0aW9uICsgbGVuZ3RoKTtcXG4gICAgICAgICAgaWYgKG5vZGUuY29udGVudHMuc3ViYXJyYXkgJiYgYnVmZmVyLnN1YmFycmF5KSB7XFxuICAgICAgICAgICAgbm9kZS5jb250ZW50cy5zZXQoXFxuICAgICAgICAgICAgICBidWZmZXIuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpLFxcbiAgICAgICAgICAgICAgcG9zaXRpb24sXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICBub2RlLmNvbnRlbnRzW3Bvc2l0aW9uICsgaV0gPSBidWZmZXJbb2Zmc2V0ICsgaV07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gTWF0aC5tYXgobm9kZS51c2VkQnl0ZXMsIHBvc2l0aW9uICsgbGVuZ3RoKTtcXG4gICAgICAgICAgcmV0dXJuIGxlbmd0aDtcXG4gICAgICAgIH0sXFxuICAgICAgICBsbHNlZWsoc3RyZWFtLCBvZmZzZXQsIHdoZW5jZSkge1xcbiAgICAgICAgICB2YXIgcG9zaXRpb24gPSBvZmZzZXQ7XFxuICAgICAgICAgIGlmICh3aGVuY2UgPT09IDEpIHtcXG4gICAgICAgICAgICBwb3NpdGlvbiArPSBzdHJlYW0ucG9zaXRpb247XFxuICAgICAgICAgIH0gZWxzZSBpZiAod2hlbmNlID09PSAyKSB7XFxuICAgICAgICAgICAgaWYgKEZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSkge1xcbiAgICAgICAgICAgICAgcG9zaXRpb24gKz0gc3RyZWFtLm5vZGUudXNlZEJ5dGVzO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcXG4gICAgICAgIH0sXFxuICAgICAgICBhbGxvY2F0ZShzdHJlYW0sIG9mZnNldCwgbGVuZ3RoKSB7XFxuICAgICAgICAgIE1FTUZTLmV4cGFuZEZpbGVTdG9yYWdlKHN0cmVhbS5ub2RlLCBvZmZzZXQgKyBsZW5ndGgpO1xcbiAgICAgICAgICBzdHJlYW0ubm9kZS51c2VkQnl0ZXMgPSBNYXRoLm1heChcXG4gICAgICAgICAgICBzdHJlYW0ubm9kZS51c2VkQnl0ZXMsXFxuICAgICAgICAgICAgb2Zmc2V0ICsgbGVuZ3RoLFxcbiAgICAgICAgICApO1xcbiAgICAgICAgfSxcXG4gICAgICAgIG1tYXAoc3RyZWFtLCBsZW5ndGgsIHBvc2l0aW9uLCBwcm90LCBmbGFncykge1xcbiAgICAgICAgICBpZiAoIUZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICB2YXIgcHRyO1xcbiAgICAgICAgICB2YXIgYWxsb2NhdGVkO1xcbiAgICAgICAgICB2YXIgY29udGVudHMgPSBzdHJlYW0ubm9kZS5jb250ZW50cztcXG4gICAgICAgICAgaWYgKCEoZmxhZ3MgJiAyKSAmJiBjb250ZW50cyAmJiBjb250ZW50cy5idWZmZXIgPT09IEhFQVA4LmJ1ZmZlcikge1xcbiAgICAgICAgICAgIGFsbG9jYXRlZCA9IGZhbHNlO1xcbiAgICAgICAgICAgIHB0ciA9IGNvbnRlbnRzLmJ5dGVPZmZzZXQ7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgYWxsb2NhdGVkID0gdHJ1ZTtcXG4gICAgICAgICAgICBwdHIgPSBtbWFwQWxsb2MobGVuZ3RoKTtcXG4gICAgICAgICAgICBpZiAoIXB0cikge1xcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoY29udGVudHMpIHtcXG4gICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+IDAgfHwgcG9zaXRpb24gKyBsZW5ndGggPCBjb250ZW50cy5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRzLnN1YmFycmF5KSB7XFxuICAgICAgICAgICAgICAgICAgY29udGVudHMgPSBjb250ZW50cy5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBsZW5ndGgpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoXFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyxcXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLFxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gKyBsZW5ndGgsXFxuICAgICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgSEVBUDguc2V0KGNvbnRlbnRzLCBwdHIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXR1cm4geyBwdHIsIGFsbG9jYXRlZCB9O1xcbiAgICAgICAgfSxcXG4gICAgICAgIG1zeW5jKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgbW1hcEZsYWdzKSB7XFxuICAgICAgICAgIE1FTUZTLnN0cmVhbV9vcHMud3JpdGUoc3RyZWFtLCBidWZmZXIsIDAsIGxlbmd0aCwgb2Zmc2V0LCBmYWxzZSk7XFxuICAgICAgICAgIHJldHVybiAwO1xcbiAgICAgICAgfSxcXG4gICAgICB9LFxcbiAgICB9O1xcbiAgICB2YXIgYXN5bmNMb2FkID0gYXN5bmMgKHVybCkgPT4ge1xcbiAgICAgIHZhciBhcnJheUJ1ZmZlciA9IGF3YWl0IHJlYWRBc3luYyh1cmwpO1xcbiAgICAgIGFzc2VydChcXG4gICAgICAgIGFycmF5QnVmZmVyLFxcbiAgICAgICAgYExvYWRpbmcgZGF0YSBmaWxlIFwiJHt1cmx9XCIgZmFpbGVkIChubyBhcnJheUJ1ZmZlcikuYCxcXG4gICAgICApO1xcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XFxuICAgIH07XFxuICAgIGFzeW5jTG9hZC5pc0FzeW5jID0gdHJ1ZTtcXG4gICAgdmFyIEZTX2NyZWF0ZURhdGFGaWxlID0gKFxcbiAgICAgIHBhcmVudCxcXG4gICAgICBuYW1lLFxcbiAgICAgIGZpbGVEYXRhLFxcbiAgICAgIGNhblJlYWQsXFxuICAgICAgY2FuV3JpdGUsXFxuICAgICAgY2FuT3duLFxcbiAgICApID0+IHtcXG4gICAgICBGUy5jcmVhdGVEYXRhRmlsZShwYXJlbnQsIG5hbWUsIGZpbGVEYXRhLCBjYW5SZWFkLCBjYW5Xcml0ZSwgY2FuT3duKTtcXG4gICAgfTtcXG4gICAgdmFyIHByZWxvYWRQbHVnaW5zID0gTW9kdWxlW1wicHJlbG9hZFBsdWdpbnNcIl0gfHwgW107XFxuICAgIHZhciBGU19oYW5kbGVkQnlQcmVsb2FkUGx1Z2luID0gKGJ5dGVBcnJheSwgZnVsbG5hbWUsIGZpbmlzaCwgb25lcnJvcikgPT4ge1xcbiAgICAgIGlmICh0eXBlb2YgQnJvd3NlciAhPSBcInVuZGVmaW5lZFwiKSBCcm93c2VyLmluaXQoKTtcXG4gICAgICB2YXIgaGFuZGxlZCA9IGZhbHNlO1xcbiAgICAgIHByZWxvYWRQbHVnaW5zLmZvckVhY2goKHBsdWdpbikgPT4ge1xcbiAgICAgICAgaWYgKGhhbmRsZWQpIHJldHVybjtcXG4gICAgICAgIGlmIChwbHVnaW5bXCJjYW5IYW5kbGVcIl0oZnVsbG5hbWUpKSB7XFxuICAgICAgICAgIHBsdWdpbltcImhhbmRsZVwiXShieXRlQXJyYXksIGZ1bGxuYW1lLCBmaW5pc2gsIG9uZXJyb3IpO1xcbiAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gaGFuZGxlZDtcXG4gICAgfTtcXG4gICAgdmFyIEZTX2NyZWF0ZVByZWxvYWRlZEZpbGUgPSAoXFxuICAgICAgcGFyZW50LFxcbiAgICAgIG5hbWUsXFxuICAgICAgdXJsLFxcbiAgICAgIGNhblJlYWQsXFxuICAgICAgY2FuV3JpdGUsXFxuICAgICAgb25sb2FkLFxcbiAgICAgIG9uZXJyb3IsXFxuICAgICAgZG9udENyZWF0ZUZpbGUsXFxuICAgICAgY2FuT3duLFxcbiAgICAgIHByZUZpbmlzaCxcXG4gICAgKSA9PiB7XFxuICAgICAgdmFyIGZ1bGxuYW1lID0gbmFtZSA/IFBBVEhfRlMucmVzb2x2ZShQQVRILmpvaW4yKHBhcmVudCwgbmFtZSkpIDogcGFyZW50O1xcbiAgICAgIHZhciBkZXAgPSBnZXRVbmlxdWVSdW5EZXBlbmRlbmN5KGBjcCAke2Z1bGxuYW1lfWApO1xcbiAgICAgIGZ1bmN0aW9uIHByb2Nlc3NEYXRhKGJ5dGVBcnJheSkge1xcbiAgICAgICAgZnVuY3Rpb24gZmluaXNoKGJ5dGVBcnJheSkge1xcbiAgICAgICAgICBwcmVGaW5pc2g/LigpO1xcbiAgICAgICAgICBpZiAoIWRvbnRDcmVhdGVGaWxlKSB7XFxuICAgICAgICAgICAgRlNfY3JlYXRlRGF0YUZpbGUoXFxuICAgICAgICAgICAgICBwYXJlbnQsXFxuICAgICAgICAgICAgICBuYW1lLFxcbiAgICAgICAgICAgICAgYnl0ZUFycmF5LFxcbiAgICAgICAgICAgICAgY2FuUmVhZCxcXG4gICAgICAgICAgICAgIGNhbldyaXRlLFxcbiAgICAgICAgICAgICAgY2FuT3duLFxcbiAgICAgICAgICAgICk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgb25sb2FkPy4oKTtcXG4gICAgICAgICAgcmVtb3ZlUnVuRGVwZW5kZW5jeShkZXApO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKFxcbiAgICAgICAgICBGU19oYW5kbGVkQnlQcmVsb2FkUGx1Z2luKGJ5dGVBcnJheSwgZnVsbG5hbWUsIGZpbmlzaCwgKCkgPT4ge1xcbiAgICAgICAgICAgIG9uZXJyb3I/LigpO1xcbiAgICAgICAgICAgIHJlbW92ZVJ1bkRlcGVuZGVuY3koZGVwKTtcXG4gICAgICAgICAgfSlcXG4gICAgICAgICkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICBmaW5pc2goYnl0ZUFycmF5KTtcXG4gICAgICB9XFxuICAgICAgYWRkUnVuRGVwZW5kZW5jeShkZXApO1xcbiAgICAgIGlmICh0eXBlb2YgdXJsID09IFwic3RyaW5nXCIpIHtcXG4gICAgICAgIGFzeW5jTG9hZCh1cmwpLnRoZW4ocHJvY2Vzc0RhdGEsIG9uZXJyb3IpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBwcm9jZXNzRGF0YSh1cmwpO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gICAgdmFyIEZTX21vZGVTdHJpbmdUb0ZsYWdzID0gKHN0cikgPT4ge1xcbiAgICAgIHZhciBmbGFnTW9kZXMgPSB7XFxuICAgICAgICByOiAwLFxcbiAgICAgICAgXCJyK1wiOiAyLFxcbiAgICAgICAgdzogNTEyIHwgNjQgfCAxLFxcbiAgICAgICAgXCJ3K1wiOiA1MTIgfCA2NCB8IDIsXFxuICAgICAgICBhOiAxMDI0IHwgNjQgfCAxLFxcbiAgICAgICAgXCJhK1wiOiAxMDI0IHwgNjQgfCAyLFxcbiAgICAgIH07XFxuICAgICAgdmFyIGZsYWdzID0gZmxhZ01vZGVzW3N0cl07XFxuICAgICAgaWYgKHR5cGVvZiBmbGFncyA9PSBcInVuZGVmaW5lZFwiKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZmlsZSBvcGVuIG1vZGU6ICR7c3RyfWApO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gZmxhZ3M7XFxuICAgIH07XFxuICAgIHZhciBGU19nZXRNb2RlID0gKGNhblJlYWQsIGNhbldyaXRlKSA9PiB7XFxuICAgICAgdmFyIG1vZGUgPSAwO1xcbiAgICAgIGlmIChjYW5SZWFkKSBtb2RlIHw9IDI5MiB8IDczO1xcbiAgICAgIGlmIChjYW5Xcml0ZSkgbW9kZSB8PSAxNDY7XFxuICAgICAgcmV0dXJuIG1vZGU7XFxuICAgIH07XFxuICAgIHZhciBzdHJFcnJvciA9IChlcnJubykgPT4gVVRGOFRvU3RyaW5nKF9zdHJlcnJvcihlcnJubykpO1xcbiAgICB2YXIgRVJSTk9fQ09ERVMgPSB7XFxuICAgICAgRVBFUk06IDYzLFxcbiAgICAgIEVOT0VOVDogNDQsXFxuICAgICAgRVNSQ0g6IDcxLFxcbiAgICAgIEVJTlRSOiAyNyxcXG4gICAgICBFSU86IDI5LFxcbiAgICAgIEVOWElPOiA2MCxcXG4gICAgICBFMkJJRzogMSxcXG4gICAgICBFTk9FWEVDOiA0NSxcXG4gICAgICBFQkFERjogOCxcXG4gICAgICBFQ0hJTEQ6IDEyLFxcbiAgICAgIEVBR0FJTjogNixcXG4gICAgICBFV09VTERCTE9DSzogNixcXG4gICAgICBFTk9NRU06IDQ4LFxcbiAgICAgIEVBQ0NFUzogMixcXG4gICAgICBFRkFVTFQ6IDIxLFxcbiAgICAgIEVOT1RCTEs6IDEwNSxcXG4gICAgICBFQlVTWTogMTAsXFxuICAgICAgRUVYSVNUOiAyMCxcXG4gICAgICBFWERFVjogNzUsXFxuICAgICAgRU5PREVWOiA0MyxcXG4gICAgICBFTk9URElSOiA1NCxcXG4gICAgICBFSVNESVI6IDMxLFxcbiAgICAgIEVJTlZBTDogMjgsXFxuICAgICAgRU5GSUxFOiA0MSxcXG4gICAgICBFTUZJTEU6IDMzLFxcbiAgICAgIEVOT1RUWTogNTksXFxuICAgICAgRVRYVEJTWTogNzQsXFxuICAgICAgRUZCSUc6IDIyLFxcbiAgICAgIEVOT1NQQzogNTEsXFxuICAgICAgRVNQSVBFOiA3MCxcXG4gICAgICBFUk9GUzogNjksXFxuICAgICAgRU1MSU5LOiAzNCxcXG4gICAgICBFUElQRTogNjQsXFxuICAgICAgRURPTTogMTgsXFxuICAgICAgRVJBTkdFOiA2OCxcXG4gICAgICBFTk9NU0c6IDQ5LFxcbiAgICAgIEVJRFJNOiAyNCxcXG4gICAgICBFQ0hSTkc6IDEwNixcXG4gICAgICBFTDJOU1lOQzogMTU2LFxcbiAgICAgIEVMM0hMVDogMTA3LFxcbiAgICAgIEVMM1JTVDogMTA4LFxcbiAgICAgIEVMTlJORzogMTA5LFxcbiAgICAgIEVVTkFUQ0g6IDExMCxcXG4gICAgICBFTk9DU0k6IDExMSxcXG4gICAgICBFTDJITFQ6IDExMixcXG4gICAgICBFREVBRExLOiAxNixcXG4gICAgICBFTk9MQ0s6IDQ2LFxcbiAgICAgIEVCQURFOiAxMTMsXFxuICAgICAgRUJBRFI6IDExNCxcXG4gICAgICBFWEZVTEw6IDExNSxcXG4gICAgICBFTk9BTk86IDEwNCxcXG4gICAgICBFQkFEUlFDOiAxMDMsXFxuICAgICAgRUJBRFNMVDogMTAyLFxcbiAgICAgIEVERUFETE9DSzogMTYsXFxuICAgICAgRUJGT05UOiAxMDEsXFxuICAgICAgRU5PU1RSOiAxMDAsXFxuICAgICAgRU5PREFUQTogMTE2LFxcbiAgICAgIEVUSU1FOiAxMTcsXFxuICAgICAgRU5PU1I6IDExOCxcXG4gICAgICBFTk9ORVQ6IDExOSxcXG4gICAgICBFTk9QS0c6IDEyMCxcXG4gICAgICBFUkVNT1RFOiAxMjEsXFxuICAgICAgRU5PTElOSzogNDcsXFxuICAgICAgRUFEVjogMTIyLFxcbiAgICAgIEVTUk1OVDogMTIzLFxcbiAgICAgIEVDT01NOiAxMjQsXFxuICAgICAgRVBST1RPOiA2NSxcXG4gICAgICBFTVVMVElIT1A6IDM2LFxcbiAgICAgIEVET1RET1Q6IDEyNSxcXG4gICAgICBFQkFETVNHOiA5LFxcbiAgICAgIEVOT1RVTklROiAxMjYsXFxuICAgICAgRUJBREZEOiAxMjcsXFxuICAgICAgRVJFTUNIRzogMTI4LFxcbiAgICAgIEVMSUJBQ0M6IDEyOSxcXG4gICAgICBFTElCQkFEOiAxMzAsXFxuICAgICAgRUxJQlNDTjogMTMxLFxcbiAgICAgIEVMSUJNQVg6IDEzMixcXG4gICAgICBFTElCRVhFQzogMTMzLFxcbiAgICAgIEVOT1NZUzogNTIsXFxuICAgICAgRU5PVEVNUFRZOiA1NSxcXG4gICAgICBFTkFNRVRPT0xPTkc6IDM3LFxcbiAgICAgIEVMT09QOiAzMixcXG4gICAgICBFT1BOT1RTVVBQOiAxMzgsXFxuICAgICAgRVBGTk9TVVBQT1JUOiAxMzksXFxuICAgICAgRUNPTk5SRVNFVDogMTUsXFxuICAgICAgRU5PQlVGUzogNDIsXFxuICAgICAgRUFGTk9TVVBQT1JUOiA1LFxcbiAgICAgIEVQUk9UT1RZUEU6IDY3LFxcbiAgICAgIEVOT1RTT0NLOiA1NyxcXG4gICAgICBFTk9QUk9UT09QVDogNTAsXFxuICAgICAgRVNIVVRET1dOOiAxNDAsXFxuICAgICAgRUNPTk5SRUZVU0VEOiAxNCxcXG4gICAgICBFQUREUklOVVNFOiAzLFxcbiAgICAgIEVDT05OQUJPUlRFRDogMTMsXFxuICAgICAgRU5FVFVOUkVBQ0g6IDQwLFxcbiAgICAgIEVORVRET1dOOiAzOCxcXG4gICAgICBFVElNRURPVVQ6IDczLFxcbiAgICAgIEVIT1NURE9XTjogMTQyLFxcbiAgICAgIEVIT1NUVU5SRUFDSDogMjMsXFxuICAgICAgRUlOUFJPR1JFU1M6IDI2LFxcbiAgICAgIEVBTFJFQURZOiA3LFxcbiAgICAgIEVERVNUQUREUlJFUTogMTcsXFxuICAgICAgRU1TR1NJWkU6IDM1LFxcbiAgICAgIEVQUk9UT05PU1VQUE9SVDogNjYsXFxuICAgICAgRVNPQ0tUTk9TVVBQT1JUOiAxMzcsXFxuICAgICAgRUFERFJOT1RBVkFJTDogNCxcXG4gICAgICBFTkVUUkVTRVQ6IDM5LFxcbiAgICAgIEVJU0NPTk46IDMwLFxcbiAgICAgIEVOT1RDT05OOiA1MyxcXG4gICAgICBFVE9PTUFOWVJFRlM6IDE0MSxcXG4gICAgICBFVVNFUlM6IDEzNixcXG4gICAgICBFRFFVT1Q6IDE5LFxcbiAgICAgIEVTVEFMRTogNzIsXFxuICAgICAgRU5PVFNVUDogMTM4LFxcbiAgICAgIEVOT01FRElVTTogMTQ4LFxcbiAgICAgIEVJTFNFUTogMjUsXFxuICAgICAgRU9WRVJGTE9XOiA2MSxcXG4gICAgICBFQ0FOQ0VMRUQ6IDExLFxcbiAgICAgIEVOT1RSRUNPVkVSQUJMRTogNTYsXFxuICAgICAgRU9XTkVSREVBRDogNjIsXFxuICAgICAgRVNUUlBJUEU6IDEzNSxcXG4gICAgfTtcXG4gICAgdmFyIEZTID0ge1xcbiAgICAgIHJvb3Q6IG51bGwsXFxuICAgICAgbW91bnRzOiBbXSxcXG4gICAgICBkZXZpY2VzOiB7fSxcXG4gICAgICBzdHJlYW1zOiBbXSxcXG4gICAgICBuZXh0SW5vZGU6IDEsXFxuICAgICAgbmFtZVRhYmxlOiBudWxsLFxcbiAgICAgIGN1cnJlbnRQYXRoOiBcIi9cIixcXG4gICAgICBpbml0aWFsaXplZDogZmFsc2UsXFxuICAgICAgaWdub3JlUGVybWlzc2lvbnM6IHRydWUsXFxuICAgICAgRXJybm9FcnJvcjogY2xhc3MgZXh0ZW5kcyBFcnJvciB7XFxuICAgICAgICBuYW1lID0gXCJFcnJub0Vycm9yXCI7XFxuICAgICAgICBjb25zdHJ1Y3RvcihlcnJubykge1xcbiAgICAgICAgICBzdXBlcihydW50aW1lSW5pdGlhbGl6ZWQgPyBzdHJFcnJvcihlcnJubykgOiBcIlwiKTtcXG4gICAgICAgICAgdGhpcy5lcnJubyA9IGVycm5vO1xcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gRVJSTk9fQ09ERVMpIHtcXG4gICAgICAgICAgICBpZiAoRVJSTk9fQ09ERVNba2V5XSA9PT0gZXJybm8pIHtcXG4gICAgICAgICAgICAgIHRoaXMuY29kZSA9IGtleTtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgZmlsZXN5c3RlbXM6IG51bGwsXFxuICAgICAgc3luY0ZTUmVxdWVzdHM6IDAsXFxuICAgICAgcmVhZEZpbGVzOiB7fSxcXG4gICAgICBGU1N0cmVhbTogY2xhc3Mge1xcbiAgICAgICAgc2hhcmVkID0ge307XFxuICAgICAgICBnZXQgb2JqZWN0KCkge1xcbiAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2V0IG9iamVjdCh2YWwpIHtcXG4gICAgICAgICAgdGhpcy5ub2RlID0gdmFsO1xcbiAgICAgICAgfVxcbiAgICAgICAgZ2V0IGlzUmVhZCgpIHtcXG4gICAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMjA5NzE1NSkgIT09IDE7XFxuICAgICAgICB9XFxuICAgICAgICBnZXQgaXNXcml0ZSgpIHtcXG4gICAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMjA5NzE1NSkgIT09IDA7XFxuICAgICAgICB9XFxuICAgICAgICBnZXQgaXNBcHBlbmQoKSB7XFxuICAgICAgICAgIHJldHVybiB0aGlzLmZsYWdzICYgMTAyNDtcXG4gICAgICAgIH1cXG4gICAgICAgIGdldCBmbGFncygpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2hhcmVkLmZsYWdzO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2V0IGZsYWdzKHZhbCkge1xcbiAgICAgICAgICB0aGlzLnNoYXJlZC5mbGFncyA9IHZhbDtcXG4gICAgICAgIH1cXG4gICAgICAgIGdldCBwb3NpdGlvbigpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2hhcmVkLnBvc2l0aW9uO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2V0IHBvc2l0aW9uKHZhbCkge1xcbiAgICAgICAgICB0aGlzLnNoYXJlZC5wb3NpdGlvbiA9IHZhbDtcXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgIEZTTm9kZTogY2xhc3Mge1xcbiAgICAgICAgbm9kZV9vcHMgPSB7fTtcXG4gICAgICAgIHN0cmVhbV9vcHMgPSB7fTtcXG4gICAgICAgIHJlYWRNb2RlID0gMjkyIHwgNzM7XFxuICAgICAgICB3cml0ZU1vZGUgPSAxNDY7XFxuICAgICAgICBtb3VudGVkID0gbnVsbDtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbmFtZSwgbW9kZSwgcmRldikge1xcbiAgICAgICAgICBpZiAoIXBhcmVudCkge1xcbiAgICAgICAgICAgIHBhcmVudCA9IHRoaXM7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XFxuICAgICAgICAgIHRoaXMubW91bnQgPSBwYXJlbnQubW91bnQ7XFxuICAgICAgICAgIHRoaXMuaWQgPSBGUy5uZXh0SW5vZGUrKztcXG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcXG4gICAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcXG4gICAgICAgICAgdGhpcy5yZGV2ID0gcmRldjtcXG4gICAgICAgICAgdGhpcy5hdGltZSA9IHRoaXMubXRpbWUgPSB0aGlzLmN0aW1lID0gRGF0ZS5ub3coKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGdldCByZWFkKCkge1xcbiAgICAgICAgICByZXR1cm4gKHRoaXMubW9kZSAmIHRoaXMucmVhZE1vZGUpID09PSB0aGlzLnJlYWRNb2RlO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2V0IHJlYWQodmFsKSB7XFxuICAgICAgICAgIHZhbCA/ICh0aGlzLm1vZGUgfD0gdGhpcy5yZWFkTW9kZSkgOiAodGhpcy5tb2RlICY9IH50aGlzLnJlYWRNb2RlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGdldCB3cml0ZSgpIHtcXG4gICAgICAgICAgcmV0dXJuICh0aGlzLm1vZGUgJiB0aGlzLndyaXRlTW9kZSkgPT09IHRoaXMud3JpdGVNb2RlO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2V0IHdyaXRlKHZhbCkge1xcbiAgICAgICAgICB2YWwgPyAodGhpcy5tb2RlIHw9IHRoaXMud3JpdGVNb2RlKSA6ICh0aGlzLm1vZGUgJj0gfnRoaXMud3JpdGVNb2RlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGdldCBpc0ZvbGRlcigpIHtcXG4gICAgICAgICAgcmV0dXJuIEZTLmlzRGlyKHRoaXMubW9kZSk7XFxuICAgICAgICB9XFxuICAgICAgICBnZXQgaXNEZXZpY2UoKSB7XFxuICAgICAgICAgIHJldHVybiBGUy5pc0NocmRldih0aGlzLm1vZGUpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgbG9va3VwUGF0aChwYXRoLCBvcHRzID0ge30pIHtcXG4gICAgICAgIGlmICghcGF0aCkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XFxuICAgICAgICB9XFxuICAgICAgICBvcHRzLmZvbGxvd19tb3VudCA/Pz0gdHJ1ZTtcXG4gICAgICAgIGlmICghUEFUSC5pc0FicyhwYXRoKSkge1xcbiAgICAgICAgICBwYXRoID0gRlMuY3dkKCkgKyBcIi9cIiArIHBhdGg7XFxuICAgICAgICB9XFxuICAgICAgICBsaW5rbG9vcDogZm9yICh2YXIgbmxpbmtzID0gMDsgbmxpbmtzIDwgNDA7IG5saW5rcysrKSB7XFxuICAgICAgICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoXCIvXCIpLmZpbHRlcigocCkgPT4gISFwKTtcXG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBGUy5yb290O1xcbiAgICAgICAgICB2YXIgY3VycmVudF9wYXRoID0gXCIvXCI7XFxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICB2YXIgaXNsYXN0ID0gaSA9PT0gcGFydHMubGVuZ3RoIC0gMTtcXG4gICAgICAgICAgICBpZiAoaXNsYXN0ICYmIG9wdHMucGFyZW50KSB7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKHBhcnRzW2ldID09PSBcIi5cIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChwYXJ0c1tpXSA9PT0gXCIuLlwiKSB7XFxuICAgICAgICAgICAgICBjdXJyZW50X3BhdGggPSBQQVRILmRpcm5hbWUoY3VycmVudF9wYXRoKTtcXG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjdXJyZW50X3BhdGggPSBQQVRILmpvaW4yKGN1cnJlbnRfcGF0aCwgcGFydHNbaV0pO1xcbiAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICBjdXJyZW50ID0gRlMubG9va3VwTm9kZShjdXJyZW50LCBwYXJ0c1tpXSk7XFxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgICAgaWYgKGU/LmVycm5vID09PSA0NCAmJiBpc2xhc3QgJiYgb3B0cy5ub2VudF9va2F5KSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB7IHBhdGg6IGN1cnJlbnRfcGF0aCB9O1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgdGhyb3cgZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChjdXJyZW50KSAmJiAoIWlzbGFzdCB8fCBvcHRzLmZvbGxvd19tb3VudCkpIHtcXG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm1vdW50ZWQucm9vdDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKEZTLmlzTGluayhjdXJyZW50Lm1vZGUpICYmICghaXNsYXN0IHx8IG9wdHMuZm9sbG93KSkge1xcbiAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Lm5vZGVfb3BzLnJlYWRsaW5rKSB7XFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDUyKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIHZhciBsaW5rID0gY3VycmVudC5ub2RlX29wcy5yZWFkbGluayhjdXJyZW50KTtcXG4gICAgICAgICAgICAgIGlmICghUEFUSC5pc0FicyhsaW5rKSkge1xcbiAgICAgICAgICAgICAgICBsaW5rID0gUEFUSC5kaXJuYW1lKGN1cnJlbnRfcGF0aCkgKyBcIi9cIiArIGxpbms7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBwYXRoID0gbGluayArIFwiL1wiICsgcGFydHMuc2xpY2UoaSArIDEpLmpvaW4oXCIvXCIpO1xcbiAgICAgICAgICAgICAgY29udGludWUgbGlua2xvb3A7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJldHVybiB7IHBhdGg6IGN1cnJlbnRfcGF0aCwgbm9kZTogY3VycmVudCB9O1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzIpO1xcbiAgICAgIH0sXFxuICAgICAgZ2V0UGF0aChub2RlKSB7XFxuICAgICAgICB2YXIgcGF0aDtcXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XFxuICAgICAgICAgIGlmIChGUy5pc1Jvb3Qobm9kZSkpIHtcXG4gICAgICAgICAgICB2YXIgbW91bnQgPSBub2RlLm1vdW50Lm1vdW50cG9pbnQ7XFxuICAgICAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gbW91bnQ7XFxuICAgICAgICAgICAgcmV0dXJuIG1vdW50W21vdW50Lmxlbmd0aCAtIDFdICE9PSBcIi9cIlxcbiAgICAgICAgICAgICAgPyBgJHttb3VudH0vJHtwYXRofWBcXG4gICAgICAgICAgICAgIDogbW91bnQgKyBwYXRoO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHBhdGggPSBwYXRoID8gYCR7bm9kZS5uYW1lfS8ke3BhdGh9YCA6IG5vZGUubmFtZTtcXG4gICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgaGFzaE5hbWUocGFyZW50aWQsIG5hbWUpIHtcXG4gICAgICAgIHZhciBoYXNoID0gMDtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCArIG5hbWUuY2hhckNvZGVBdChpKSkgfCAwO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuICgocGFyZW50aWQgKyBoYXNoKSA+Pj4gMCkgJSBGUy5uYW1lVGFibGUubGVuZ3RoO1xcbiAgICAgIH0sXFxuICAgICAgaGFzaEFkZE5vZGUobm9kZSkge1xcbiAgICAgICAgdmFyIGhhc2ggPSBGUy5oYXNoTmFtZShub2RlLnBhcmVudC5pZCwgbm9kZS5uYW1lKTtcXG4gICAgICAgIG5vZGUubmFtZV9uZXh0ID0gRlMubmFtZVRhYmxlW2hhc2hdO1xcbiAgICAgICAgRlMubmFtZVRhYmxlW2hhc2hdID0gbm9kZTtcXG4gICAgICB9LFxcbiAgICAgIGhhc2hSZW1vdmVOb2RlKG5vZGUpIHtcXG4gICAgICAgIHZhciBoYXNoID0gRlMuaGFzaE5hbWUobm9kZS5wYXJlbnQuaWQsIG5vZGUubmFtZSk7XFxuICAgICAgICBpZiAoRlMubmFtZVRhYmxlW2hhc2hdID09PSBub2RlKSB7XFxuICAgICAgICAgIEZTLm5hbWVUYWJsZVtoYXNoXSA9IG5vZGUubmFtZV9uZXh0O1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBGUy5uYW1lVGFibGVbaGFzaF07XFxuICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XFxuICAgICAgICAgICAgaWYgKGN1cnJlbnQubmFtZV9uZXh0ID09PSBub2RlKSB7XFxuICAgICAgICAgICAgICBjdXJyZW50Lm5hbWVfbmV4dCA9IG5vZGUubmFtZV9uZXh0O1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5hbWVfbmV4dDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgbG9va3VwTm9kZShwYXJlbnQsIG5hbWUpIHtcXG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5TG9va3VwKHBhcmVudCk7XFxuICAgICAgICBpZiAoZXJyQ29kZSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBoYXNoID0gRlMuaGFzaE5hbWUocGFyZW50LmlkLCBuYW1lKTtcXG4gICAgICAgIGZvciAodmFyIG5vZGUgPSBGUy5uYW1lVGFibGVbaGFzaF07IG5vZGU7IG5vZGUgPSBub2RlLm5hbWVfbmV4dCkge1xcbiAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBub2RlLm5hbWU7XFxuICAgICAgICAgIGlmIChub2RlLnBhcmVudC5pZCA9PT0gcGFyZW50LmlkICYmIG5vZGVOYW1lID09PSBuYW1lKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBGUy5sb29rdXAocGFyZW50LCBuYW1lKTtcXG4gICAgICB9LFxcbiAgICAgIGNyZWF0ZU5vZGUocGFyZW50LCBuYW1lLCBtb2RlLCByZGV2KSB7XFxuICAgICAgICBhc3NlcnQodHlwZW9mIHBhcmVudCA9PSBcIm9iamVjdFwiKTtcXG4gICAgICAgIHZhciBub2RlID0gbmV3IEZTLkZTTm9kZShwYXJlbnQsIG5hbWUsIG1vZGUsIHJkZXYpO1xcbiAgICAgICAgRlMuaGFzaEFkZE5vZGUobm9kZSk7XFxuICAgICAgICByZXR1cm4gbm9kZTtcXG4gICAgICB9LFxcbiAgICAgIGRlc3Ryb3lOb2RlKG5vZGUpIHtcXG4gICAgICAgIEZTLmhhc2hSZW1vdmVOb2RlKG5vZGUpO1xcbiAgICAgIH0sXFxuICAgICAgaXNSb290KG5vZGUpIHtcXG4gICAgICAgIHJldHVybiBub2RlID09PSBub2RlLnBhcmVudDtcXG4gICAgICB9LFxcbiAgICAgIGlzTW91bnRwb2ludChub2RlKSB7XFxuICAgICAgICByZXR1cm4gISFub2RlLm1vdW50ZWQ7XFxuICAgICAgfSxcXG4gICAgICBpc0ZpbGUobW9kZSkge1xcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSAzMjc2ODtcXG4gICAgICB9LFxcbiAgICAgIGlzRGlyKG1vZGUpIHtcXG4gICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gMTYzODQ7XFxuICAgICAgfSxcXG4gICAgICBpc0xpbmsobW9kZSkge1xcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSA0MDk2MDtcXG4gICAgICB9LFxcbiAgICAgIGlzQ2hyZGV2KG1vZGUpIHtcXG4gICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gODE5MjtcXG4gICAgICB9LFxcbiAgICAgIGlzQmxrZGV2KG1vZGUpIHtcXG4gICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gMjQ1NzY7XFxuICAgICAgfSxcXG4gICAgICBpc0ZJRk8obW9kZSkge1xcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSA0MDk2O1xcbiAgICAgIH0sXFxuICAgICAgaXNTb2NrZXQobW9kZSkge1xcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNDkxNTIpID09PSA0OTE1MjtcXG4gICAgICB9LFxcbiAgICAgIGZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nKGZsYWcpIHtcXG4gICAgICAgIHZhciBwZXJtcyA9IFtcInJcIiwgXCJ3XCIsIFwicndcIl1bZmxhZyAmIDNdO1xcbiAgICAgICAgaWYgKGZsYWcgJiA1MTIpIHtcXG4gICAgICAgICAgcGVybXMgKz0gXCJ3XCI7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcGVybXM7XFxuICAgICAgfSxcXG4gICAgICBub2RlUGVybWlzc2lvbnMobm9kZSwgcGVybXMpIHtcXG4gICAgICAgIGlmIChGUy5pZ25vcmVQZXJtaXNzaW9ucykge1xcbiAgICAgICAgICByZXR1cm4gMDtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChwZXJtcy5pbmNsdWRlcyhcInJcIikgJiYgIShub2RlLm1vZGUgJiAyOTIpKSB7XFxuICAgICAgICAgIHJldHVybiAyO1xcbiAgICAgICAgfSBlbHNlIGlmIChwZXJtcy5pbmNsdWRlcyhcIndcIikgJiYgIShub2RlLm1vZGUgJiAxNDYpKSB7XFxuICAgICAgICAgIHJldHVybiAyO1xcbiAgICAgICAgfSBlbHNlIGlmIChwZXJtcy5pbmNsdWRlcyhcInhcIikgJiYgIShub2RlLm1vZGUgJiA3MykpIHtcXG4gICAgICAgICAgcmV0dXJuIDI7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gMDtcXG4gICAgICB9LFxcbiAgICAgIG1heUxvb2t1cChkaXIpIHtcXG4gICAgICAgIGlmICghRlMuaXNEaXIoZGlyLm1vZGUpKSByZXR1cm4gNTQ7XFxuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm5vZGVQZXJtaXNzaW9ucyhkaXIsIFwieFwiKTtcXG4gICAgICAgIGlmIChlcnJDb2RlKSByZXR1cm4gZXJyQ29kZTtcXG4gICAgICAgIGlmICghZGlyLm5vZGVfb3BzLmxvb2t1cCkgcmV0dXJuIDI7XFxuICAgICAgICByZXR1cm4gMDtcXG4gICAgICB9LFxcbiAgICAgIG1heUNyZWF0ZShkaXIsIG5hbWUpIHtcXG4gICAgICAgIGlmICghRlMuaXNEaXIoZGlyLm1vZGUpKSB7XFxuICAgICAgICAgIHJldHVybiA1NDtcXG4gICAgICAgIH1cXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIHZhciBub2RlID0gRlMubG9va3VwTm9kZShkaXIsIG5hbWUpO1xcbiAgICAgICAgICByZXR1cm4gMjA7XFxuICAgICAgICB9IGNhdGNoIChlKSB7fVxcbiAgICAgICAgcmV0dXJuIEZTLm5vZGVQZXJtaXNzaW9ucyhkaXIsIFwid3hcIik7XFxuICAgICAgfSxcXG4gICAgICBtYXlEZWxldGUoZGlyLCBuYW1lLCBpc2Rpcikge1xcbiAgICAgICAgdmFyIG5vZGU7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICBub2RlID0gRlMubG9va3VwTm9kZShkaXIsIG5hbWUpO1xcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICByZXR1cm4gZS5lcnJubztcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKGRpciwgXCJ3eFwiKTtcXG4gICAgICAgIGlmIChlcnJDb2RlKSB7XFxuICAgICAgICAgIHJldHVybiBlcnJDb2RlO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGlzZGlyKSB7XFxuICAgICAgICAgIGlmICghRlMuaXNEaXIobm9kZS5tb2RlKSkge1xcbiAgICAgICAgICAgIHJldHVybiA1NDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoRlMuaXNSb290KG5vZGUpIHx8IEZTLmdldFBhdGgobm9kZSkgPT09IEZTLmN3ZCgpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIDEwO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBpZiAoRlMuaXNEaXIobm9kZS5tb2RlKSkge1xcbiAgICAgICAgICAgIHJldHVybiAzMTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIDA7XFxuICAgICAgfSxcXG4gICAgICBtYXlPcGVuKG5vZGUsIGZsYWdzKSB7XFxuICAgICAgICBpZiAoIW5vZGUpIHtcXG4gICAgICAgICAgcmV0dXJuIDQ0O1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKEZTLmlzTGluayhub2RlLm1vZGUpKSB7XFxuICAgICAgICAgIHJldHVybiAzMjtcXG4gICAgICAgIH0gZWxzZSBpZiAoRlMuaXNEaXIobm9kZS5tb2RlKSkge1xcbiAgICAgICAgICBpZiAoRlMuZmxhZ3NUb1Blcm1pc3Npb25TdHJpbmcoZmxhZ3MpICE9PSBcInJcIiB8fCBmbGFncyAmICg1MTIgfCA2NCkpIHtcXG4gICAgICAgICAgICByZXR1cm4gMzE7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBGUy5ub2RlUGVybWlzc2lvbnMobm9kZSwgRlMuZmxhZ3NUb1Blcm1pc3Npb25TdHJpbmcoZmxhZ3MpKTtcXG4gICAgICB9LFxcbiAgICAgIGNoZWNrT3BFeGlzdHMob3AsIGVycikge1xcbiAgICAgICAgaWYgKCFvcCkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIG9wO1xcbiAgICAgIH0sXFxuICAgICAgTUFYX09QRU5fRkRTOiA0MDk2LFxcbiAgICAgIG5leHRmZCgpIHtcXG4gICAgICAgIGZvciAodmFyIGZkID0gMDsgZmQgPD0gRlMuTUFYX09QRU5fRkRTOyBmZCsrKSB7XFxuICAgICAgICAgIGlmICghRlMuc3RyZWFtc1tmZF0pIHtcXG4gICAgICAgICAgICByZXR1cm4gZmQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDMzKTtcXG4gICAgICB9LFxcbiAgICAgIGdldFN0cmVhbUNoZWNrZWQoZmQpIHtcXG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpO1xcbiAgICAgICAgaWYgKCFzdHJlYW0pIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gc3RyZWFtO1xcbiAgICAgIH0sXFxuICAgICAgZ2V0U3RyZWFtOiAoZmQpID0+IEZTLnN0cmVhbXNbZmRdLFxcbiAgICAgIGNyZWF0ZVN0cmVhbShzdHJlYW0sIGZkID0gLTEpIHtcXG4gICAgICAgIGFzc2VydChmZCA+PSAtMSk7XFxuICAgICAgICBzdHJlYW0gPSBPYmplY3QuYXNzaWduKG5ldyBGUy5GU1N0cmVhbSgpLCBzdHJlYW0pO1xcbiAgICAgICAgaWYgKGZkID09IC0xKSB7XFxuICAgICAgICAgIGZkID0gRlMubmV4dGZkKCk7XFxuICAgICAgICB9XFxuICAgICAgICBzdHJlYW0uZmQgPSBmZDtcXG4gICAgICAgIEZTLnN0cmVhbXNbZmRdID0gc3RyZWFtO1xcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcXG4gICAgICB9LFxcbiAgICAgIGNsb3NlU3RyZWFtKGZkKSB7XFxuICAgICAgICBGUy5zdHJlYW1zW2ZkXSA9IG51bGw7XFxuICAgICAgfSxcXG4gICAgICBkdXBTdHJlYW0ob3JpZ1N0cmVhbSwgZmQgPSAtMSkge1xcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmNyZWF0ZVN0cmVhbShvcmlnU3RyZWFtLCBmZCk7XFxuICAgICAgICBzdHJlYW0uc3RyZWFtX29wcz8uZHVwPy4oc3RyZWFtKTtcXG4gICAgICAgIHJldHVybiBzdHJlYW07XFxuICAgICAgfSxcXG4gICAgICBkb1NldEF0dHIoc3RyZWFtLCBub2RlLCBhdHRyKSB7XFxuICAgICAgICB2YXIgc2V0YXR0ciA9IHN0cmVhbT8uc3RyZWFtX29wcy5zZXRhdHRyO1xcbiAgICAgICAgdmFyIGFyZyA9IHNldGF0dHIgPyBzdHJlYW0gOiBub2RlO1xcbiAgICAgICAgc2V0YXR0ciA/Pz0gbm9kZS5ub2RlX29wcy5zZXRhdHRyO1xcbiAgICAgICAgRlMuY2hlY2tPcEV4aXN0cyhzZXRhdHRyLCA2Myk7XFxuICAgICAgICBzZXRhdHRyKGFyZywgYXR0cik7XFxuICAgICAgfSxcXG4gICAgICBjaHJkZXZfc3RyZWFtX29wczoge1xcbiAgICAgICAgb3BlbihzdHJlYW0pIHtcXG4gICAgICAgICAgdmFyIGRldmljZSA9IEZTLmdldERldmljZShzdHJlYW0ubm9kZS5yZGV2KTtcXG4gICAgICAgICAgc3RyZWFtLnN0cmVhbV9vcHMgPSBkZXZpY2Uuc3RyZWFtX29wcztcXG4gICAgICAgICAgc3RyZWFtLnN0cmVhbV9vcHMub3Blbj8uKHN0cmVhbSk7XFxuICAgICAgICB9LFxcbiAgICAgICAgbGxzZWVrKCkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCk7XFxuICAgICAgICB9LFxcbiAgICAgIH0sXFxuICAgICAgbWFqb3I6IChkZXYpID0+IGRldiA+PiA4LFxcbiAgICAgIG1pbm9yOiAoZGV2KSA9PiBkZXYgJiAyNTUsXFxuICAgICAgbWFrZWRldjogKG1hLCBtaSkgPT4gKG1hIDw8IDgpIHwgbWksXFxuICAgICAgcmVnaXN0ZXJEZXZpY2UoZGV2LCBvcHMpIHtcXG4gICAgICAgIEZTLmRldmljZXNbZGV2XSA9IHsgc3RyZWFtX29wczogb3BzIH07XFxuICAgICAgfSxcXG4gICAgICBnZXREZXZpY2U6IChkZXYpID0+IEZTLmRldmljZXNbZGV2XSxcXG4gICAgICBnZXRNb3VudHMobW91bnQpIHtcXG4gICAgICAgIHZhciBtb3VudHMgPSBbXTtcXG4gICAgICAgIHZhciBjaGVjayA9IFttb3VudF07XFxuICAgICAgICB3aGlsZSAoY2hlY2subGVuZ3RoKSB7XFxuICAgICAgICAgIHZhciBtID0gY2hlY2sucG9wKCk7XFxuICAgICAgICAgIG1vdW50cy5wdXNoKG0pO1xcbiAgICAgICAgICBjaGVjay5wdXNoKC4uLm0ubW91bnRzKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBtb3VudHM7XFxuICAgICAgfSxcXG4gICAgICBzeW5jZnMocG9wdWxhdGUsIGNhbGxiYWNrKSB7XFxuICAgICAgICBpZiAodHlwZW9mIHBvcHVsYXRlID09IFwiZnVuY3Rpb25cIikge1xcbiAgICAgICAgICBjYWxsYmFjayA9IHBvcHVsYXRlO1xcbiAgICAgICAgICBwb3B1bGF0ZSA9IGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgRlMuc3luY0ZTUmVxdWVzdHMrKztcXG4gICAgICAgIGlmIChGUy5zeW5jRlNSZXF1ZXN0cyA+IDEpIHtcXG4gICAgICAgICAgZXJyKFxcbiAgICAgICAgICAgIGB3YXJuaW5nOiAke0ZTLnN5bmNGU1JlcXVlc3RzfSBGUy5zeW5jZnMgb3BlcmF0aW9ucyBpbiBmbGlnaHQgYXQgb25jZSwgcHJvYmFibHkganVzdCBkb2luZyBleHRyYSB3b3JrYCxcXG4gICAgICAgICAgKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBtb3VudHMgPSBGUy5nZXRNb3VudHMoRlMucm9vdC5tb3VudCk7XFxuICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcXG4gICAgICAgIGZ1bmN0aW9uIGRvQ2FsbGJhY2soZXJyQ29kZSkge1xcbiAgICAgICAgICBhc3NlcnQoRlMuc3luY0ZTUmVxdWVzdHMgPiAwKTtcXG4gICAgICAgICAgRlMuc3luY0ZTUmVxdWVzdHMtLTtcXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyckNvZGUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZnVuY3Rpb24gZG9uZShlcnJDb2RlKSB7XFxuICAgICAgICAgIGlmIChlcnJDb2RlKSB7XFxuICAgICAgICAgICAgaWYgKCFkb25lLmVycm9yZWQpIHtcXG4gICAgICAgICAgICAgIGRvbmUuZXJyb3JlZCA9IHRydWU7XFxuICAgICAgICAgICAgICByZXR1cm4gZG9DYWxsYmFjayhlcnJDb2RlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmICgrK2NvbXBsZXRlZCA+PSBtb3VudHMubGVuZ3RoKSB7XFxuICAgICAgICAgICAgZG9DYWxsYmFjayhudWxsKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgbW91bnRzLmZvckVhY2goKG1vdW50KSA9PiB7XFxuICAgICAgICAgIGlmICghbW91bnQudHlwZS5zeW5jZnMpIHtcXG4gICAgICAgICAgICByZXR1cm4gZG9uZShudWxsKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBtb3VudC50eXBlLnN5bmNmcyhtb3VudCwgcG9wdWxhdGUsIGRvbmUpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSxcXG4gICAgICBtb3VudCh0eXBlLCBvcHRzLCBtb3VudHBvaW50KSB7XFxuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT0gXCJzdHJpbmdcIikge1xcbiAgICAgICAgICB0aHJvdyB0eXBlO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIHJvb3QgPSBtb3VudHBvaW50ID09PSBcIi9cIjtcXG4gICAgICAgIHZhciBwc2V1ZG8gPSAhbW91bnRwb2ludDtcXG4gICAgICAgIHZhciBub2RlO1xcbiAgICAgICAgaWYgKHJvb3QgJiYgRlMucm9vdCkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMCk7XFxuICAgICAgICB9IGVsc2UgaWYgKCFyb290ICYmICFwc2V1ZG8pIHtcXG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgobW91bnRwb2ludCwgeyBmb2xsb3dfbW91bnQ6IGZhbHNlIH0pO1xcbiAgICAgICAgICBtb3VudHBvaW50ID0gbG9va3VwLnBhdGg7XFxuICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTtcXG4gICAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChub2RlKSkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoIUZTLmlzRGlyKG5vZGUubW9kZSkpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBtb3VudCA9IHsgdHlwZSwgb3B0cywgbW91bnRwb2ludCwgbW91bnRzOiBbXSB9O1xcbiAgICAgICAgdmFyIG1vdW50Um9vdCA9IHR5cGUubW91bnQobW91bnQpO1xcbiAgICAgICAgbW91bnRSb290Lm1vdW50ID0gbW91bnQ7XFxuICAgICAgICBtb3VudC5yb290ID0gbW91bnRSb290O1xcbiAgICAgICAgaWYgKHJvb3QpIHtcXG4gICAgICAgICAgRlMucm9vdCA9IG1vdW50Um9vdDtcXG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSkge1xcbiAgICAgICAgICBub2RlLm1vdW50ZWQgPSBtb3VudDtcXG4gICAgICAgICAgaWYgKG5vZGUubW91bnQpIHtcXG4gICAgICAgICAgICBub2RlLm1vdW50Lm1vdW50cy5wdXNoKG1vdW50KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIG1vdW50Um9vdDtcXG4gICAgICB9LFxcbiAgICAgIHVubW91bnQobW91bnRwb2ludCkge1xcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgobW91bnRwb2ludCwgeyBmb2xsb3dfbW91bnQ6IGZhbHNlIH0pO1xcbiAgICAgICAgaWYgKCFGUy5pc01vdW50cG9pbnQobG9va3VwLm5vZGUpKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7XFxuICAgICAgICB2YXIgbW91bnQgPSBub2RlLm1vdW50ZWQ7XFxuICAgICAgICB2YXIgbW91bnRzID0gRlMuZ2V0TW91bnRzKG1vdW50KTtcXG4gICAgICAgIE9iamVjdC5rZXlzKEZTLm5hbWVUYWJsZSkuZm9yRWFjaCgoaGFzaCkgPT4ge1xcbiAgICAgICAgICB2YXIgY3VycmVudCA9IEZTLm5hbWVUYWJsZVtoYXNoXTtcXG4gICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcXG4gICAgICAgICAgICB2YXIgbmV4dCA9IGN1cnJlbnQubmFtZV9uZXh0O1xcbiAgICAgICAgICAgIGlmIChtb3VudHMuaW5jbHVkZXMoY3VycmVudC5tb3VudCkpIHtcXG4gICAgICAgICAgICAgIEZTLmRlc3Ryb3lOb2RlKGN1cnJlbnQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgICBub2RlLm1vdW50ZWQgPSBudWxsO1xcbiAgICAgICAgdmFyIGlkeCA9IG5vZGUubW91bnQubW91bnRzLmluZGV4T2YobW91bnQpO1xcbiAgICAgICAgYXNzZXJ0KGlkeCAhPT0gLTEpO1xcbiAgICAgICAgbm9kZS5tb3VudC5tb3VudHMuc3BsaWNlKGlkeCwgMSk7XFxuICAgICAgfSxcXG4gICAgICBsb29rdXAocGFyZW50LCBuYW1lKSB7XFxuICAgICAgICByZXR1cm4gcGFyZW50Lm5vZGVfb3BzLmxvb2t1cChwYXJlbnQsIG5hbWUpO1xcbiAgICAgIH0sXFxuICAgICAgbWtub2QocGF0aCwgbW9kZSwgZGV2KSB7XFxuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcXG4gICAgICAgIHZhciBwYXJlbnQgPSBsb29rdXAubm9kZTtcXG4gICAgICAgIHZhciBuYW1lID0gUEFUSC5iYXNlbmFtZShwYXRoKTtcXG4gICAgICAgIGlmICghbmFtZSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAobmFtZSA9PT0gXCIuXCIgfHwgbmFtZSA9PT0gXCIuLlwiKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDIwKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5Q3JlYXRlKHBhcmVudCwgbmFtZSk7XFxuICAgICAgICBpZiAoZXJyQ29kZSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghcGFyZW50Lm5vZGVfb3BzLm1rbm9kKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBwYXJlbnQubm9kZV9vcHMubWtub2QocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpO1xcbiAgICAgIH0sXFxuICAgICAgc3RhdGZzKHBhdGgpIHtcXG4gICAgICAgIHJldHVybiBGUy5zdGF0ZnNOb2RlKEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6IHRydWUgfSkubm9kZSk7XFxuICAgICAgfSxcXG4gICAgICBzdGF0ZnNTdHJlYW0oc3RyZWFtKSB7XFxuICAgICAgICByZXR1cm4gRlMuc3RhdGZzTm9kZShzdHJlYW0ubm9kZSk7XFxuICAgICAgfSxcXG4gICAgICBzdGF0ZnNOb2RlKG5vZGUpIHtcXG4gICAgICAgIHZhciBydG4gPSB7XFxuICAgICAgICAgIGJzaXplOiA0MDk2LFxcbiAgICAgICAgICBmcnNpemU6IDQwOTYsXFxuICAgICAgICAgIGJsb2NrczogMWU2LFxcbiAgICAgICAgICBiZnJlZTogNWU1LFxcbiAgICAgICAgICBiYXZhaWw6IDVlNSxcXG4gICAgICAgICAgZmlsZXM6IEZTLm5leHRJbm9kZSxcXG4gICAgICAgICAgZmZyZWU6IEZTLm5leHRJbm9kZSAtIDEsXFxuICAgICAgICAgIGZzaWQ6IDQyLFxcbiAgICAgICAgICBmbGFnczogMixcXG4gICAgICAgICAgbmFtZWxlbjogMjU1LFxcbiAgICAgICAgfTtcXG4gICAgICAgIGlmIChub2RlLm5vZGVfb3BzLnN0YXRmcykge1xcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHJ0biwgbm9kZS5ub2RlX29wcy5zdGF0ZnMobm9kZS5tb3VudC5vcHRzLnJvb3QpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBydG47XFxuICAgICAgfSxcXG4gICAgICBjcmVhdGUocGF0aCwgbW9kZSA9IDQzOCkge1xcbiAgICAgICAgbW9kZSAmPSA0MDk1O1xcbiAgICAgICAgbW9kZSB8PSAzMjc2ODtcXG4gICAgICAgIHJldHVybiBGUy5ta25vZChwYXRoLCBtb2RlLCAwKTtcXG4gICAgICB9LFxcbiAgICAgIG1rZGlyKHBhdGgsIG1vZGUgPSA1MTEpIHtcXG4gICAgICAgIG1vZGUgJj0gNTExIHwgNTEyO1xcbiAgICAgICAgbW9kZSB8PSAxNjM4NDtcXG4gICAgICAgIHJldHVybiBGUy5ta25vZChwYXRoLCBtb2RlLCAwKTtcXG4gICAgICB9LFxcbiAgICAgIG1rZGlyVHJlZShwYXRoLCBtb2RlKSB7XFxuICAgICAgICB2YXIgZGlycyA9IHBhdGguc3BsaXQoXCIvXCIpO1xcbiAgICAgICAgdmFyIGQgPSBcIlwiO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgKytpKSB7XFxuICAgICAgICAgIGlmICghZGlyc1tpXSkgY29udGludWU7XFxuICAgICAgICAgIGQgKz0gXCIvXCIgKyBkaXJzW2ldO1xcbiAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIEZTLm1rZGlyKGQsIG1vZGUpO1xcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgaWYgKGUuZXJybm8gIT0gMjApIHRocm93IGU7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgIG1rZGV2KHBhdGgsIG1vZGUsIGRldikge1xcbiAgICAgICAgaWYgKHR5cGVvZiBkZXYgPT0gXCJ1bmRlZmluZWRcIikge1xcbiAgICAgICAgICBkZXYgPSBtb2RlO1xcbiAgICAgICAgICBtb2RlID0gNDM4O1xcbiAgICAgICAgfVxcbiAgICAgICAgbW9kZSB8PSA4MTkyO1xcbiAgICAgICAgcmV0dXJuIEZTLm1rbm9kKHBhdGgsIG1vZGUsIGRldik7XFxuICAgICAgfSxcXG4gICAgICBzeW1saW5rKG9sZHBhdGgsIG5ld3BhdGgpIHtcXG4gICAgICAgIGlmICghUEFUSF9GUy5yZXNvbHZlKG9sZHBhdGgpKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKG5ld3BhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xcbiAgICAgICAgdmFyIHBhcmVudCA9IGxvb2t1cC5ub2RlO1xcbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIG5ld25hbWUgPSBQQVRILmJhc2VuYW1lKG5ld3BhdGgpO1xcbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5tYXlDcmVhdGUocGFyZW50LCBuZXduYW1lKTtcXG4gICAgICAgIGlmIChlcnJDb2RlKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCFwYXJlbnQubm9kZV9vcHMuc3ltbGluaykge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcGFyZW50Lm5vZGVfb3BzLnN5bWxpbmsocGFyZW50LCBuZXduYW1lLCBvbGRwYXRoKTtcXG4gICAgICB9LFxcbiAgICAgIHJlbmFtZShvbGRfcGF0aCwgbmV3X3BhdGgpIHtcXG4gICAgICAgIHZhciBvbGRfZGlybmFtZSA9IFBBVEguZGlybmFtZShvbGRfcGF0aCk7XFxuICAgICAgICB2YXIgbmV3X2Rpcm5hbWUgPSBQQVRILmRpcm5hbWUobmV3X3BhdGgpO1xcbiAgICAgICAgdmFyIG9sZF9uYW1lID0gUEFUSC5iYXNlbmFtZShvbGRfcGF0aCk7XFxuICAgICAgICB2YXIgbmV3X25hbWUgPSBQQVRILmJhc2VuYW1lKG5ld19wYXRoKTtcXG4gICAgICAgIHZhciBsb29rdXAsIG9sZF9kaXIsIG5ld19kaXI7XFxuICAgICAgICBsb29rdXAgPSBGUy5sb29rdXBQYXRoKG9sZF9wYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcXG4gICAgICAgIG9sZF9kaXIgPSBsb29rdXAubm9kZTtcXG4gICAgICAgIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgobmV3X3BhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xcbiAgICAgICAgbmV3X2RpciA9IGxvb2t1cC5ub2RlO1xcbiAgICAgICAgaWYgKCFvbGRfZGlyIHx8ICFuZXdfZGlyKSB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XFxuICAgICAgICBpZiAob2xkX2Rpci5tb3VudCAhPT0gbmV3X2Rpci5tb3VudCkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3NSk7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgb2xkX25vZGUgPSBGUy5sb29rdXBOb2RlKG9sZF9kaXIsIG9sZF9uYW1lKTtcXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IFBBVEhfRlMucmVsYXRpdmUob2xkX3BhdGgsIG5ld19kaXJuYW1lKTtcXG4gICAgICAgIGlmIChyZWxhdGl2ZS5jaGFyQXQoMCkgIT09IFwiLlwiKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJlbGF0aXZlID0gUEFUSF9GUy5yZWxhdGl2ZShuZXdfcGF0aCwgb2xkX2Rpcm5hbWUpO1xcbiAgICAgICAgaWYgKHJlbGF0aXZlLmNoYXJBdCgwKSAhPT0gXCIuXCIpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIG5ld19ub2RlO1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgbmV3X25vZGUgPSBGUy5sb29rdXBOb2RlKG5ld19kaXIsIG5ld19uYW1lKTtcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XFxuICAgICAgICBpZiAob2xkX25vZGUgPT09IG5ld19ub2RlKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBpc2RpciA9IEZTLmlzRGlyKG9sZF9ub2RlLm1vZGUpO1xcbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5tYXlEZWxldGUob2xkX2Rpciwgb2xkX25hbWUsIGlzZGlyKTtcXG4gICAgICAgIGlmIChlcnJDb2RlKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZXJyQ29kZSA9IG5ld19ub2RlXFxuICAgICAgICAgID8gRlMubWF5RGVsZXRlKG5ld19kaXIsIG5ld19uYW1lLCBpc2RpcilcXG4gICAgICAgICAgOiBGUy5tYXlDcmVhdGUobmV3X2RpciwgbmV3X25hbWUpO1xcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIW9sZF9kaXIubm9kZV9vcHMucmVuYW1lKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChcXG4gICAgICAgICAgRlMuaXNNb3VudHBvaW50KG9sZF9ub2RlKSB8fFxcbiAgICAgICAgICAobmV3X25vZGUgJiYgRlMuaXNNb3VudHBvaW50KG5ld19ub2RlKSlcXG4gICAgICAgICkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAobmV3X2RpciAhPT0gb2xkX2Rpcikge1xcbiAgICAgICAgICBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKG9sZF9kaXIsIFwid1wiKTtcXG4gICAgICAgICAgaWYgKGVyckNvZGUpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgRlMuaGFzaFJlbW92ZU5vZGUob2xkX25vZGUpO1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgb2xkX2Rpci5ub2RlX29wcy5yZW5hbWUob2xkX25vZGUsIG5ld19kaXIsIG5ld19uYW1lKTtcXG4gICAgICAgICAgb2xkX25vZGUucGFyZW50ID0gbmV3X2RpcjtcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgdGhyb3cgZTtcXG4gICAgICAgIH0gZmluYWxseSB7XFxuICAgICAgICAgIEZTLmhhc2hBZGROb2RlKG9sZF9ub2RlKTtcXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgIHJtZGlyKHBhdGgpIHtcXG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xcbiAgICAgICAgdmFyIHBhcmVudCA9IGxvb2t1cC5ub2RlO1xcbiAgICAgICAgdmFyIG5hbWUgPSBQQVRILmJhc2VuYW1lKHBhdGgpO1xcbiAgICAgICAgdmFyIG5vZGUgPSBGUy5sb29rdXBOb2RlKHBhcmVudCwgbmFtZSk7XFxuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heURlbGV0ZShwYXJlbnQsIG5hbWUsIHRydWUpO1xcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIXBhcmVudC5ub2RlX29wcy5ybWRpcikge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoRlMuaXNNb3VudHBvaW50KG5vZGUpKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHBhcmVudC5ub2RlX29wcy5ybWRpcihwYXJlbnQsIG5hbWUpO1xcbiAgICAgICAgRlMuZGVzdHJveU5vZGUobm9kZSk7XFxuICAgICAgfSxcXG4gICAgICByZWFkZGlyKHBhdGgpIHtcXG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pO1xcbiAgICAgICAgdmFyIG5vZGUgPSBsb29rdXAubm9kZTtcXG4gICAgICAgIHZhciByZWFkZGlyID0gRlMuY2hlY2tPcEV4aXN0cyhub2RlLm5vZGVfb3BzLnJlYWRkaXIsIDU0KTtcXG4gICAgICAgIHJldHVybiByZWFkZGlyKG5vZGUpO1xcbiAgICAgIH0sXFxuICAgICAgdW5saW5rKHBhdGgpIHtcXG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xcbiAgICAgICAgdmFyIHBhcmVudCA9IGxvb2t1cC5ub2RlO1xcbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIG5hbWUgPSBQQVRILmJhc2VuYW1lKHBhdGgpO1xcbiAgICAgICAgdmFyIG5vZGUgPSBGUy5sb29rdXBOb2RlKHBhcmVudCwgbmFtZSk7XFxuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heURlbGV0ZShwYXJlbnQsIG5hbWUsIGZhbHNlKTtcXG4gICAgICAgIGlmIChlcnJDb2RlKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCFwYXJlbnQubm9kZV9vcHMudW5saW5rKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChGUy5pc01vdW50cG9pbnQobm9kZSkpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTApO1xcbiAgICAgICAgfVxcbiAgICAgICAgcGFyZW50Lm5vZGVfb3BzLnVubGluayhwYXJlbnQsIG5hbWUpO1xcbiAgICAgICAgRlMuZGVzdHJveU5vZGUobm9kZSk7XFxuICAgICAgfSxcXG4gICAgICByZWFkbGluayhwYXRoKSB7XFxuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoKTtcXG4gICAgICAgIHZhciBsaW5rID0gbG9va3VwLm5vZGU7XFxuICAgICAgICBpZiAoIWxpbmspIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCFsaW5rLm5vZGVfb3BzLnJlYWRsaW5rKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBsaW5rLm5vZGVfb3BzLnJlYWRsaW5rKGxpbmspO1xcbiAgICAgIH0sXFxuICAgICAgc3RhdChwYXRoLCBkb250Rm9sbG93KSB7XFxuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRGb2xsb3cgfSk7XFxuICAgICAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlO1xcbiAgICAgICAgdmFyIGdldGF0dHIgPSBGUy5jaGVja09wRXhpc3RzKG5vZGUubm9kZV9vcHMuZ2V0YXR0ciwgNjMpO1xcbiAgICAgICAgcmV0dXJuIGdldGF0dHIobm9kZSk7XFxuICAgICAgfSxcXG4gICAgICBmc3RhdChmZCkge1xcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmdldFN0cmVhbUNoZWNrZWQoZmQpO1xcbiAgICAgICAgdmFyIG5vZGUgPSBzdHJlYW0ubm9kZTtcXG4gICAgICAgIHZhciBnZXRhdHRyID0gc3RyZWFtLnN0cmVhbV9vcHMuZ2V0YXR0cjtcXG4gICAgICAgIHZhciBhcmcgPSBnZXRhdHRyID8gc3RyZWFtIDogbm9kZTtcXG4gICAgICAgIGdldGF0dHIgPz89IG5vZGUubm9kZV9vcHMuZ2V0YXR0cjtcXG4gICAgICAgIEZTLmNoZWNrT3BFeGlzdHMoZ2V0YXR0ciwgNjMpO1xcbiAgICAgICAgcmV0dXJuIGdldGF0dHIoYXJnKTtcXG4gICAgICB9LFxcbiAgICAgIGxzdGF0KHBhdGgpIHtcXG4gICAgICAgIHJldHVybiBGUy5zdGF0KHBhdGgsIHRydWUpO1xcbiAgICAgIH0sXFxuICAgICAgZG9DaG1vZChzdHJlYW0sIG5vZGUsIG1vZGUsIGRvbnRGb2xsb3cpIHtcXG4gICAgICAgIEZTLmRvU2V0QXR0cihzdHJlYW0sIG5vZGUsIHtcXG4gICAgICAgICAgbW9kZTogKG1vZGUgJiA0MDk1KSB8IChub2RlLm1vZGUgJiB+NDA5NSksXFxuICAgICAgICAgIGN0aW1lOiBEYXRlLm5vdygpLFxcbiAgICAgICAgICBkb250Rm9sbG93LFxcbiAgICAgICAgfSk7XFxuICAgICAgfSxcXG4gICAgICBjaG1vZChwYXRoLCBtb2RlLCBkb250Rm9sbG93KSB7XFxuICAgICAgICB2YXIgbm9kZTtcXG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PSBcInN0cmluZ1wiKSB7XFxuICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhZG9udEZvbGxvdyB9KTtcXG4gICAgICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgbm9kZSA9IHBhdGg7XFxuICAgICAgICB9XFxuICAgICAgICBGUy5kb0NobW9kKG51bGwsIG5vZGUsIG1vZGUsIGRvbnRGb2xsb3cpO1xcbiAgICAgIH0sXFxuICAgICAgbGNobW9kKHBhdGgsIG1vZGUpIHtcXG4gICAgICAgIEZTLmNobW9kKHBhdGgsIG1vZGUsIHRydWUpO1xcbiAgICAgIH0sXFxuICAgICAgZmNobW9kKGZkLCBtb2RlKSB7XFxuICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtQ2hlY2tlZChmZCk7XFxuICAgICAgICBGUy5kb0NobW9kKHN0cmVhbSwgc3RyZWFtLm5vZGUsIG1vZGUsIGZhbHNlKTtcXG4gICAgICB9LFxcbiAgICAgIGRvQ2hvd24oc3RyZWFtLCBub2RlLCBkb250Rm9sbG93KSB7XFxuICAgICAgICBGUy5kb1NldEF0dHIoc3RyZWFtLCBub2RlLCB7IHRpbWVzdGFtcDogRGF0ZS5ub3coKSwgZG9udEZvbGxvdyB9KTtcXG4gICAgICB9LFxcbiAgICAgIGNob3duKHBhdGgsIHVpZCwgZ2lkLCBkb250Rm9sbG93KSB7XFxuICAgICAgICB2YXIgbm9kZTtcXG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PSBcInN0cmluZ1wiKSB7XFxuICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhZG9udEZvbGxvdyB9KTtcXG4gICAgICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgbm9kZSA9IHBhdGg7XFxuICAgICAgICB9XFxuICAgICAgICBGUy5kb0Nob3duKG51bGwsIG5vZGUsIGRvbnRGb2xsb3cpO1xcbiAgICAgIH0sXFxuICAgICAgbGNob3duKHBhdGgsIHVpZCwgZ2lkKSB7XFxuICAgICAgICBGUy5jaG93bihwYXRoLCB1aWQsIGdpZCwgdHJ1ZSk7XFxuICAgICAgfSxcXG4gICAgICBmY2hvd24oZmQsIHVpZCwgZ2lkKSB7XFxuICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtQ2hlY2tlZChmZCk7XFxuICAgICAgICBGUy5kb0Nob3duKHN0cmVhbSwgc3RyZWFtLm5vZGUsIGZhbHNlKTtcXG4gICAgICB9LFxcbiAgICAgIGRvVHJ1bmNhdGUoc3RyZWFtLCBub2RlLCBsZW4pIHtcXG4gICAgICAgIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDMxKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghRlMuaXNGaWxlKG5vZGUubW9kZSkpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5ub2RlUGVybWlzc2lvbnMobm9kZSwgXCJ3XCIpO1xcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XFxuICAgICAgICB9XFxuICAgICAgICBGUy5kb1NldEF0dHIoc3RyZWFtLCBub2RlLCB7IHNpemU6IGxlbiwgdGltZXN0YW1wOiBEYXRlLm5vdygpIH0pO1xcbiAgICAgIH0sXFxuICAgICAgdHJ1bmNhdGUocGF0aCwgbGVuKSB7XFxuICAgICAgICBpZiAobGVuIDwgMCkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgbm9kZTtcXG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PSBcInN0cmluZ1wiKSB7XFxuICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pO1xcbiAgICAgICAgICBub2RlID0gbG9va3VwLm5vZGU7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBub2RlID0gcGF0aDtcXG4gICAgICAgIH1cXG4gICAgICAgIEZTLmRvVHJ1bmNhdGUobnVsbCwgbm9kZSwgbGVuKTtcXG4gICAgICB9LFxcbiAgICAgIGZ0cnVuY2F0ZShmZCwgbGVuKSB7XFxuICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtQ2hlY2tlZChmZCk7XFxuICAgICAgICBpZiAobGVuIDwgMCB8fCAoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDApIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgRlMuZG9UcnVuY2F0ZShzdHJlYW0sIHN0cmVhbS5ub2RlLCBsZW4pO1xcbiAgICAgIH0sXFxuICAgICAgdXRpbWUocGF0aCwgYXRpbWUsIG10aW1lKSB7XFxuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogdHJ1ZSB9KTtcXG4gICAgICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7XFxuICAgICAgICB2YXIgc2V0YXR0ciA9IEZTLmNoZWNrT3BFeGlzdHMobm9kZS5ub2RlX29wcy5zZXRhdHRyLCA2Myk7XFxuICAgICAgICBzZXRhdHRyKG5vZGUsIHsgYXRpbWUsIG10aW1lIH0pO1xcbiAgICAgIH0sXFxuICAgICAgb3BlbihwYXRoLCBmbGFncywgbW9kZSA9IDQzOCkge1xcbiAgICAgICAgaWYgKHBhdGggPT09IFwiXCIpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmxhZ3MgPSB0eXBlb2YgZmxhZ3MgPT0gXCJzdHJpbmdcIiA/IEZTX21vZGVTdHJpbmdUb0ZsYWdzKGZsYWdzKSA6IGZsYWdzO1xcbiAgICAgICAgaWYgKGZsYWdzICYgNjQpIHtcXG4gICAgICAgICAgbW9kZSA9IChtb2RlICYgNDA5NSkgfCAzMjc2ODtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIG1vZGUgPSAwO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIG5vZGU7XFxuICAgICAgICB2YXIgaXNEaXJQYXRoO1xcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09IFwib2JqZWN0XCIpIHtcXG4gICAgICAgICAgbm9kZSA9IHBhdGg7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBpc0RpclBhdGggPSBwYXRoLmVuZHNXaXRoKFwiL1wiKTtcXG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwge1xcbiAgICAgICAgICAgIGZvbGxvdzogIShmbGFncyAmIDEzMTA3MiksXFxuICAgICAgICAgICAgbm9lbnRfb2theTogdHJ1ZSxcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTtcXG4gICAgICAgICAgcGF0aCA9IGxvb2t1cC5wYXRoO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGNyZWF0ZWQgPSBmYWxzZTtcXG4gICAgICAgIGlmIChmbGFncyAmIDY0KSB7XFxuICAgICAgICAgIGlmIChub2RlKSB7XFxuICAgICAgICAgICAgaWYgKGZsYWdzICYgMTI4KSB7XFxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyMCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRGlyUGF0aCkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDMxKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBub2RlID0gRlMubWtub2QocGF0aCwgbW9kZSB8IDUxMSwgMCk7XFxuICAgICAgICAgICAgY3JlYXRlZCA9IHRydWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghbm9kZSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoRlMuaXNDaHJkZXYobm9kZS5tb2RlKSkge1xcbiAgICAgICAgICBmbGFncyAmPSB+NTEyO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGZsYWdzICYgNjU1MzYgJiYgIUZTLmlzRGlyKG5vZGUubW9kZSkpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCFjcmVhdGVkKSB7XFxuICAgICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5T3Blbihub2RlLCBmbGFncyk7XFxuICAgICAgICAgIGlmIChlcnJDb2RlKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChmbGFncyAmIDUxMiAmJiAhY3JlYXRlZCkge1xcbiAgICAgICAgICBGUy50cnVuY2F0ZShub2RlLCAwKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGZsYWdzICY9IH4oMTI4IHwgNTEyIHwgMTMxMDcyKTtcXG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5jcmVhdGVTdHJlYW0oe1xcbiAgICAgICAgICBub2RlLFxcbiAgICAgICAgICBwYXRoOiBGUy5nZXRQYXRoKG5vZGUpLFxcbiAgICAgICAgICBmbGFncyxcXG4gICAgICAgICAgc2Vla2FibGU6IHRydWUsXFxuICAgICAgICAgIHBvc2l0aW9uOiAwLFxcbiAgICAgICAgICBzdHJlYW1fb3BzOiBub2RlLnN0cmVhbV9vcHMsXFxuICAgICAgICAgIHVuZ290dGVuOiBbXSxcXG4gICAgICAgICAgZXJyb3I6IGZhbHNlLFxcbiAgICAgICAgfSk7XFxuICAgICAgICBpZiAoc3RyZWFtLnN0cmVhbV9vcHMub3Blbikge1xcbiAgICAgICAgICBzdHJlYW0uc3RyZWFtX29wcy5vcGVuKHN0cmVhbSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoY3JlYXRlZCkge1xcbiAgICAgICAgICBGUy5jaG1vZChub2RlLCBtb2RlICYgNTExKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChNb2R1bGVbXCJsb2dSZWFkRmlsZXNcIl0gJiYgIShmbGFncyAmIDEpKSB7XFxuICAgICAgICAgIGlmICghKHBhdGggaW4gRlMucmVhZEZpbGVzKSkge1xcbiAgICAgICAgICAgIEZTLnJlYWRGaWxlc1twYXRoXSA9IDE7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBzdHJlYW07XFxuICAgICAgfSxcXG4gICAgICBjbG9zZShzdHJlYW0pIHtcXG4gICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHN0cmVhbS5nZXRkZW50cykgc3RyZWFtLmdldGRlbnRzID0gbnVsbDtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIGlmIChzdHJlYW0uc3RyZWFtX29wcy5jbG9zZSkge1xcbiAgICAgICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzLmNsb3NlKHN0cmVhbSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgdGhyb3cgZTtcXG4gICAgICAgIH0gZmluYWxseSB7XFxuICAgICAgICAgIEZTLmNsb3NlU3RyZWFtKHN0cmVhbS5mZCk7XFxuICAgICAgICB9XFxuICAgICAgICBzdHJlYW0uZmQgPSBudWxsO1xcbiAgICAgIH0sXFxuICAgICAgaXNDbG9zZWQoc3RyZWFtKSB7XFxuICAgICAgICByZXR1cm4gc3RyZWFtLmZkID09PSBudWxsO1xcbiAgICAgIH0sXFxuICAgICAgbGxzZWVrKHN0cmVhbSwgb2Zmc2V0LCB3aGVuY2UpIHtcXG4gICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCFzdHJlYW0uc2Vla2FibGUgfHwgIXN0cmVhbS5zdHJlYW1fb3BzLmxsc2Vlaykge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAod2hlbmNlICE9IDAgJiYgd2hlbmNlICE9IDEgJiYgd2hlbmNlICE9IDIpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc3RyZWFtLnBvc2l0aW9uID0gc3RyZWFtLnN0cmVhbV9vcHMubGxzZWVrKHN0cmVhbSwgb2Zmc2V0LCB3aGVuY2UpO1xcbiAgICAgICAgc3RyZWFtLnVuZ290dGVuID0gW107XFxuICAgICAgICByZXR1cm4gc3RyZWFtLnBvc2l0aW9uO1xcbiAgICAgIH0sXFxuICAgICAgcmVhZChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XFxuICAgICAgICBhc3NlcnQob2Zmc2V0ID49IDApO1xcbiAgICAgICAgaWYgKGxlbmd0aCA8IDAgfHwgcG9zaXRpb24gPCAwKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSA9PT0gMSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChGUy5pc0RpcihzdHJlYW0ubm9kZS5tb2RlKSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIXN0cmVhbS5zdHJlYW1fb3BzLnJlYWQpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIHNlZWtpbmcgPSB0eXBlb2YgcG9zaXRpb24gIT0gXCJ1bmRlZmluZWRcIjtcXG4gICAgICAgIGlmICghc2Vla2luZykge1xcbiAgICAgICAgICBwb3NpdGlvbiA9IHN0cmVhbS5wb3NpdGlvbjtcXG4gICAgICAgIH0gZWxzZSBpZiAoIXN0cmVhbS5zZWVrYWJsZSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCk7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgYnl0ZXNSZWFkID0gc3RyZWFtLnN0cmVhbV9vcHMucmVhZChcXG4gICAgICAgICAgc3RyZWFtLFxcbiAgICAgICAgICBidWZmZXIsXFxuICAgICAgICAgIG9mZnNldCxcXG4gICAgICAgICAgbGVuZ3RoLFxcbiAgICAgICAgICBwb3NpdGlvbixcXG4gICAgICAgICk7XFxuICAgICAgICBpZiAoIXNlZWtpbmcpIHN0cmVhbS5wb3NpdGlvbiArPSBieXRlc1JlYWQ7XFxuICAgICAgICByZXR1cm4gYnl0ZXNSZWFkO1xcbiAgICAgIH0sXFxuICAgICAgd3JpdGUoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FuT3duKSB7XFxuICAgICAgICBhc3NlcnQob2Zmc2V0ID49IDApO1xcbiAgICAgICAgaWYgKGxlbmd0aCA8IDAgfHwgcG9zaXRpb24gPCAwKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSA9PT0gMCkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChGUy5pc0RpcihzdHJlYW0ubm9kZS5tb2RlKSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIXN0cmVhbS5zdHJlYW1fb3BzLndyaXRlKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChzdHJlYW0uc2Vla2FibGUgJiYgc3RyZWFtLmZsYWdzICYgMTAyNCkge1xcbiAgICAgICAgICBGUy5sbHNlZWsoc3RyZWFtLCAwLCAyKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBzZWVraW5nID0gdHlwZW9mIHBvc2l0aW9uICE9IFwidW5kZWZpbmVkXCI7XFxuICAgICAgICBpZiAoIXNlZWtpbmcpIHtcXG4gICAgICAgICAgcG9zaXRpb24gPSBzdHJlYW0ucG9zaXRpb247XFxuICAgICAgICB9IGVsc2UgaWYgKCFzdHJlYW0uc2Vla2FibGUpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNzApO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGJ5dGVzV3JpdHRlbiA9IHN0cmVhbS5zdHJlYW1fb3BzLndyaXRlKFxcbiAgICAgICAgICBzdHJlYW0sXFxuICAgICAgICAgIGJ1ZmZlcixcXG4gICAgICAgICAgb2Zmc2V0LFxcbiAgICAgICAgICBsZW5ndGgsXFxuICAgICAgICAgIHBvc2l0aW9uLFxcbiAgICAgICAgICBjYW5Pd24sXFxuICAgICAgICApO1xcbiAgICAgICAgaWYgKCFzZWVraW5nKSBzdHJlYW0ucG9zaXRpb24gKz0gYnl0ZXNXcml0dGVuO1xcbiAgICAgICAgcmV0dXJuIGJ5dGVzV3JpdHRlbjtcXG4gICAgICB9LFxcbiAgICAgIGFsbG9jYXRlKHN0cmVhbSwgb2Zmc2V0LCBsZW5ndGgpIHtcXG4gICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgbGVuZ3RoIDw9IDApIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSA9PT0gMCkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpICYmICFGUy5pc0RpcihzdHJlYW0ubm9kZS5tb2RlKSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0Myk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIXN0cmVhbS5zdHJlYW1fb3BzLmFsbG9jYXRlKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEzOCk7XFxuICAgICAgICB9XFxuICAgICAgICBzdHJlYW0uc3RyZWFtX29wcy5hbGxvY2F0ZShzdHJlYW0sIG9mZnNldCwgbGVuZ3RoKTtcXG4gICAgICB9LFxcbiAgICAgIG1tYXAoc3RyZWFtLCBsZW5ndGgsIHBvc2l0aW9uLCBwcm90LCBmbGFncykge1xcbiAgICAgICAgaWYgKFxcbiAgICAgICAgICAocHJvdCAmIDIpICE9PSAwICYmXFxuICAgICAgICAgIChmbGFncyAmIDIpID09PSAwICYmXFxuICAgICAgICAgIChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSAhPT0gMlxcbiAgICAgICAgKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSA9PT0gMSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMubW1hcCkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0Myk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIWxlbmd0aCkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMubW1hcChzdHJlYW0sIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKTtcXG4gICAgICB9LFxcbiAgICAgIG1zeW5jKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgbW1hcEZsYWdzKSB7XFxuICAgICAgICBhc3NlcnQob2Zmc2V0ID49IDApO1xcbiAgICAgICAgaWYgKCFzdHJlYW0uc3RyZWFtX29wcy5tc3luYykge1xcbiAgICAgICAgICByZXR1cm4gMDtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBzdHJlYW0uc3RyZWFtX29wcy5tc3luYyhcXG4gICAgICAgICAgc3RyZWFtLFxcbiAgICAgICAgICBidWZmZXIsXFxuICAgICAgICAgIG9mZnNldCxcXG4gICAgICAgICAgbGVuZ3RoLFxcbiAgICAgICAgICBtbWFwRmxhZ3MsXFxuICAgICAgICApO1xcbiAgICAgIH0sXFxuICAgICAgaW9jdGwoc3RyZWFtLCBjbWQsIGFyZykge1xcbiAgICAgICAgaWYgKCFzdHJlYW0uc3RyZWFtX29wcy5pb2N0bCkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1OSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMuaW9jdGwoc3RyZWFtLCBjbWQsIGFyZyk7XFxuICAgICAgfSxcXG4gICAgICByZWFkRmlsZShwYXRoLCBvcHRzID0ge30pIHtcXG4gICAgICAgIG9wdHMuZmxhZ3MgPSBvcHRzLmZsYWdzIHx8IDA7XFxuICAgICAgICBvcHRzLmVuY29kaW5nID0gb3B0cy5lbmNvZGluZyB8fCBcImJpbmFyeVwiO1xcbiAgICAgICAgaWYgKG9wdHMuZW5jb2RpbmcgIT09IFwidXRmOFwiICYmIG9wdHMuZW5jb2RpbmcgIT09IFwiYmluYXJ5XCIpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGVuY29kaW5nIHR5cGUgXCIke29wdHMuZW5jb2Rpbmd9XCJgKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciByZXQ7XFxuICAgICAgICB2YXIgc3RyZWFtID0gRlMub3BlbihwYXRoLCBvcHRzLmZsYWdzKTtcXG4gICAgICAgIHZhciBzdGF0ID0gRlMuc3RhdChwYXRoKTtcXG4gICAgICAgIHZhciBsZW5ndGggPSBzdGF0LnNpemU7XFxuICAgICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcXG4gICAgICAgIEZTLnJlYWQoc3RyZWFtLCBidWYsIDAsIGxlbmd0aCwgMCk7XFxuICAgICAgICBpZiAob3B0cy5lbmNvZGluZyA9PT0gXCJ1dGY4XCIpIHtcXG4gICAgICAgICAgcmV0ID0gVVRGOEFycmF5VG9TdHJpbmcoYnVmKTtcXG4gICAgICAgIH0gZWxzZSBpZiAob3B0cy5lbmNvZGluZyA9PT0gXCJiaW5hcnlcIikge1xcbiAgICAgICAgICByZXQgPSBidWY7XFxuICAgICAgICB9XFxuICAgICAgICBGUy5jbG9zZShzdHJlYW0pO1xcbiAgICAgICAgcmV0dXJuIHJldDtcXG4gICAgICB9LFxcbiAgICAgIHdyaXRlRmlsZShwYXRoLCBkYXRhLCBvcHRzID0ge30pIHtcXG4gICAgICAgIG9wdHMuZmxhZ3MgPSBvcHRzLmZsYWdzIHx8IDU3NztcXG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5vcGVuKHBhdGgsIG9wdHMuZmxhZ3MsIG9wdHMubW9kZSk7XFxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gXCJzdHJpbmdcIikge1xcbiAgICAgICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoQnl0ZXNVVEY4KGRhdGEpICsgMSk7XFxuICAgICAgICAgIHZhciBhY3R1YWxOdW1CeXRlcyA9IHN0cmluZ1RvVVRGOEFycmF5KGRhdGEsIGJ1ZiwgMCwgYnVmLmxlbmd0aCk7XFxuICAgICAgICAgIEZTLndyaXRlKHN0cmVhbSwgYnVmLCAwLCBhY3R1YWxOdW1CeXRlcywgdW5kZWZpbmVkLCBvcHRzLmNhbk93bik7XFxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xcbiAgICAgICAgICBGUy53cml0ZShzdHJlYW0sIGRhdGEsIDAsIGRhdGEuYnl0ZUxlbmd0aCwgdW5kZWZpbmVkLCBvcHRzLmNhbk93bik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkYXRhIHR5cGVcIik7XFxuICAgICAgICB9XFxuICAgICAgICBGUy5jbG9zZShzdHJlYW0pO1xcbiAgICAgIH0sXFxuICAgICAgY3dkOiAoKSA9PiBGUy5jdXJyZW50UGF0aCxcXG4gICAgICBjaGRpcihwYXRoKSB7XFxuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogdHJ1ZSB9KTtcXG4gICAgICAgIGlmIChsb29rdXAubm9kZSA9PT0gbnVsbCkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIUZTLmlzRGlyKGxvb2t1cC5ub2RlLm1vZGUpKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU0KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKGxvb2t1cC5ub2RlLCBcInhcIik7XFxuICAgICAgICBpZiAoZXJyQ29kZSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIEZTLmN1cnJlbnRQYXRoID0gbG9va3VwLnBhdGg7XFxuICAgICAgfSxcXG4gICAgICBjcmVhdGVEZWZhdWx0RGlyZWN0b3JpZXMoKSB7XFxuICAgICAgICBGUy5ta2RpcihcIi90bXBcIik7XFxuICAgICAgICBGUy5ta2RpcihcIi9ob21lXCIpO1xcbiAgICAgICAgRlMubWtkaXIoXCIvaG9tZS93ZWJfdXNlclwiKTtcXG4gICAgICB9LFxcbiAgICAgIGNyZWF0ZURlZmF1bHREZXZpY2VzKCkge1xcbiAgICAgICAgRlMubWtkaXIoXCIvZGV2XCIpO1xcbiAgICAgICAgRlMucmVnaXN0ZXJEZXZpY2UoRlMubWFrZWRldigxLCAzKSwge1xcbiAgICAgICAgICByZWFkOiAoKSA9PiAwLFxcbiAgICAgICAgICB3cml0ZTogKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zKSA9PiBsZW5ndGgsXFxuICAgICAgICAgIGxsc2VlazogKCkgPT4gMCxcXG4gICAgICAgIH0pO1xcbiAgICAgICAgRlMubWtkZXYoXCIvZGV2L251bGxcIiwgRlMubWFrZWRldigxLCAzKSk7XFxuICAgICAgICBUVFkucmVnaXN0ZXIoRlMubWFrZWRldig1LCAwKSwgVFRZLmRlZmF1bHRfdHR5X29wcyk7XFxuICAgICAgICBUVFkucmVnaXN0ZXIoRlMubWFrZWRldig2LCAwKSwgVFRZLmRlZmF1bHRfdHR5MV9vcHMpO1xcbiAgICAgICAgRlMubWtkZXYoXCIvZGV2L3R0eVwiLCBGUy5tYWtlZGV2KDUsIDApKTtcXG4gICAgICAgIEZTLm1rZGV2KFwiL2Rldi90dHkxXCIsIEZTLm1ha2VkZXYoNiwgMCkpO1xcbiAgICAgICAgdmFyIHJhbmRvbUJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEwMjQpLFxcbiAgICAgICAgICByYW5kb21MZWZ0ID0gMDtcXG4gICAgICAgIHZhciByYW5kb21CeXRlID0gKCkgPT4ge1xcbiAgICAgICAgICBpZiAocmFuZG9tTGVmdCA9PT0gMCkge1xcbiAgICAgICAgICAgIHJhbmRvbUZpbGwocmFuZG9tQnVmZmVyKTtcXG4gICAgICAgICAgICByYW5kb21MZWZ0ID0gcmFuZG9tQnVmZmVyLmJ5dGVMZW5ndGg7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIHJhbmRvbUJ1ZmZlclstLXJhbmRvbUxlZnRdO1xcbiAgICAgICAgfTtcXG4gICAgICAgIEZTLmNyZWF0ZURldmljZShcIi9kZXZcIiwgXCJyYW5kb21cIiwgcmFuZG9tQnl0ZSk7XFxuICAgICAgICBGUy5jcmVhdGVEZXZpY2UoXCIvZGV2XCIsIFwidXJhbmRvbVwiLCByYW5kb21CeXRlKTtcXG4gICAgICAgIEZTLm1rZGlyKFwiL2Rldi9zaG1cIik7XFxuICAgICAgICBGUy5ta2RpcihcIi9kZXYvc2htL3RtcFwiKTtcXG4gICAgICB9LFxcbiAgICAgIGNyZWF0ZVNwZWNpYWxEaXJlY3RvcmllcygpIHtcXG4gICAgICAgIEZTLm1rZGlyKFwiL3Byb2NcIik7XFxuICAgICAgICB2YXIgcHJvY19zZWxmID0gRlMubWtkaXIoXCIvcHJvYy9zZWxmXCIpO1xcbiAgICAgICAgRlMubWtkaXIoXCIvcHJvYy9zZWxmL2ZkXCIpO1xcbiAgICAgICAgRlMubW91bnQoXFxuICAgICAgICAgIHtcXG4gICAgICAgICAgICBtb3VudCgpIHtcXG4gICAgICAgICAgICAgIHZhciBub2RlID0gRlMuY3JlYXRlTm9kZShwcm9jX3NlbGYsIFwiZmRcIiwgMTY4OTUsIDczKTtcXG4gICAgICAgICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IHsgbGxzZWVrOiBNRU1GUy5zdHJlYW1fb3BzLmxsc2VlayB9O1xcbiAgICAgICAgICAgICAgbm9kZS5ub2RlX29wcyA9IHtcXG4gICAgICAgICAgICAgICAgbG9va3VwKHBhcmVudCwgbmFtZSkge1xcbiAgICAgICAgICAgICAgICAgIHZhciBmZCA9ICtuYW1lO1xcbiAgICAgICAgICAgICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW1DaGVja2VkKGZkKTtcXG4gICAgICAgICAgICAgICAgICB2YXIgcmV0ID0ge1xcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxcbiAgICAgICAgICAgICAgICAgICAgbW91bnQ6IHsgbW91bnRwb2ludDogXCJmYWtlXCIgfSxcXG4gICAgICAgICAgICAgICAgICAgIG5vZGVfb3BzOiB7IHJlYWRsaW5rOiAoKSA9PiBzdHJlYW0ucGF0aCB9LFxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGZkICsgMSxcXG4gICAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICAgIHJldC5wYXJlbnQgPSByZXQ7XFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgcmVhZGRpcigpIHtcXG4gICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShGUy5zdHJlYW1zLmVudHJpZXMoKSlcXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKFtrLCB2XSkgPT4gdilcXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKFtrLCB2XSkgPT4gay50b1N0cmluZygpKTtcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICB9LFxcbiAgICAgICAgICB7fSxcXG4gICAgICAgICAgXCIvcHJvYy9zZWxmL2ZkXCIsXFxuICAgICAgICApO1xcbiAgICAgIH0sXFxuICAgICAgY3JlYXRlU3RhbmRhcmRTdHJlYW1zKGlucHV0LCBvdXRwdXQsIGVycm9yKSB7XFxuICAgICAgICBpZiAoaW5wdXQpIHtcXG4gICAgICAgICAgRlMuY3JlYXRlRGV2aWNlKFwiL2RldlwiLCBcInN0ZGluXCIsIGlucHV0KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIEZTLnN5bWxpbmsoXCIvZGV2L3R0eVwiLCBcIi9kZXYvc3RkaW5cIik7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAob3V0cHV0KSB7XFxuICAgICAgICAgIEZTLmNyZWF0ZURldmljZShcIi9kZXZcIiwgXCJzdGRvdXRcIiwgbnVsbCwgb3V0cHV0KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIEZTLnN5bWxpbmsoXCIvZGV2L3R0eVwiLCBcIi9kZXYvc3Rkb3V0XCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGVycm9yKSB7XFxuICAgICAgICAgIEZTLmNyZWF0ZURldmljZShcIi9kZXZcIiwgXCJzdGRlcnJcIiwgbnVsbCwgZXJyb3IpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgRlMuc3ltbGluayhcIi9kZXYvdHR5MVwiLCBcIi9kZXYvc3RkZXJyXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIHN0ZGluID0gRlMub3BlbihcIi9kZXYvc3RkaW5cIiwgMCk7XFxuICAgICAgICB2YXIgc3Rkb3V0ID0gRlMub3BlbihcIi9kZXYvc3Rkb3V0XCIsIDEpO1xcbiAgICAgICAgdmFyIHN0ZGVyciA9IEZTLm9wZW4oXCIvZGV2L3N0ZGVyclwiLCAxKTtcXG4gICAgICAgIGFzc2VydChzdGRpbi5mZCA9PT0gMCwgYGludmFsaWQgaGFuZGxlIGZvciBzdGRpbiAoJHtzdGRpbi5mZH0pYCk7XFxuICAgICAgICBhc3NlcnQoc3Rkb3V0LmZkID09PSAxLCBgaW52YWxpZCBoYW5kbGUgZm9yIHN0ZG91dCAoJHtzdGRvdXQuZmR9KWApO1xcbiAgICAgICAgYXNzZXJ0KHN0ZGVyci5mZCA9PT0gMiwgYGludmFsaWQgaGFuZGxlIGZvciBzdGRlcnIgKCR7c3RkZXJyLmZkfSlgKTtcXG4gICAgICB9LFxcbiAgICAgIHN0YXRpY0luaXQoKSB7XFxuICAgICAgICBGUy5uYW1lVGFibGUgPSBuZXcgQXJyYXkoNDA5Nik7XFxuICAgICAgICBGUy5tb3VudChNRU1GUywge30sIFwiL1wiKTtcXG4gICAgICAgIEZTLmNyZWF0ZURlZmF1bHREaXJlY3RvcmllcygpO1xcbiAgICAgICAgRlMuY3JlYXRlRGVmYXVsdERldmljZXMoKTtcXG4gICAgICAgIEZTLmNyZWF0ZVNwZWNpYWxEaXJlY3RvcmllcygpO1xcbiAgICAgICAgRlMuZmlsZXN5c3RlbXMgPSB7IE1FTUZTIH07XFxuICAgICAgfSxcXG4gICAgICBpbml0KGlucHV0LCBvdXRwdXQsIGVycm9yKSB7XFxuICAgICAgICBhc3NlcnQoXFxuICAgICAgICAgICFGUy5pbml0aWFsaXplZCxcXG4gICAgICAgICAgXCJGUy5pbml0IHdhcyBwcmV2aW91c2x5IGNhbGxlZC4gSWYgeW91IHdhbnQgdG8gaW5pdGlhbGl6ZSBsYXRlciB3aXRoIGN1c3RvbSBwYXJhbWV0ZXJzLCByZW1vdmUgYW55IGVhcmxpZXIgY2FsbHMgKG5vdGUgdGhhdCBvbmUgaXMgYXV0b21hdGljYWxseSBhZGRlZCB0byB0aGUgZ2VuZXJhdGVkIGNvZGUpXCIsXFxuICAgICAgICApO1xcbiAgICAgICAgRlMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xcbiAgICAgICAgaW5wdXQgPz89IE1vZHVsZVtcInN0ZGluXCJdO1xcbiAgICAgICAgb3V0cHV0ID8/PSBNb2R1bGVbXCJzdGRvdXRcIl07XFxuICAgICAgICBlcnJvciA/Pz0gTW9kdWxlW1wic3RkZXJyXCJdO1xcbiAgICAgICAgRlMuY3JlYXRlU3RhbmRhcmRTdHJlYW1zKGlucHV0LCBvdXRwdXQsIGVycm9yKTtcXG4gICAgICB9LFxcbiAgICAgIHF1aXQoKSB7XFxuICAgICAgICBGUy5pbml0aWFsaXplZCA9IGZhbHNlO1xcbiAgICAgICAgX2ZmbHVzaCgwKTtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRlMuc3RyZWFtcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICB2YXIgc3RyZWFtID0gRlMuc3RyZWFtc1tpXTtcXG4gICAgICAgICAgaWYgKCFzdHJlYW0pIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBGUy5jbG9zZShzdHJlYW0pO1xcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgZmluZE9iamVjdChwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKSB7XFxuICAgICAgICB2YXIgcmV0ID0gRlMuYW5hbHl6ZVBhdGgocGF0aCwgZG9udFJlc29sdmVMYXN0TGluayk7XFxuICAgICAgICBpZiAoIXJldC5leGlzdHMpIHtcXG4gICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcmV0Lm9iamVjdDtcXG4gICAgICB9LFxcbiAgICAgIGFuYWx5emVQYXRoKHBhdGgsIGRvbnRSZXNvbHZlTGFzdExpbmspIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhZG9udFJlc29sdmVMYXN0TGluayB9KTtcXG4gICAgICAgICAgcGF0aCA9IGxvb2t1cC5wYXRoO1xcbiAgICAgICAgfSBjYXRjaCAoZSkge31cXG4gICAgICAgIHZhciByZXQgPSB7XFxuICAgICAgICAgIGlzUm9vdDogZmFsc2UsXFxuICAgICAgICAgIGV4aXN0czogZmFsc2UsXFxuICAgICAgICAgIGVycm9yOiAwLFxcbiAgICAgICAgICBuYW1lOiBudWxsLFxcbiAgICAgICAgICBwYXRoOiBudWxsLFxcbiAgICAgICAgICBvYmplY3Q6IG51bGwsXFxuICAgICAgICAgIHBhcmVudEV4aXN0czogZmFsc2UsXFxuICAgICAgICAgIHBhcmVudFBhdGg6IG51bGwsXFxuICAgICAgICAgIHBhcmVudE9iamVjdDogbnVsbCxcXG4gICAgICAgIH07XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcXG4gICAgICAgICAgcmV0LnBhcmVudEV4aXN0cyA9IHRydWU7XFxuICAgICAgICAgIHJldC5wYXJlbnRQYXRoID0gbG9va3VwLnBhdGg7XFxuICAgICAgICAgIHJldC5wYXJlbnRPYmplY3QgPSBsb29rdXAubm9kZTtcXG4gICAgICAgICAgcmV0Lm5hbWUgPSBQQVRILmJhc2VuYW1lKHBhdGgpO1xcbiAgICAgICAgICBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhZG9udFJlc29sdmVMYXN0TGluayB9KTtcXG4gICAgICAgICAgcmV0LmV4aXN0cyA9IHRydWU7XFxuICAgICAgICAgIHJldC5wYXRoID0gbG9va3VwLnBhdGg7XFxuICAgICAgICAgIHJldC5vYmplY3QgPSBsb29rdXAubm9kZTtcXG4gICAgICAgICAgcmV0Lm5hbWUgPSBsb29rdXAubm9kZS5uYW1lO1xcbiAgICAgICAgICByZXQuaXNSb290ID0gbG9va3VwLnBhdGggPT09IFwiL1wiO1xcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICByZXQuZXJyb3IgPSBlLmVycm5vO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHJldDtcXG4gICAgICB9LFxcbiAgICAgIGNyZWF0ZVBhdGgocGFyZW50LCBwYXRoLCBjYW5SZWFkLCBjYW5Xcml0ZSkge1xcbiAgICAgICAgcGFyZW50ID0gdHlwZW9mIHBhcmVudCA9PSBcInN0cmluZ1wiID8gcGFyZW50IDogRlMuZ2V0UGF0aChwYXJlbnQpO1xcbiAgICAgICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdChcIi9cIikucmV2ZXJzZSgpO1xcbiAgICAgICAgd2hpbGUgKHBhcnRzLmxlbmd0aCkge1xcbiAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzLnBvcCgpO1xcbiAgICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xcbiAgICAgICAgICB2YXIgY3VycmVudCA9IFBBVEguam9pbjIocGFyZW50LCBwYXJ0KTtcXG4gICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBGUy5ta2RpcihjdXJyZW50KTtcXG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cXG4gICAgICAgICAgcGFyZW50ID0gY3VycmVudDtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBjdXJyZW50O1xcbiAgICAgIH0sXFxuICAgICAgY3JlYXRlRmlsZShwYXJlbnQsIG5hbWUsIHByb3BlcnRpZXMsIGNhblJlYWQsIGNhbldyaXRlKSB7XFxuICAgICAgICB2YXIgcGF0aCA9IFBBVEguam9pbjIoXFxuICAgICAgICAgIHR5cGVvZiBwYXJlbnQgPT0gXCJzdHJpbmdcIiA/IHBhcmVudCA6IEZTLmdldFBhdGgocGFyZW50KSxcXG4gICAgICAgICAgbmFtZSxcXG4gICAgICAgICk7XFxuICAgICAgICB2YXIgbW9kZSA9IEZTX2dldE1vZGUoY2FuUmVhZCwgY2FuV3JpdGUpO1xcbiAgICAgICAgcmV0dXJuIEZTLmNyZWF0ZShwYXRoLCBtb2RlKTtcXG4gICAgICB9LFxcbiAgICAgIGNyZWF0ZURhdGFGaWxlKHBhcmVudCwgbmFtZSwgZGF0YSwgY2FuUmVhZCwgY2FuV3JpdGUsIGNhbk93bikge1xcbiAgICAgICAgdmFyIHBhdGggPSBuYW1lO1xcbiAgICAgICAgaWYgKHBhcmVudCkge1xcbiAgICAgICAgICBwYXJlbnQgPSB0eXBlb2YgcGFyZW50ID09IFwic3RyaW5nXCIgPyBwYXJlbnQgOiBGUy5nZXRQYXRoKHBhcmVudCk7XFxuICAgICAgICAgIHBhdGggPSBuYW1lID8gUEFUSC5qb2luMihwYXJlbnQsIG5hbWUpIDogcGFyZW50O1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIG1vZGUgPSBGU19nZXRNb2RlKGNhblJlYWQsIGNhbldyaXRlKTtcXG4gICAgICAgIHZhciBub2RlID0gRlMuY3JlYXRlKHBhdGgsIG1vZGUpO1xcbiAgICAgICAgaWYgKGRhdGEpIHtcXG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09IFwic3RyaW5nXCIpIHtcXG4gICAgICAgICAgICB2YXIgYXJyID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47ICsraSlcXG4gICAgICAgICAgICAgIGFycltpXSA9IGRhdGEuY2hhckNvZGVBdChpKTtcXG4gICAgICAgICAgICBkYXRhID0gYXJyO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIEZTLmNobW9kKG5vZGUsIG1vZGUgfCAxNDYpO1xcbiAgICAgICAgICB2YXIgc3RyZWFtID0gRlMub3Blbihub2RlLCA1NzcpO1xcbiAgICAgICAgICBGUy53cml0ZShzdHJlYW0sIGRhdGEsIDAsIGRhdGEubGVuZ3RoLCAwLCBjYW5Pd24pO1xcbiAgICAgICAgICBGUy5jbG9zZShzdHJlYW0pO1xcbiAgICAgICAgICBGUy5jaG1vZChub2RlLCBtb2RlKTtcXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgIGNyZWF0ZURldmljZShwYXJlbnQsIG5hbWUsIGlucHV0LCBvdXRwdXQpIHtcXG4gICAgICAgIHZhciBwYXRoID0gUEFUSC5qb2luMihcXG4gICAgICAgICAgdHlwZW9mIHBhcmVudCA9PSBcInN0cmluZ1wiID8gcGFyZW50IDogRlMuZ2V0UGF0aChwYXJlbnQpLFxcbiAgICAgICAgICBuYW1lLFxcbiAgICAgICAgKTtcXG4gICAgICAgIHZhciBtb2RlID0gRlNfZ2V0TW9kZSghIWlucHV0LCAhIW91dHB1dCk7XFxuICAgICAgICBGUy5jcmVhdGVEZXZpY2UubWFqb3IgPz89IDY0O1xcbiAgICAgICAgdmFyIGRldiA9IEZTLm1ha2VkZXYoRlMuY3JlYXRlRGV2aWNlLm1ham9yKyssIDApO1xcbiAgICAgICAgRlMucmVnaXN0ZXJEZXZpY2UoZGV2LCB7XFxuICAgICAgICAgIG9wZW4oc3RyZWFtKSB7XFxuICAgICAgICAgICAgc3RyZWFtLnNlZWthYmxlID0gZmFsc2U7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGNsb3NlKHN0cmVhbSkge1xcbiAgICAgICAgICAgIGlmIChvdXRwdXQ/LmJ1ZmZlcj8ubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICBvdXRwdXQoMTApO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgcmVhZChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvcykge1xcbiAgICAgICAgICAgIHZhciBieXRlc1JlYWQgPSAwO1xcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgIHZhciByZXN1bHQ7XFxuICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnB1dCgpO1xcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQgJiYgYnl0ZXNSZWFkID09PSAwKSB7XFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHVuZGVmaW5lZCkgYnJlYWs7XFxuICAgICAgICAgICAgICBieXRlc1JlYWQrKztcXG4gICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IHJlc3VsdDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKGJ5dGVzUmVhZCkge1xcbiAgICAgICAgICAgICAgc3RyZWFtLm5vZGUuYXRpbWUgPSBEYXRlLm5vdygpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gYnl0ZXNSZWFkO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICB3cml0ZShzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvcykge1xcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgIG91dHB1dChidWZmZXJbb2Zmc2V0ICsgaV0pO1xcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChsZW5ndGgpIHtcXG4gICAgICAgICAgICAgIHN0cmVhbS5ub2RlLm10aW1lID0gc3RyZWFtLm5vZGUuY3RpbWUgPSBEYXRlLm5vdygpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gaTtcXG4gICAgICAgICAgfSxcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIEZTLm1rZGV2KHBhdGgsIG1vZGUsIGRldik7XFxuICAgICAgfSxcXG4gICAgICBmb3JjZUxvYWRGaWxlKG9iaikge1xcbiAgICAgICAgaWYgKG9iai5pc0RldmljZSB8fCBvYmouaXNGb2xkZXIgfHwgb2JqLmxpbmsgfHwgb2JqLmNvbnRlbnRzKVxcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT0gXCJ1bmRlZmluZWRcIikge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxuICAgICAgICAgICAgXCJMYXp5IGxvYWRpbmcgc2hvdWxkIGhhdmUgYmVlbiBwZXJmb3JtZWQgKGNvbnRlbnRzIHNldCkgaW4gY3JlYXRlTGF6eUZpbGUsIGJ1dCBpdCB3YXMgbm90LiBMYXp5IGxvYWRpbmcgb25seSB3b3JrcyBpbiB3ZWIgd29ya2Vycy4gVXNlIC0tZW1iZWQtZmlsZSBvciAtLXByZWxvYWQtZmlsZSBpbiBlbWNjIG9uIHRoZSBtYWluIHRocmVhZC5cIixcXG4gICAgICAgICAgKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgb2JqLmNvbnRlbnRzID0gcmVhZEJpbmFyeShvYmoudXJsKTtcXG4gICAgICAgICAgICBvYmoudXNlZEJ5dGVzID0gb2JqLmNvbnRlbnRzLmxlbmd0aDtcXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgY3JlYXRlTGF6eUZpbGUocGFyZW50LCBuYW1lLCB1cmwsIGNhblJlYWQsIGNhbldyaXRlKSB7XFxuICAgICAgICBjbGFzcyBMYXp5VWludDhBcnJheSB7XFxuICAgICAgICAgIGxlbmd0aEtub3duID0gZmFsc2U7XFxuICAgICAgICAgIGNodW5rcyA9IFtdO1xcbiAgICAgICAgICBnZXQoaWR4KSB7XFxuICAgICAgICAgICAgaWYgKGlkeCA+IHRoaXMubGVuZ3RoIC0gMSB8fCBpZHggPCAwKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB2YXIgY2h1bmtPZmZzZXQgPSBpZHggJSB0aGlzLmNodW5rU2l6ZTtcXG4gICAgICAgICAgICB2YXIgY2h1bmtOdW0gPSAoaWR4IC8gdGhpcy5jaHVua1NpemUpIHwgMDtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXR0ZXIoY2h1bmtOdW0pW2NodW5rT2Zmc2V0XTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXREYXRhR2V0dGVyKGdldHRlcikge1xcbiAgICAgICAgICAgIHRoaXMuZ2V0dGVyID0gZ2V0dGVyO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGNhY2hlTGVuZ3RoKCkge1xcbiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcXG4gICAgICAgICAgICB4aHIub3BlbihcIkhFQURcIiwgdXJsLCBmYWxzZSk7XFxuICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XFxuICAgICAgICAgICAgaWYgKFxcbiAgICAgICAgICAgICAgISgoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkgfHwgeGhyLnN0YXR1cyA9PT0gMzA0KVxcbiAgICAgICAgICAgIClcXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXG4gICAgICAgICAgICAgICAgXCJDb3VsZG5cXCd0IGxvYWQgXCIgKyB1cmwgKyBcIi4gU3RhdHVzOiBcIiArIHhoci5zdGF0dXMsXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgIHZhciBkYXRhbGVuZ3RoID0gTnVtYmVyKHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtbGVuZ3RoXCIpKTtcXG4gICAgICAgICAgICB2YXIgaGVhZGVyO1xcbiAgICAgICAgICAgIHZhciBoYXNCeXRlU2VydmluZyA9XFxuICAgICAgICAgICAgICAoaGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiQWNjZXB0LVJhbmdlc1wiKSkgJiZcXG4gICAgICAgICAgICAgIGhlYWRlciA9PT0gXCJieXRlc1wiO1xcbiAgICAgICAgICAgIHZhciB1c2VzR3ppcCA9XFxuICAgICAgICAgICAgICAoaGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1FbmNvZGluZ1wiKSkgJiZcXG4gICAgICAgICAgICAgIGhlYWRlciA9PT0gXCJnemlwXCI7XFxuICAgICAgICAgICAgdmFyIGNodW5rU2l6ZSA9IDEwMjQgKiAxMDI0O1xcbiAgICAgICAgICAgIGlmICghaGFzQnl0ZVNlcnZpbmcpIGNodW5rU2l6ZSA9IGRhdGFsZW5ndGg7XFxuICAgICAgICAgICAgdmFyIGRvWEhSID0gKGZyb20sIHRvKSA9PiB7XFxuICAgICAgICAgICAgICBpZiAoZnJvbSA+IHRvKVxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxuICAgICAgICAgICAgICAgICAgXCJpbnZhbGlkIHJhbmdlIChcIiArXFxuICAgICAgICAgICAgICAgICAgICBmcm9tICtcXG4gICAgICAgICAgICAgICAgICAgIFwiLCBcIiArXFxuICAgICAgICAgICAgICAgICAgICB0byArXFxuICAgICAgICAgICAgICAgICAgICBcIikgb3Igbm8gYnl0ZXMgcmVxdWVzdGVkIVwiLFxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgaWYgKHRvID4gZGF0YWxlbmd0aCAtIDEpXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXG4gICAgICAgICAgICAgICAgICBcIm9ubHkgXCIgKyBkYXRhbGVuZ3RoICsgXCIgYnl0ZXMgYXZhaWxhYmxlISBwcm9ncmFtbWVyIGVycm9yIVwiLFxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xcbiAgICAgICAgICAgICAgeGhyLm9wZW4oXCJHRVRcIiwgdXJsLCBmYWxzZSk7XFxuICAgICAgICAgICAgICBpZiAoZGF0YWxlbmd0aCAhPT0gY2h1bmtTaXplKVxcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIlJhbmdlXCIsIFwiYnl0ZXM9XCIgKyBmcm9tICsgXCItXCIgKyB0byk7XFxuICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xcbiAgICAgICAgICAgICAgaWYgKHhoci5vdmVycmlkZU1pbWVUeXBlKSB7XFxuICAgICAgICAgICAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKFwidGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZFwiKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xcbiAgICAgICAgICAgICAgaWYgKFxcbiAgICAgICAgICAgICAgICAhKCh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB8fCB4aHIuc3RhdHVzID09PSAzMDQpXFxuICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXG4gICAgICAgICAgICAgICAgICBcIkNvdWxkblxcJ3QgbG9hZCBcIiArIHVybCArIFwiLiBTdGF0dXM6IFwiICsgeGhyLnN0YXR1cyxcXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIGlmICh4aHIucmVzcG9uc2UgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlIHx8IFtdKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIHJldHVybiBpbnRBcnJheUZyb21TdHJpbmcoeGhyLnJlc3BvbnNlVGV4dCB8fCBcIlwiLCB0cnVlKTtcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIHZhciBsYXp5QXJyYXkgPSB0aGlzO1xcbiAgICAgICAgICAgIGxhenlBcnJheS5zZXREYXRhR2V0dGVyKChjaHVua051bSkgPT4ge1xcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY2h1bmtOdW0gKiBjaHVua1NpemU7XFxuICAgICAgICAgICAgICB2YXIgZW5kID0gKGNodW5rTnVtICsgMSkgKiBjaHVua1NpemUgLSAxO1xcbiAgICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCBkYXRhbGVuZ3RoIC0gMSk7XFxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dID09IFwidW5kZWZpbmVkXCIpIHtcXG4gICAgICAgICAgICAgICAgbGF6eUFycmF5LmNodW5rc1tjaHVua051bV0gPSBkb1hIUihzdGFydCwgZW5kKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbGF6eUFycmF5LmNodW5rc1tjaHVua051bV0gPT0gXCJ1bmRlZmluZWRcIilcXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZG9YSFIgZmFpbGVkIVwiKTtcXG4gICAgICAgICAgICAgIHJldHVybiBsYXp5QXJyYXkuY2h1bmtzW2NodW5rTnVtXTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBpZiAodXNlc0d6aXAgfHwgIWRhdGFsZW5ndGgpIHtcXG4gICAgICAgICAgICAgIGNodW5rU2l6ZSA9IGRhdGFsZW5ndGggPSAxO1xcbiAgICAgICAgICAgICAgZGF0YWxlbmd0aCA9IHRoaXMuZ2V0dGVyKDApLmxlbmd0aDtcXG4gICAgICAgICAgICAgIGNodW5rU2l6ZSA9IGRhdGFsZW5ndGg7XFxuICAgICAgICAgICAgICBvdXQoXFxuICAgICAgICAgICAgICAgIFwiTGF6eUZpbGVzIG9uIGd6aXAgZm9yY2VzIGRvd25sb2FkIG9mIHRoZSB3aG9sZSBmaWxlIHdoZW4gbGVuZ3RoIGlzIGFjY2Vzc2VkXCIsXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB0aGlzLl9sZW5ndGggPSBkYXRhbGVuZ3RoO1xcbiAgICAgICAgICAgIHRoaXMuX2NodW5rU2l6ZSA9IGNodW5rU2l6ZTtcXG4gICAgICAgICAgICB0aGlzLmxlbmd0aEtub3duID0gdHJ1ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBnZXQgbGVuZ3RoKCkge1xcbiAgICAgICAgICAgIGlmICghdGhpcy5sZW5ndGhLbm93bikge1xcbiAgICAgICAgICAgICAgdGhpcy5jYWNoZUxlbmd0aCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGdldCBjaHVua1NpemUoKSB7XFxuICAgICAgICAgICAgaWYgKCF0aGlzLmxlbmd0aEtub3duKSB7XFxuICAgICAgICAgICAgICB0aGlzLmNhY2hlTGVuZ3RoKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaHVua1NpemU7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT0gXCJ1bmRlZmluZWRcIikge1xcbiAgICAgICAgICBpZiAoIUVOVklST05NRU5UX0lTX1dPUktFUilcXG4gICAgICAgICAgICB0aHJvdyBcIkNhbm5vdCBkbyBzeW5jaHJvbm91cyBiaW5hcnkgWEhScyBvdXRzaWRlIHdlYndvcmtlcnMgaW4gbW9kZXJuIGJyb3dzZXJzLiBVc2UgLS1lbWJlZC1maWxlIG9yIC0tcHJlbG9hZC1maWxlIGluIGVtY2NcIjtcXG4gICAgICAgICAgdmFyIGxhenlBcnJheSA9IG5ldyBMYXp5VWludDhBcnJheSgpO1xcbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHsgaXNEZXZpY2U6IGZhbHNlLCBjb250ZW50czogbGF6eUFycmF5IH07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHsgaXNEZXZpY2U6IGZhbHNlLCB1cmwgfTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBub2RlID0gRlMuY3JlYXRlRmlsZShwYXJlbnQsIG5hbWUsIHByb3BlcnRpZXMsIGNhblJlYWQsIGNhbldyaXRlKTtcXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmNvbnRlbnRzKSB7XFxuICAgICAgICAgIG5vZGUuY29udGVudHMgPSBwcm9wZXJ0aWVzLmNvbnRlbnRzO1xcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0aWVzLnVybCkge1xcbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbnVsbDtcXG4gICAgICAgICAgbm9kZS51cmwgPSBwcm9wZXJ0aWVzLnVybDtcXG4gICAgICAgIH1cXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG5vZGUsIHtcXG4gICAgICAgICAgdXNlZEJ5dGVzOiB7XFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50cy5sZW5ndGg7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgfSxcXG4gICAgICAgIH0pO1xcbiAgICAgICAgdmFyIHN0cmVhbV9vcHMgPSB7fTtcXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobm9kZS5zdHJlYW1fb3BzKTtcXG4gICAgICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XFxuICAgICAgICAgIHZhciBmbiA9IG5vZGUuc3RyZWFtX29wc1trZXldO1xcbiAgICAgICAgICBzdHJlYW1fb3BzW2tleV0gPSAoLi4uYXJncykgPT4ge1xcbiAgICAgICAgICAgIEZTLmZvcmNlTG9hZEZpbGUobm9kZSk7XFxuICAgICAgICAgICAgcmV0dXJuIGZuKC4uLmFyZ3MpO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSk7XFxuICAgICAgICBmdW5jdGlvbiB3cml0ZUNodW5rcyhzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XFxuICAgICAgICAgIHZhciBjb250ZW50cyA9IHN0cmVhbS5ub2RlLmNvbnRlbnRzO1xcbiAgICAgICAgICBpZiAocG9zaXRpb24gPj0gY29udGVudHMubGVuZ3RoKSByZXR1cm4gMDtcXG4gICAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbihjb250ZW50cy5sZW5ndGggLSBwb3NpdGlvbiwgbGVuZ3RoKTtcXG4gICAgICAgICAgYXNzZXJ0KHNpemUgPj0gMCk7XFxuICAgICAgICAgIGlmIChjb250ZW50cy5zbGljZSkge1xcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XFxuICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaV0gPSBjb250ZW50c1twb3NpdGlvbiArIGldO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xcbiAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIGldID0gY29udGVudHMuZ2V0KHBvc2l0aW9uICsgaSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJldHVybiBzaXplO1xcbiAgICAgICAgfVxcbiAgICAgICAgc3RyZWFtX29wcy5yZWFkID0gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pID0+IHtcXG4gICAgICAgICAgRlMuZm9yY2VMb2FkRmlsZShub2RlKTtcXG4gICAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtzKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pO1xcbiAgICAgICAgfTtcXG4gICAgICAgIHN0cmVhbV9vcHMubW1hcCA9IChzdHJlYW0sIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKSA9PiB7XFxuICAgICAgICAgIEZTLmZvcmNlTG9hZEZpbGUobm9kZSk7XFxuICAgICAgICAgIHZhciBwdHIgPSBtbWFwQWxsb2MobGVuZ3RoKTtcXG4gICAgICAgICAgaWYgKCFwdHIpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0OCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgd3JpdGVDaHVua3Moc3RyZWFtLCBIRUFQOCwgcHRyLCBsZW5ndGgsIHBvc2l0aW9uKTtcXG4gICAgICAgICAgcmV0dXJuIHsgcHRyLCBhbGxvY2F0ZWQ6IHRydWUgfTtcXG4gICAgICAgIH07XFxuICAgICAgICBub2RlLnN0cmVhbV9vcHMgPSBzdHJlYW1fb3BzO1xcbiAgICAgICAgcmV0dXJuIG5vZGU7XFxuICAgICAgfSxcXG4gICAgICBhYnNvbHV0ZVBhdGgoKSB7XFxuICAgICAgICBhYm9ydChcIkZTLmFic29sdXRlUGF0aCBoYXMgYmVlbiByZW1vdmVkOyB1c2UgUEFUSF9GUy5yZXNvbHZlIGluc3RlYWRcIik7XFxuICAgICAgfSxcXG4gICAgICBjcmVhdGVGb2xkZXIoKSB7XFxuICAgICAgICBhYm9ydChcIkZTLmNyZWF0ZUZvbGRlciBoYXMgYmVlbiByZW1vdmVkOyB1c2UgRlMubWtkaXIgaW5zdGVhZFwiKTtcXG4gICAgICB9LFxcbiAgICAgIGNyZWF0ZUxpbmsoKSB7XFxuICAgICAgICBhYm9ydChcIkZTLmNyZWF0ZUxpbmsgaGFzIGJlZW4gcmVtb3ZlZDsgdXNlIEZTLnN5bWxpbmsgaW5zdGVhZFwiKTtcXG4gICAgICB9LFxcbiAgICAgIGpvaW5QYXRoKCkge1xcbiAgICAgICAgYWJvcnQoXCJGUy5qb2luUGF0aCBoYXMgYmVlbiByZW1vdmVkOyB1c2UgUEFUSC5qb2luIGluc3RlYWRcIik7XFxuICAgICAgfSxcXG4gICAgICBtbWFwQWxsb2MoKSB7XFxuICAgICAgICBhYm9ydChcXG4gICAgICAgICAgXCJGUy5tbWFwQWxsb2MgaGFzIGJlZW4gcmVwbGFjZWQgYnkgdGhlIHRvcCBsZXZlbCBmdW5jdGlvbiBtbWFwQWxsb2NcIixcXG4gICAgICAgICk7XFxuICAgICAgfSxcXG4gICAgICBzdGFuZGFyZGl6ZVBhdGgoKSB7XFxuICAgICAgICBhYm9ydChcXG4gICAgICAgICAgXCJGUy5zdGFuZGFyZGl6ZVBhdGggaGFzIGJlZW4gcmVtb3ZlZDsgdXNlIFBBVEgubm9ybWFsaXplIGluc3RlYWRcIixcXG4gICAgICAgICk7XFxuICAgICAgfSxcXG4gICAgfTtcXG4gICAgdmFyIFNZU0NBTExTID0ge1xcbiAgICAgIERFRkFVTFRfUE9MTE1BU0s6IDUsXFxuICAgICAgY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgsIGFsbG93RW1wdHkpIHtcXG4gICAgICAgIGlmIChQQVRILmlzQWJzKHBhdGgpKSB7XFxuICAgICAgICAgIHJldHVybiBwYXRoO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGRpcjtcXG4gICAgICAgIGlmIChkaXJmZCA9PT0gLTEwMCkge1xcbiAgICAgICAgICBkaXIgPSBGUy5jd2QoKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHZhciBkaXJzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZGlyZmQpO1xcbiAgICAgICAgICBkaXIgPSBkaXJzdHJlYW0ucGF0aDtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PSAwKSB7XFxuICAgICAgICAgIGlmICghYWxsb3dFbXB0eSkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXR1cm4gZGlyO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGRpciArIFwiL1wiICsgcGF0aDtcXG4gICAgICB9LFxcbiAgICAgIHdyaXRlU3RhdChidWYsIHN0YXQpIHtcXG4gICAgICAgIEhFQVAzMltidWYgLyA0XSA9IHN0YXQuZGV2O1xcbiAgICAgICAgSEVBUDMyWyhidWYgKyA0KSAvIDRdID0gc3RhdC5tb2RlO1xcbiAgICAgICAgSEVBUFU2NFsoYnVmICsgOCkgLyA4XSA9IEJpZ0ludChzdGF0Lm5saW5rKTtcXG4gICAgICAgIEhFQVAzMlsoYnVmICsgMTYpIC8gNF0gPSBzdGF0LnVpZDtcXG4gICAgICAgIEhFQVAzMlsoYnVmICsgMjApIC8gNF0gPSBzdGF0LmdpZDtcXG4gICAgICAgIEhFQVAzMlsoYnVmICsgMjQpIC8gNF0gPSBzdGF0LnJkZXY7XFxuICAgICAgICBIRUFQNjRbKGJ1ZiArIDMyKSAvIDhdID0gQmlnSW50KHN0YXQuc2l6ZSk7XFxuICAgICAgICBIRUFQMzJbKGJ1ZiArIDQwKSAvIDRdID0gNDA5NjtcXG4gICAgICAgIEhFQVAzMlsoYnVmICsgNDQpIC8gNF0gPSBzdGF0LmJsb2NrcztcXG4gICAgICAgIHZhciBhdGltZSA9IHN0YXQuYXRpbWUuZ2V0VGltZSgpO1xcbiAgICAgICAgdmFyIG10aW1lID0gc3RhdC5tdGltZS5nZXRUaW1lKCk7XFxuICAgICAgICB2YXIgY3RpbWUgPSBzdGF0LmN0aW1lLmdldFRpbWUoKTtcXG4gICAgICAgIEhFQVA2NFsoYnVmICsgNDgpIC8gOF0gPSBCaWdJbnQoTWF0aC5mbG9vcihhdGltZSAvIDFlMykpO1xcbiAgICAgICAgSEVBUFU2NFsoYnVmICsgNTYpIC8gOF0gPSBCaWdJbnQoKGF0aW1lICUgMWUzKSAqIDFlMyAqIDFlMyk7XFxuICAgICAgICBIRUFQNjRbKGJ1ZiArIDY0KSAvIDhdID0gQmlnSW50KE1hdGguZmxvb3IobXRpbWUgLyAxZTMpKTtcXG4gICAgICAgIEhFQVBVNjRbKGJ1ZiArIDcyKSAvIDhdID0gQmlnSW50KChtdGltZSAlIDFlMykgKiAxZTMgKiAxZTMpO1xcbiAgICAgICAgSEVBUDY0WyhidWYgKyA4MCkgLyA4XSA9IEJpZ0ludChNYXRoLmZsb29yKGN0aW1lIC8gMWUzKSk7XFxuICAgICAgICBIRUFQVTY0WyhidWYgKyA4OCkgLyA4XSA9IEJpZ0ludCgoY3RpbWUgJSAxZTMpICogMWUzICogMWUzKTtcXG4gICAgICAgIEhFQVA2NFsoYnVmICsgOTYpIC8gOF0gPSBCaWdJbnQoc3RhdC5pbm8pO1xcbiAgICAgICAgcmV0dXJuIDA7XFxuICAgICAgfSxcXG4gICAgICB3cml0ZVN0YXRGcyhidWYsIHN0YXRzKSB7XFxuICAgICAgICBIRUFQMzJbKGJ1ZiArIDgpIC8gNF0gPSBzdGF0cy5ic2l6ZTtcXG4gICAgICAgIEhFQVAzMlsoYnVmICsgNTYpIC8gNF0gPSBzdGF0cy5ic2l6ZTtcXG4gICAgICAgIEhFQVAzMlsoYnVmICsgMTYpIC8gNF0gPSBzdGF0cy5ibG9ja3M7XFxuICAgICAgICBIRUFQMzJbKGJ1ZiArIDIwKSAvIDRdID0gc3RhdHMuYmZyZWU7XFxuICAgICAgICBIRUFQMzJbKGJ1ZiArIDI0KSAvIDRdID0gc3RhdHMuYmF2YWlsO1xcbiAgICAgICAgSEVBUDMyWyhidWYgKyAyOCkgLyA0XSA9IHN0YXRzLmZpbGVzO1xcbiAgICAgICAgSEVBUDMyWyhidWYgKyAzMikgLyA0XSA9IHN0YXRzLmZmcmVlO1xcbiAgICAgICAgSEVBUDMyWyhidWYgKyAzNikgLyA0XSA9IHN0YXRzLmZzaWQ7XFxuICAgICAgICBIRUFQMzJbKGJ1ZiArIDY0KSAvIDRdID0gc3RhdHMuZmxhZ3M7XFxuICAgICAgICBIRUFQMzJbKGJ1ZiArIDQ4KSAvIDRdID0gc3RhdHMubmFtZWxlbjtcXG4gICAgICB9LFxcbiAgICAgIGRvTXN5bmMoYWRkciwgc3RyZWFtLCBsZW4sIGZsYWdzLCBvZmZzZXQpIHtcXG4gICAgICAgIGlmICghRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChmbGFncyAmIDIpIHtcXG4gICAgICAgICAgcmV0dXJuIDA7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgYnVmZmVyID0gSEVBUFU4LnNsaWNlKGFkZHIsIGFkZHIgKyBsZW4pO1xcbiAgICAgICAgRlMubXN5bmMoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuLCBmbGFncyk7XFxuICAgICAgfSxcXG4gICAgICBnZXRTdHJlYW1Gcm9tRkQoZmQpIHtcXG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW1DaGVja2VkKGZkKTtcXG4gICAgICAgIHJldHVybiBzdHJlYW07XFxuICAgICAgfSxcXG4gICAgICB2YXJhcmdzOiB1bmRlZmluZWQsXFxuICAgICAgZ2V0U3RyKHB0cikge1xcbiAgICAgICAgdmFyIHJldCA9IFVURjhUb1N0cmluZyhwdHIpO1xcbiAgICAgICAgcmV0dXJuIHJldDtcXG4gICAgICB9LFxcbiAgICB9O1xcbiAgICBmdW5jdGlvbiBfX19zeXNjYWxsX2ZjbnRsNjQoZmQsIGNtZCwgdmFyYXJncykge1xcbiAgICAgIHZhcmFyZ3MgPSBiaWdpbnRUb0k1M0NoZWNrZWQodmFyYXJncyk7XFxuICAgICAgU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xcbiAgICAgICAgc3dpdGNoIChjbWQpIHtcXG4gICAgICAgICAgY2FzZSAwOiB7XFxuICAgICAgICAgICAgdmFyIGFyZyA9IHN5c2NhbGxHZXRWYXJhcmdJKCk7XFxuICAgICAgICAgICAgaWYgKGFyZyA8IDApIHtcXG4gICAgICAgICAgICAgIHJldHVybiAtMjg7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHdoaWxlIChGUy5zdHJlYW1zW2FyZ10pIHtcXG4gICAgICAgICAgICAgIGFyZysrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB2YXIgbmV3U3RyZWFtO1xcbiAgICAgICAgICAgIG5ld1N0cmVhbSA9IEZTLmR1cFN0cmVhbShzdHJlYW0sIGFyZyk7XFxuICAgICAgICAgICAgcmV0dXJuIG5ld1N0cmVhbS5mZDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBjYXNlIDE6XFxuICAgICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgICByZXR1cm4gMDtcXG4gICAgICAgICAgY2FzZSAzOlxcbiAgICAgICAgICAgIHJldHVybiBzdHJlYW0uZmxhZ3M7XFxuICAgICAgICAgIGNhc2UgNDoge1xcbiAgICAgICAgICAgIHZhciBhcmcgPSBzeXNjYWxsR2V0VmFyYXJnSSgpO1xcbiAgICAgICAgICAgIHN0cmVhbS5mbGFncyB8PSBhcmc7XFxuICAgICAgICAgICAgcmV0dXJuIDA7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgY2FzZSA1OiB7XFxuICAgICAgICAgICAgdmFyIGFyZyA9IHN5c2NhbGxHZXRWYXJhcmdQKCk7XFxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XFxuICAgICAgICAgICAgSEVBUDE2WyhhcmcgKyBvZmZzZXQpIC8gMl0gPSAyO1xcbiAgICAgICAgICAgIHJldHVybiAwO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGNhc2UgNjpcXG4gICAgICAgICAgY2FzZSA3OlxcbiAgICAgICAgICAgIHJldHVybiAwO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIC0yODtcXG4gICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBpZiAodHlwZW9mIEZTID09IFwidW5kZWZpbmVkXCIgfHwgIShlLm5hbWUgPT09IFwiRXJybm9FcnJvclwiKSkgdGhyb3cgZTtcXG4gICAgICAgIHJldHVybiAtZS5lcnJubztcXG4gICAgICB9XFxuICAgIH1cXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF9mc3RhdDY0KGZkLCBidWYpIHtcXG4gICAgICBidWYgPSBiaWdpbnRUb0k1M0NoZWNrZWQoYnVmKTtcXG4gICAgICB0cnkge1xcbiAgICAgICAgcmV0dXJuIFNZU0NBTExTLndyaXRlU3RhdChidWYsIEZTLmZzdGF0KGZkKSk7XFxuICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSBcInVuZGVmaW5lZFwiIHx8ICEoZS5uYW1lID09PSBcIkVycm5vRXJyb3JcIikpIHRocm93IGU7XFxuICAgICAgICByZXR1cm4gLWUuZXJybm87XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfaW9jdGwoZmQsIG9wLCB2YXJhcmdzKSB7XFxuICAgICAgdmFyYXJncyA9IGJpZ2ludFRvSTUzQ2hlY2tlZCh2YXJhcmdzKTtcXG4gICAgICBTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJncztcXG4gICAgICB0cnkge1xcbiAgICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XFxuICAgICAgICBzd2l0Y2ggKG9wKSB7XFxuICAgICAgICAgIGNhc2UgMjE1MDk6IHtcXG4gICAgICAgICAgICBpZiAoIXN0cmVhbS50dHkpIHJldHVybiAtNTk7XFxuICAgICAgICAgICAgcmV0dXJuIDA7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgY2FzZSAyMTUwNToge1xcbiAgICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcXG4gICAgICAgICAgICBpZiAoc3RyZWFtLnR0eS5vcHMuaW9jdGxfdGNnZXRzKSB7XFxuICAgICAgICAgICAgICB2YXIgdGVybWlvcyA9IHN0cmVhbS50dHkub3BzLmlvY3RsX3RjZ2V0cyhzdHJlYW0pO1xcbiAgICAgICAgICAgICAgdmFyIGFyZ3AgPSBzeXNjYWxsR2V0VmFyYXJnUCgpO1xcbiAgICAgICAgICAgICAgSEVBUDMyW2FyZ3AgLyA0XSA9IHRlcm1pb3MuY19pZmxhZyB8fCAwO1xcbiAgICAgICAgICAgICAgSEVBUDMyWyhhcmdwICsgNCkgLyA0XSA9IHRlcm1pb3MuY19vZmxhZyB8fCAwO1xcbiAgICAgICAgICAgICAgSEVBUDMyWyhhcmdwICsgOCkgLyA0XSA9IHRlcm1pb3MuY19jZmxhZyB8fCAwO1xcbiAgICAgICAgICAgICAgSEVBUDMyWyhhcmdwICsgMTIpIC8gNF0gPSB0ZXJtaW9zLmNfbGZsYWcgfHwgMDtcXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xcbiAgICAgICAgICAgICAgICBIRUFQOFthcmdwICsgaSArIDE3XSA9IHRlcm1pb3MuY19jY1tpXSB8fCAwO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgcmV0dXJuIDA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiAwO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGNhc2UgMjE1MTA6XFxuICAgICAgICAgIGNhc2UgMjE1MTE6XFxuICAgICAgICAgIGNhc2UgMjE1MTI6IHtcXG4gICAgICAgICAgICBpZiAoIXN0cmVhbS50dHkpIHJldHVybiAtNTk7XFxuICAgICAgICAgICAgcmV0dXJuIDA7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgY2FzZSAyMTUwNjpcXG4gICAgICAgICAgY2FzZSAyMTUwNzpcXG4gICAgICAgICAgY2FzZSAyMTUwODoge1xcbiAgICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcXG4gICAgICAgICAgICBpZiAoc3RyZWFtLnR0eS5vcHMuaW9jdGxfdGNzZXRzKSB7XFxuICAgICAgICAgICAgICB2YXIgYXJncCA9IHN5c2NhbGxHZXRWYXJhcmdQKCk7XFxuICAgICAgICAgICAgICB2YXIgY19pZmxhZyA9IEhFQVAzMlthcmdwIC8gNF07XFxuICAgICAgICAgICAgICB2YXIgY19vZmxhZyA9IEhFQVAzMlsoYXJncCArIDQpIC8gNF07XFxuICAgICAgICAgICAgICB2YXIgY19jZmxhZyA9IEhFQVAzMlsoYXJncCArIDgpIC8gNF07XFxuICAgICAgICAgICAgICB2YXIgY19sZmxhZyA9IEhFQVAzMlsoYXJncCArIDEyKSAvIDRdO1xcbiAgICAgICAgICAgICAgdmFyIGNfY2MgPSBbXTtcXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xcbiAgICAgICAgICAgICAgICBjX2NjLnB1c2goSEVBUDhbYXJncCArIGkgKyAxN10pO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgcmV0dXJuIHN0cmVhbS50dHkub3BzLmlvY3RsX3Rjc2V0cyhzdHJlYW0udHR5LCBvcCwge1xcbiAgICAgICAgICAgICAgICBjX2lmbGFnLFxcbiAgICAgICAgICAgICAgICBjX29mbGFnLFxcbiAgICAgICAgICAgICAgICBjX2NmbGFnLFxcbiAgICAgICAgICAgICAgICBjX2xmbGFnLFxcbiAgICAgICAgICAgICAgICBjX2NjLFxcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiAwO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGNhc2UgMjE1MTk6IHtcXG4gICAgICAgICAgICBpZiAoIXN0cmVhbS50dHkpIHJldHVybiAtNTk7XFxuICAgICAgICAgICAgdmFyIGFyZ3AgPSBzeXNjYWxsR2V0VmFyYXJnUCgpO1xcbiAgICAgICAgICAgIEhFQVAzMlthcmdwIC8gNF0gPSAwO1xcbiAgICAgICAgICAgIHJldHVybiAwO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGNhc2UgMjE1MjA6IHtcXG4gICAgICAgICAgICBpZiAoIXN0cmVhbS50dHkpIHJldHVybiAtNTk7XFxuICAgICAgICAgICAgcmV0dXJuIC0yODtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBjYXNlIDIxNTMxOiB7XFxuICAgICAgICAgICAgdmFyIGFyZ3AgPSBzeXNjYWxsR2V0VmFyYXJnUCgpO1xcbiAgICAgICAgICAgIHJldHVybiBGUy5pb2N0bChzdHJlYW0sIG9wLCBhcmdwKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBjYXNlIDIxNTIzOiB7XFxuICAgICAgICAgICAgaWYgKCFzdHJlYW0udHR5KSByZXR1cm4gLTU5O1xcbiAgICAgICAgICAgIGlmIChzdHJlYW0udHR5Lm9wcy5pb2N0bF90aW9jZ3dpbnN6KSB7XFxuICAgICAgICAgICAgICB2YXIgd2luc2l6ZSA9IHN0cmVhbS50dHkub3BzLmlvY3RsX3Rpb2Nnd2luc3ooc3RyZWFtLnR0eSk7XFxuICAgICAgICAgICAgICB2YXIgYXJncCA9IHN5c2NhbGxHZXRWYXJhcmdQKCk7XFxuICAgICAgICAgICAgICBIRUFQMTZbYXJncCAvIDJdID0gd2luc2l6ZVswXTtcXG4gICAgICAgICAgICAgIEhFQVAxNlsoYXJncCArIDIpIC8gMl0gPSB3aW5zaXplWzFdO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gMDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBjYXNlIDIxNTI0OiB7XFxuICAgICAgICAgICAgaWYgKCFzdHJlYW0udHR5KSByZXR1cm4gLTU5O1xcbiAgICAgICAgICAgIHJldHVybiAwO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGNhc2UgMjE1MTU6IHtcXG4gICAgICAgICAgICBpZiAoIXN0cmVhbS50dHkpIHJldHVybiAtNTk7XFxuICAgICAgICAgICAgcmV0dXJuIDA7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICByZXR1cm4gLTI4O1xcbiAgICAgICAgfVxcbiAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gXCJ1bmRlZmluZWRcIiB8fCAhKGUubmFtZSA9PT0gXCJFcnJub0Vycm9yXCIpKSB0aHJvdyBlO1xcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBmdW5jdGlvbiBfX19zeXNjYWxsX29wZW5hdChkaXJmZCwgcGF0aCwgZmxhZ3MsIHZhcmFyZ3MpIHtcXG4gICAgICBwYXRoID0gYmlnaW50VG9JNTNDaGVja2VkKHBhdGgpO1xcbiAgICAgIHZhcmFyZ3MgPSBiaWdpbnRUb0k1M0NoZWNrZWQodmFyYXJncyk7XFxuICAgICAgU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XFxuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgpO1xcbiAgICAgICAgdmFyIG1vZGUgPSB2YXJhcmdzID8gc3lzY2FsbEdldFZhcmFyZ0koKSA6IDA7XFxuICAgICAgICByZXR1cm4gRlMub3BlbihwYXRoLCBmbGFncywgbW9kZSkuZmQ7XFxuICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSBcInVuZGVmaW5lZFwiIHx8ICEoZS5uYW1lID09PSBcIkVycm5vRXJyb3JcIikpIHRocm93IGU7XFxuICAgICAgICByZXR1cm4gLWUuZXJybm87XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHZhciBfX2Fib3J0X2pzID0gKCkgPT4gYWJvcnQoXCJuYXRpdmUgY29kZSBjYWxsZWQgYWJvcnQoKVwiKTtcXG4gICAgdmFyIHJ1bnRpbWVLZWVwYWxpdmVDb3VudGVyID0gMDtcXG4gICAgdmFyIF9fZW1zY3JpcHRlbl9ydW50aW1lX2tlZXBhbGl2ZV9jbGVhciA9ICgpID0+IHtcXG4gICAgICBub0V4aXRSdW50aW1lID0gZmFsc2U7XFxuICAgICAgcnVudGltZUtlZXBhbGl2ZUNvdW50ZXIgPSAwO1xcbiAgICB9O1xcbiAgICBmdW5jdGlvbiBfX21tYXBfanMobGVuLCBwcm90LCBmbGFncywgZmQsIG9mZnNldCwgYWxsb2NhdGVkLCBhZGRyKSB7XFxuICAgICAgbGVuID0gYmlnaW50VG9JNTNDaGVja2VkKGxlbik7XFxuICAgICAgb2Zmc2V0ID0gYmlnaW50VG9JNTNDaGVja2VkKG9mZnNldCk7XFxuICAgICAgYWxsb2NhdGVkID0gYmlnaW50VG9JNTNDaGVja2VkKGFsbG9jYXRlZCk7XFxuICAgICAgYWRkciA9IGJpZ2ludFRvSTUzQ2hlY2tlZChhZGRyKTtcXG4gICAgICB0cnkge1xcbiAgICAgICAgaWYgKGlzTmFOKG9mZnNldCkpIHJldHVybiA2MTtcXG4gICAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xcbiAgICAgICAgdmFyIHJlcyA9IEZTLm1tYXAoc3RyZWFtLCBsZW4sIG9mZnNldCwgcHJvdCwgZmxhZ3MpO1xcbiAgICAgICAgdmFyIHB0ciA9IHJlcy5wdHI7XFxuICAgICAgICBIRUFQMzJbYWxsb2NhdGVkIC8gNF0gPSByZXMuYWxsb2NhdGVkO1xcbiAgICAgICAgSEVBUFU2NFthZGRyIC8gOF0gPSBCaWdJbnQocHRyKTtcXG4gICAgICAgIHJldHVybiAwO1xcbiAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gXCJ1bmRlZmluZWRcIiB8fCAhKGUubmFtZSA9PT0gXCJFcnJub0Vycm9yXCIpKSB0aHJvdyBlO1xcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBmdW5jdGlvbiBfX211bm1hcF9qcyhhZGRyLCBsZW4sIHByb3QsIGZsYWdzLCBmZCwgb2Zmc2V0KSB7XFxuICAgICAgYWRkciA9IGJpZ2ludFRvSTUzQ2hlY2tlZChhZGRyKTtcXG4gICAgICBsZW4gPSBiaWdpbnRUb0k1M0NoZWNrZWQobGVuKTtcXG4gICAgICBvZmZzZXQgPSBiaWdpbnRUb0k1M0NoZWNrZWQob2Zmc2V0KTtcXG4gICAgICB0cnkge1xcbiAgICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XFxuICAgICAgICBpZiAocHJvdCAmIDIpIHtcXG4gICAgICAgICAgU1lTQ0FMTFMuZG9Nc3luYyhhZGRyLCBzdHJlYW0sIGxlbiwgZmxhZ3MsIG9mZnNldCk7XFxuICAgICAgICB9XFxuICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSBcInVuZGVmaW5lZFwiIHx8ICEoZS5uYW1lID09PSBcIkVycm5vRXJyb3JcIikpIHRocm93IGU7XFxuICAgICAgICByZXR1cm4gLWUuZXJybm87XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHZhciB0aW1lcnMgPSB7fTtcXG4gICAgdmFyIGhhbmRsZUV4Y2VwdGlvbiA9IChlKSA9PiB7XFxuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFeGl0U3RhdHVzIHx8IGUgPT0gXCJ1bndpbmRcIikge1xcbiAgICAgICAgcmV0dXJuIEVYSVRTVEFUVVM7XFxuICAgICAgfVxcbiAgICAgIGNoZWNrU3RhY2tDb29raWUoKTtcXG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcikge1xcbiAgICAgICAgaWYgKF9lbXNjcmlwdGVuX3N0YWNrX2dldF9jdXJyZW50KCkgPD0gMCkge1xcbiAgICAgICAgICBlcnIoXFxuICAgICAgICAgICAgXCJTdGFjayBvdmVyZmxvdyBkZXRlY3RlZC4gIFlvdSBjYW4gdHJ5IGluY3JlYXNpbmcgLXNTVEFDS19TSVpFIChjdXJyZW50bHkgc2V0IHRvIDY1NTM2KVwiLFxcbiAgICAgICAgICApO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBxdWl0XygxLCBlKTtcXG4gICAgfTtcXG4gICAgdmFyIGtlZXBSdW50aW1lQWxpdmUgPSAoKSA9PiBub0V4aXRSdW50aW1lIHx8IHJ1bnRpbWVLZWVwYWxpdmVDb3VudGVyID4gMDtcXG4gICAgdmFyIF9wcm9jX2V4aXQgPSAoY29kZSkgPT4ge1xcbiAgICAgIEVYSVRTVEFUVVMgPSBjb2RlO1xcbiAgICAgIGlmICgha2VlcFJ1bnRpbWVBbGl2ZSgpKSB7XFxuICAgICAgICBNb2R1bGVbXCJvbkV4aXRcIl0/Lihjb2RlKTtcXG4gICAgICAgIEFCT1JUID0gdHJ1ZTtcXG4gICAgICB9XFxuICAgICAgcXVpdF8oY29kZSwgbmV3IEV4aXRTdGF0dXMoY29kZSkpO1xcbiAgICB9O1xcbiAgICB2YXIgZXhpdEpTID0gKHN0YXR1c3csIGltcGxpY2l0KSA9PiB7XFxuICAgICAgRVhJVFNUQVRVUyA9IHN0YXR1c3c7XFxuICAgICAgY2hlY2tVbmZsdXNoZWRDb250ZW50KCk7XFxuICAgICAgaWYgKGtlZXBSdW50aW1lQWxpdmUoKSAmJiAhaW1wbGljaXQpIHtcXG5cXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKXtcXG4gICAgICAgICAgaW5zdHJ1Y3Rpb25zW2ldLl9yb3dWYXJpYW50ID0gXFwnXFwnO1xcbiAgICAgICAgfVxcbiAgICAgICAgc3RhdHVzLnJ1bl9wcm9ncmFtID0gLTE7IC8vIHByb2dyYW0gZmluaXNoZWRcXG4gICAgICAgIGlmIChzdGF0dXN3ICE9PSAwKXtcXG4gICAgICAgICAgcmVzZXRfZGlzYWJsZS52YWx1ZSA9IGZhbHNlO1xcbiAgICAgICAgICBpbnN0cnVjdGlvbl9kaXNhYmxlLnZhbHVlID0gdHJ1ZTtcXG4gICAgICAgICAgcnVuX2Rpc2FibGUudmFsdWUgPSB0cnVlO1xcbiAgICAgICAgICBzdG9wX2Rpc2FibGUudmFsdWUgPSBmYWxzZTtcXG4gICAgICAgICAgc2hvd19ub3RpZmljYXRpb24oXCJZb3VyIHByb2dyYW0gaGFzIGZpbmlzaGVkIHdpdGggZXJyb3JzLlwiLCBcImRhbmdlclwiKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJlc2V0X2Rpc2FibGUudmFsdWUgPSBmYWxzZTtcXG4gICAgICAgICAgaW5zdHJ1Y3Rpb25fZGlzYWJsZS52YWx1ZSA9IGZhbHNlO1xcbiAgICAgICAgICBydW5fZGlzYWJsZS52YWx1ZSA9IGZhbHNlO1xcbiAgICAgICAgICBzdG9wX2Rpc2FibGUudmFsdWUgPSB0cnVlO1xcbiAgICAgICAgICBpc0ZpbmlzaGVkLnZhbHVlID0gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBtc2cgPSBgcHJvZ3JhbSBleGl0ZWQgKHdpdGggc3RhdHVzOiAke3N0YXR1c3d9KSwgYnV0IGtlZXBSdW50aW1lQWxpdmUoKSBpcyBzZXQgKGNvdW50ZXI9JHtydW50aW1lS2VlcGFsaXZlQ291bnRlcn0pIGR1ZSB0byBhbiBhc3luYyBvcGVyYXRpb24sIHNvIGhhbHRpbmcgZXhlY3V0aW9uIGJ1dCBub3QgZXhpdGluZyB0aGUgcnVudGltZSBvciBwcmV2ZW50aW5nIGZ1cnRoZXIgYXN5bmMgZXhlY3V0aW9uICh5b3UgY2FuIHVzZSBlbXNjcmlwdGVuX2ZvcmNlX2V4aXQsIGlmIHlvdSB3YW50IHRvIGZvcmNlIGEgdHJ1ZSBzaHV0ZG93bilgO1xcbiAgICAgICAgcmVhZHlQcm9taXNlUmVqZWN0KG1zZyk7XFxuICAgICAgICBlcnIobXNnKTtcXG4gICAgICB9XFxuICAgICAgX3Byb2NfZXhpdChzdGF0dXN3KTtcXG4gICAgfTtcXG4gICAgdmFyIF9leGl0ID0gZXhpdEpTO1xcbiAgICB2YXIgbWF5YmVFeGl0ID0gKCkgPT4ge1xcbiAgICAgIGlmICgha2VlcFJ1bnRpbWVBbGl2ZSgpKSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICBfZXhpdChFWElUU1RBVFVTKTtcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgaGFuZGxlRXhjZXB0aW9uKGUpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfTtcXG4gICAgdmFyIGNhbGxVc2VyQ2FsbGJhY2sgPSAoZnVuYykgPT4ge1xcbiAgICAgIGlmIChBQk9SVCkge1xcbiAgICAgICAgZXJyKFxcbiAgICAgICAgICBcInVzZXIgY2FsbGJhY2sgdHJpZ2dlcmVkIGFmdGVyIHJ1bnRpbWUgZXhpdGVkIG9yIGFwcGxpY2F0aW9uIGFib3J0ZWQuICBJZ25vcmluZy5cIixcXG4gICAgICAgICk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICAgIHRyeSB7XFxuICAgICAgICBmdW5jKCk7XFxuICAgICAgICBtYXliZUV4aXQoKTtcXG4gICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBoYW5kbGVFeGNlcHRpb24oZSk7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgICB2YXIgX2Vtc2NyaXB0ZW5fZ2V0X25vdyA9ICgpID0+IHBlcmZvcm1hbmNlLm5vdygpO1xcbiAgICB2YXIgX19zZXRpdGltZXJfanMgPSAod2hpY2gsIHRpbWVvdXRfbXMpID0+IHtcXG4gICAgICBpZiAodGltZXJzW3doaWNoXSkge1xcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyc1t3aGljaF0uaWQpO1xcbiAgICAgICAgZGVsZXRlIHRpbWVyc1t3aGljaF07XFxuICAgICAgfVxcbiAgICAgIGlmICghdGltZW91dF9tcykgcmV0dXJuIDA7XFxuICAgICAgdmFyIGlkID0gc2V0VGltZW91dCgoKSA9PiB7XFxuICAgICAgICBhc3NlcnQod2hpY2ggaW4gdGltZXJzKTtcXG4gICAgICAgIGRlbGV0ZSB0aW1lcnNbd2hpY2hdO1xcbiAgICAgICAgY2FsbFVzZXJDYWxsYmFjaygoKSA9PlxcbiAgICAgICAgICBfX2Vtc2NyaXB0ZW5fdGltZW91dCh3aGljaCwgX2Vtc2NyaXB0ZW5fZ2V0X25vdygpKSxcXG4gICAgICAgICk7XFxuICAgICAgfSwgdGltZW91dF9tcyk7XFxuICAgICAgdGltZXJzW3doaWNoXSA9IHsgaWQsIHRpbWVvdXRfbXMgfTtcXG4gICAgICByZXR1cm4gMDtcXG4gICAgfTtcXG4gICAgdmFyIF9lbXNjcmlwdGVuX3NldF9tYWluX2xvb3BfdGltaW5nID0gKG1vZGUsIHZhbHVlKSA9PiB7XFxuICAgICAgTWFpbkxvb3AudGltaW5nTW9kZSA9IG1vZGU7XFxuICAgICAgTWFpbkxvb3AudGltaW5nVmFsdWUgPSB2YWx1ZTtcXG4gICAgICBpZiAoIU1haW5Mb29wLmZ1bmMpIHtcXG4gICAgICAgIGVycihcXG4gICAgICAgICAgXCJlbXNjcmlwdGVuX3NldF9tYWluX2xvb3BfdGltaW5nOiBDYW5ub3Qgc2V0IHRpbWluZyBtb2RlIGZvciBtYWluIGxvb3Agc2luY2UgYSBtYWluIGxvb3AgZG9lcyBub3QgZXhpc3QhIENhbGwgZW1zY3JpcHRlbl9zZXRfbWFpbl9sb29wIGZpcnN0IHRvIHNldCBvbmUgdXAuXCIsXFxuICAgICAgICApO1xcbiAgICAgICAgcmV0dXJuIDE7XFxuICAgICAgfVxcbiAgICAgIGlmICghTWFpbkxvb3AucnVubmluZykge1xcbiAgICAgICAgTWFpbkxvb3AucnVubmluZyA9IHRydWU7XFxuICAgICAgfVxcbiAgICAgIGlmIChtb2RlID09IDApIHtcXG4gICAgICAgIE1haW5Mb29wLnNjaGVkdWxlciA9IGZ1bmN0aW9uIE1haW5Mb29wX3NjaGVkdWxlcl9zZXRUaW1lb3V0KCkge1xcbiAgICAgICAgICB2YXIgdGltZVVudGlsTmV4dFRpY2sgPVxcbiAgICAgICAgICAgIE1hdGgubWF4KFxcbiAgICAgICAgICAgICAgMCxcXG4gICAgICAgICAgICAgIE1haW5Mb29wLnRpY2tTdGFydFRpbWUgKyB2YWx1ZSAtIF9lbXNjcmlwdGVuX2dldF9ub3coKSxcXG4gICAgICAgICAgICApIHwgMDtcXG4gICAgICAgICAgc2V0VGltZW91dChNYWluTG9vcC5ydW5uZXIsIHRpbWVVbnRpbE5leHRUaWNrKTtcXG4gICAgICAgIH07XFxuICAgICAgICBNYWluTG9vcC5tZXRob2QgPSBcInRpbWVvdXRcIjtcXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT0gMSkge1xcbiAgICAgICAgTWFpbkxvb3Auc2NoZWR1bGVyID0gZnVuY3Rpb24gTWFpbkxvb3Bfc2NoZWR1bGVyX3JBRigpIHtcXG4gICAgICAgICAgTWFpbkxvb3AucmVxdWVzdEFuaW1hdGlvbkZyYW1lKE1haW5Mb29wLnJ1bm5lcik7XFxuICAgICAgICB9O1xcbiAgICAgICAgTWFpbkxvb3AubWV0aG9kID0gXCJyQUZcIjtcXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT0gMikge1xcbiAgICAgICAgaWYgKHR5cGVvZiBNYWluTG9vcC5zZXRJbW1lZGlhdGUgPT0gXCJ1bmRlZmluZWRcIikge1xcbiAgICAgICAgICBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PSBcInVuZGVmaW5lZFwiKSB7XFxuICAgICAgICAgICAgdmFyIHNldEltbWVkaWF0ZXMgPSBbXTtcXG4gICAgICAgICAgICB2YXIgZW1zY3JpcHRlbk1haW5Mb29wTWVzc2FnZUlkID0gXCJzZXRpbW1lZGlhdGVcIjtcXG4gICAgICAgICAgICB2YXIgTWFpbkxvb3Bfc2V0SW1tZWRpYXRlX21lc3NhZ2VIYW5kbGVyID0gKGV2ZW50KSA9PiB7XFxuICAgICAgICAgICAgICBpZiAoXFxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEgPT09IGVtc2NyaXB0ZW5NYWluTG9vcE1lc3NhZ2VJZCB8fFxcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLnRhcmdldCA9PT0gZW1zY3JpcHRlbk1haW5Mb29wTWVzc2FnZUlkXFxuICAgICAgICAgICAgICApIHtcXG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XFxuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZXMuc2hpZnQoKSgpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihcXG4gICAgICAgICAgICAgIFwibWVzc2FnZVwiLFxcbiAgICAgICAgICAgICAgTWFpbkxvb3Bfc2V0SW1tZWRpYXRlX21lc3NhZ2VIYW5kbGVyLFxcbiAgICAgICAgICAgICAgdHJ1ZSxcXG4gICAgICAgICAgICApO1xcbiAgICAgICAgICAgIE1haW5Mb29wLnNldEltbWVkaWF0ZSA9IChmdW5jKSA9PiB7XFxuICAgICAgICAgICAgICBzZXRJbW1lZGlhdGVzLnB1c2goZnVuYyk7XFxuICAgICAgICAgICAgICBpZiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XFxuICAgICAgICAgICAgICAgIE1vZHVsZVtcInNldEltbWVkaWF0ZXNcIl0gPz89IFtdO1xcbiAgICAgICAgICAgICAgICBNb2R1bGVbXCJzZXRJbW1lZGlhdGVzXCJdLnB1c2goZnVuYyk7XFxuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdGFyZ2V0OiBlbXNjcmlwdGVuTWFpbkxvb3BNZXNzYWdlSWQgfSk7XFxuICAgICAgICAgICAgICB9IGVsc2UgcG9zdE1lc3NhZ2UoZW1zY3JpcHRlbk1haW5Mb29wTWVzc2FnZUlkLCBcIipcIik7XFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBNYWluTG9vcC5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIE1haW5Mb29wLnNjaGVkdWxlciA9IGZ1bmN0aW9uIE1haW5Mb29wX3NjaGVkdWxlcl9zZXRJbW1lZGlhdGUoKSB7XFxuICAgICAgICAgIE1haW5Mb29wLnNldEltbWVkaWF0ZShNYWluTG9vcC5ydW5uZXIpO1xcbiAgICAgICAgfTtcXG4gICAgICAgIE1haW5Mb29wLm1ldGhvZCA9IFwiaW1tZWRpYXRlXCI7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiAwO1xcbiAgICB9O1xcbiAgICB2YXIgc2V0TWFpbkxvb3AgPSAoXFxuICAgICAgaXRlckZ1bmMsXFxuICAgICAgZnBzLFxcbiAgICAgIHNpbXVsYXRlSW5maW5pdGVMb29wLFxcbiAgICAgIGFyZyxcXG4gICAgICBub1NldFRpbWluZyxcXG4gICAgKSA9PiB7XFxuICAgICAgYXNzZXJ0KFxcbiAgICAgICAgIU1haW5Mb29wLmZ1bmMsXFxuICAgICAgICBcImVtc2NyaXB0ZW5fc2V0X21haW5fbG9vcDogdGhlcmUgY2FuIG9ubHkgYmUgb25lIG1haW4gbG9vcCBmdW5jdGlvbiBhdCBvbmNlOiBjYWxsIGVtc2NyaXB0ZW5fY2FuY2VsX21haW5fbG9vcCB0byBjYW5jZWwgdGhlIHByZXZpb3VzIG9uZSBiZWZvcmUgc2V0dGluZyBhIG5ldyBvbmUgd2l0aCBkaWZmZXJlbnQgcGFyYW1ldGVycy5cIixcXG4gICAgICApO1xcbiAgICAgIE1haW5Mb29wLmZ1bmMgPSBpdGVyRnVuYztcXG4gICAgICBNYWluTG9vcC5hcmcgPSBhcmc7XFxuICAgICAgdmFyIHRoaXNNYWluTG9vcElkID0gTWFpbkxvb3AuY3VycmVudGx5UnVubmluZ01haW5sb29wO1xcbiAgICAgIGZ1bmN0aW9uIGNoZWNrSXNSdW5uaW5nKCkge1xcbiAgICAgICAgaWYgKHRoaXNNYWluTG9vcElkIDwgTWFpbkxvb3AuY3VycmVudGx5UnVubmluZ01haW5sb29wKSB7XFxuICAgICAgICAgIG1heWJlRXhpdCgpO1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuICAgICAgTWFpbkxvb3AucnVubmluZyA9IGZhbHNlO1xcbiAgICAgIE1haW5Mb29wLnJ1bm5lciA9IGZ1bmN0aW9uIE1haW5Mb29wX3J1bm5lcigpIHtcXG4gICAgICAgIGlmIChBQk9SVCkgcmV0dXJuO1xcbiAgICAgICAgaWYgKE1haW5Mb29wLnF1ZXVlLmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKTtcXG4gICAgICAgICAgdmFyIGJsb2NrZXIgPSBNYWluTG9vcC5xdWV1ZS5zaGlmdCgpO1xcbiAgICAgICAgICBibG9ja2VyLmZ1bmMoYmxvY2tlci5hcmcpO1xcbiAgICAgICAgICBpZiAoTWFpbkxvb3AucmVtYWluaW5nQmxvY2tlcnMpIHtcXG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gTWFpbkxvb3AucmVtYWluaW5nQmxvY2tlcnM7XFxuICAgICAgICAgICAgdmFyIG5leHQgPVxcbiAgICAgICAgICAgICAgcmVtYWluaW5nICUgMSA9PSAwID8gcmVtYWluaW5nIC0gMSA6IE1hdGguZmxvb3IocmVtYWluaW5nKTtcXG4gICAgICAgICAgICBpZiAoYmxvY2tlci5jb3VudGVkKSB7XFxuICAgICAgICAgICAgICBNYWluTG9vcC5yZW1haW5pbmdCbG9ja2VycyA9IG5leHQ7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIG5leHQgPSBuZXh0ICsgMC41O1xcbiAgICAgICAgICAgICAgTWFpbkxvb3AucmVtYWluaW5nQmxvY2tlcnMgPSAoOCAqIHJlbWFpbmluZyArIG5leHQpIC8gOTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgTWFpbkxvb3AudXBkYXRlU3RhdHVzKCk7XFxuICAgICAgICAgIGlmICghY2hlY2tJc1J1bm5pbmcoKSkgcmV0dXJuO1xcbiAgICAgICAgICBzZXRUaW1lb3V0KE1haW5Mb29wLnJ1bm5lciwgMCk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghY2hlY2tJc1J1bm5pbmcoKSkgcmV0dXJuO1xcbiAgICAgICAgTWFpbkxvb3AuY3VycmVudEZyYW1lTnVtYmVyID0gKE1haW5Mb29wLmN1cnJlbnRGcmFtZU51bWJlciArIDEpIHwgMDtcXG4gICAgICAgIGlmIChcXG4gICAgICAgICAgTWFpbkxvb3AudGltaW5nTW9kZSA9PSAxICYmXFxuICAgICAgICAgIE1haW5Mb29wLnRpbWluZ1ZhbHVlID4gMSAmJlxcbiAgICAgICAgICBNYWluTG9vcC5jdXJyZW50RnJhbWVOdW1iZXIgJSBNYWluTG9vcC50aW1pbmdWYWx1ZSAhPSAwXFxuICAgICAgICApIHtcXG4gICAgICAgICAgTWFpbkxvb3Auc2NoZWR1bGVyKCk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH0gZWxzZSBpZiAoTWFpbkxvb3AudGltaW5nTW9kZSA9PSAwKSB7XFxuICAgICAgICAgIE1haW5Mb29wLnRpY2tTdGFydFRpbWUgPSBfZW1zY3JpcHRlbl9nZXRfbm93KCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoTWFpbkxvb3AubWV0aG9kID09PSBcInRpbWVvdXRcIiAmJiBNb2R1bGVbXCJjdHhcIl0pIHtcXG4gICAgICAgICAgd2Fybk9uY2UoXFxuICAgICAgICAgICAgXCJMb29rcyBsaWtlIHlvdSBhcmUgcmVuZGVyaW5nIHdpdGhvdXQgdXNpbmcgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGZvciB0aGUgbWFpbiBsb29wLiBZb3Ugc2hvdWxkIHVzZSAwIGZvciB0aGUgZnJhbWUgcmF0ZSBpbiBlbXNjcmlwdGVuX3NldF9tYWluX2xvb3AgaW4gb3JkZXIgdG8gdXNlIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgYXMgdGhhdCBjYW4gZ3JlYXRseSBpbXByb3ZlIHlvdXIgZnJhbWUgcmF0ZXMhXCIsXFxuICAgICAgICAgICk7XFxuICAgICAgICAgIE1haW5Mb29wLm1ldGhvZCA9IFwiXCI7XFxuICAgICAgICB9XFxuICAgICAgICBNYWluTG9vcC5ydW5JdGVyKGl0ZXJGdW5jKTtcXG4gICAgICAgIGlmICghY2hlY2tJc1J1bm5pbmcoKSkgcmV0dXJuO1xcbiAgICAgICAgTWFpbkxvb3Auc2NoZWR1bGVyKCk7XFxuICAgICAgfTtcXG4gICAgICBpZiAoIW5vU2V0VGltaW5nKSB7XFxuICAgICAgICBpZiAoZnBzID4gMCkge1xcbiAgICAgICAgICBfZW1zY3JpcHRlbl9zZXRfbWFpbl9sb29wX3RpbWluZygwLCAxZTMgLyBmcHMpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgX2Vtc2NyaXB0ZW5fc2V0X21haW5fbG9vcF90aW1pbmcoMSwgMSk7XFxuICAgICAgICB9XFxuICAgICAgICBNYWluTG9vcC5zY2hlZHVsZXIoKTtcXG4gICAgICB9XFxuICAgICAgaWYgKHNpbXVsYXRlSW5maW5pdGVMb29wKSB7XFxuICAgICAgICB0aHJvdyBcInVud2luZFwiO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gICAgdmFyIE1haW5Mb29wID0ge1xcbiAgICAgIHJ1bm5pbmc6IGZhbHNlLFxcbiAgICAgIHNjaGVkdWxlcjogbnVsbCxcXG4gICAgICBtZXRob2Q6IFwiXCIsXFxuICAgICAgY3VycmVudGx5UnVubmluZ01haW5sb29wOiAwLFxcbiAgICAgIGZ1bmM6IG51bGwsXFxuICAgICAgYXJnOiAwLFxcbiAgICAgIHRpbWluZ01vZGU6IDAsXFxuICAgICAgdGltaW5nVmFsdWU6IDAsXFxuICAgICAgY3VycmVudEZyYW1lTnVtYmVyOiAwLFxcbiAgICAgIHF1ZXVlOiBbXSxcXG4gICAgICBwcmVNYWluTG9vcDogW10sXFxuICAgICAgcG9zdE1haW5Mb29wOiBbXSxcXG4gICAgICBwYXVzZSgpIHtcXG4gICAgICAgIE1haW5Mb29wLnNjaGVkdWxlciA9IG51bGw7XFxuICAgICAgICBNYWluTG9vcC5jdXJyZW50bHlSdW5uaW5nTWFpbmxvb3ArKztcXG4gICAgICB9LFxcbiAgICAgIHJlc3VtZSgpIHtcXG4gICAgICAgIE1haW5Mb29wLmN1cnJlbnRseVJ1bm5pbmdNYWlubG9vcCsrO1xcbiAgICAgICAgdmFyIHRpbWluZ01vZGUgPSBNYWluTG9vcC50aW1pbmdNb2RlO1xcbiAgICAgICAgdmFyIHRpbWluZ1ZhbHVlID0gTWFpbkxvb3AudGltaW5nVmFsdWU7XFxuICAgICAgICB2YXIgZnVuYyA9IE1haW5Mb29wLmZ1bmM7XFxuICAgICAgICBNYWluTG9vcC5mdW5jID0gbnVsbDtcXG4gICAgICAgIHNldE1haW5Mb29wKGZ1bmMsIDAsIGZhbHNlLCBNYWluTG9vcC5hcmcsIHRydWUpO1xcbiAgICAgICAgX2Vtc2NyaXB0ZW5fc2V0X21haW5fbG9vcF90aW1pbmcodGltaW5nTW9kZSwgdGltaW5nVmFsdWUpO1xcbiAgICAgICAgTWFpbkxvb3Auc2NoZWR1bGVyKCk7XFxuICAgICAgfSxcXG4gICAgICB1cGRhdGVTdGF0dXMoKSB7XFxuICAgICAgICBpZiAoTW9kdWxlW1wic2V0U3RhdHVzXCJdKSB7XFxuICAgICAgICAgIHZhciBtZXNzYWdlID0gTW9kdWxlW1wic3RhdHVzTWVzc2FnZVwiXSB8fCBcIlBsZWFzZSB3YWl0Li4uXCI7XFxuICAgICAgICAgIHZhciByZW1haW5pbmcgPSBNYWluTG9vcC5yZW1haW5pbmdCbG9ja2VycyA/PyAwO1xcbiAgICAgICAgICB2YXIgZXhwZWN0ZWQgPSBNYWluTG9vcC5leHBlY3RlZEJsb2NrZXJzID8/IDA7XFxuICAgICAgICAgIGlmIChyZW1haW5pbmcpIHtcXG4gICAgICAgICAgICBpZiAocmVtYWluaW5nIDwgZXhwZWN0ZWQpIHtcXG4gICAgICAgICAgICAgIE1vZHVsZVtcInNldFN0YXR1c1wiXShcXG4gICAgICAgICAgICAgICAgYHttZXNzYWdlfSAoe2V4cGVjdGVkIC0gcmVtYWluaW5nfS97ZXhwZWN0ZWR9KWAsXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBNb2R1bGVbXCJzZXRTdGF0dXNcIl0obWVzc2FnZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIE1vZHVsZVtcInNldFN0YXR1c1wiXShcIlwiKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgaW5pdCgpIHtcXG4gICAgICAgIE1vZHVsZVtcInByZU1haW5Mb29wXCJdICYmXFxuICAgICAgICAgIE1haW5Mb29wLnByZU1haW5Mb29wLnB1c2goTW9kdWxlW1wicHJlTWFpbkxvb3BcIl0pO1xcbiAgICAgICAgTW9kdWxlW1wicG9zdE1haW5Mb29wXCJdICYmXFxuICAgICAgICAgIE1haW5Mb29wLnBvc3RNYWluTG9vcC5wdXNoKE1vZHVsZVtcInBvc3RNYWluTG9vcFwiXSk7XFxuICAgICAgfSxcXG4gICAgICBydW5JdGVyKGZ1bmMpIHtcXG4gICAgICAgIGlmIChBQk9SVCkgcmV0dXJuO1xcbiAgICAgICAgZm9yICh2YXIgcHJlIG9mIE1haW5Mb29wLnByZU1haW5Mb29wKSB7XFxuICAgICAgICAgIGlmIChwcmUoKSA9PT0gZmFsc2UpIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGNhbGxVc2VyQ2FsbGJhY2soZnVuYyk7XFxuICAgICAgICBmb3IgKHZhciBwb3N0IG9mIE1haW5Mb29wLnBvc3RNYWluTG9vcCkge1xcbiAgICAgICAgICBwb3N0KCk7XFxuICAgICAgICB9XFxuICAgICAgICBjaGVja1N0YWNrQ29va2llKCk7XFxuICAgICAgfSxcXG4gICAgICBuZXh0UkFGOiAwLFxcbiAgICAgIGZha2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuYykge1xcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XFxuICAgICAgICBpZiAoTWFpbkxvb3AubmV4dFJBRiA9PT0gMCkge1xcbiAgICAgICAgICBNYWluTG9vcC5uZXh0UkFGID0gbm93ICsgMWUzIC8gNjA7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB3aGlsZSAobm93ICsgMiA+PSBNYWluTG9vcC5uZXh0UkFGKSB7XFxuICAgICAgICAgICAgTWFpbkxvb3AubmV4dFJBRiArPSAxZTMgLyA2MDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGRlbGF5ID0gTWF0aC5tYXgoTWFpbkxvb3AubmV4dFJBRiAtIG5vdywgMCk7XFxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmMsIGRlbGF5KTtcXG4gICAgICB9LFxcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jKSB7XFxuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PSBcImZ1bmN0aW9uXCIpIHtcXG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmMpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgUkFGID0gTWFpbkxvb3AuZmFrZVJlcXVlc3RBbmltYXRpb25GcmFtZTtcXG4gICAgICAgIFJBRihmdW5jKTtcXG4gICAgICB9LFxcbiAgICB9O1xcbiAgICB2YXIgX2Vtc2NyaXB0ZW5fZGF0ZV9ub3cgPSAoKSA9PiBEYXRlLm5vdygpO1xcbiAgICB2YXIgZ2V0SGVhcE1heCA9ICgpID0+IDIxNDc0ODM2NDg7XFxuICAgIHZhciBncm93TWVtb3J5ID0gKHNpemUpID0+IHtcXG4gICAgICB2YXIgYiA9IHdhc21NZW1vcnkuYnVmZmVyO1xcbiAgICAgIHZhciBwYWdlcyA9ICgoc2l6ZSAtIGIuYnl0ZUxlbmd0aCArIDY1NTM1KSAvIDY1NTM2KSB8IDA7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIHdhc21NZW1vcnkuZ3JvdyhCaWdJbnQocGFnZXMpKTtcXG4gICAgICAgIHVwZGF0ZU1lbW9yeVZpZXdzKCk7XFxuICAgICAgICByZXR1cm4gMTtcXG4gICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBlcnIoXFxuICAgICAgICAgIGBncm93TWVtb3J5OiBBdHRlbXB0ZWQgdG8gZ3JvdyBoZWFwIGZyb20gJHtiLmJ5dGVMZW5ndGh9IGJ5dGVzIHRvICR7c2l6ZX0gYnl0ZXMsIGJ1dCBnb3QgZXJyb3I6ICR7ZX1gLFxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuICAgIH07XFxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwKHJlcXVlc3RlZFNpemUpIHtcXG4gICAgICByZXF1ZXN0ZWRTaXplID0gYmlnaW50VG9JNTNDaGVja2VkKHJlcXVlc3RlZFNpemUpO1xcbiAgICAgIHZhciBvbGRTaXplID0gSEVBUFU4Lmxlbmd0aDtcXG4gICAgICBhc3NlcnQocmVxdWVzdGVkU2l6ZSA+IG9sZFNpemUpO1xcbiAgICAgIHZhciBtYXhIZWFwU2l6ZSA9IGdldEhlYXBNYXgoKTtcXG4gICAgICBpZiAocmVxdWVzdGVkU2l6ZSA+IG1heEhlYXBTaXplKSB7XFxuICAgICAgICBlcnIoXFxuICAgICAgICAgIGBDYW5ub3QgZW5sYXJnZSBtZW1vcnksIHJlcXVlc3RlZCAke3JlcXVlc3RlZFNpemV9IGJ5dGVzLCBidXQgdGhlIGxpbWl0IGlzICR7bWF4SGVhcFNpemV9IGJ5dGVzIWAsXFxuICAgICAgICApO1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG4gICAgICBmb3IgKHZhciBjdXREb3duID0gMTsgY3V0RG93biA8PSA0OyBjdXREb3duICo9IDIpIHtcXG4gICAgICAgIHZhciBvdmVyR3Jvd25IZWFwU2l6ZSA9IG9sZFNpemUgKiAoMSArIDAuMiAvIGN1dERvd24pO1xcbiAgICAgICAgb3Zlckdyb3duSGVhcFNpemUgPSBNYXRoLm1pbihcXG4gICAgICAgICAgb3Zlckdyb3duSGVhcFNpemUsXFxuICAgICAgICAgIHJlcXVlc3RlZFNpemUgKyAxMDA2NjMyOTYsXFxuICAgICAgICApO1xcbiAgICAgICAgdmFyIG5ld1NpemUgPSBNYXRoLm1pbihcXG4gICAgICAgICAgbWF4SGVhcFNpemUsXFxuICAgICAgICAgIGFsaWduTWVtb3J5KE1hdGgubWF4KHJlcXVlc3RlZFNpemUsIG92ZXJHcm93bkhlYXBTaXplKSwgNjU1MzYpLFxcbiAgICAgICAgKTtcXG4gICAgICAgIHZhciByZXBsYWNlbWVudCA9IGdyb3dNZW1vcnkobmV3U2l6ZSk7XFxuICAgICAgICBpZiAocmVwbGFjZW1lbnQpIHtcXG4gICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGVycihcXG4gICAgICAgIGBGYWlsZWQgdG8gZ3JvdyB0aGUgaGVhcCBmcm9tICR7b2xkU2l6ZX0gYnl0ZXMgdG8gJHtuZXdTaXplfSBieXRlcywgbm90IGVub3VnaCBtZW1vcnkhYCxcXG4gICAgICApO1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9ydW5fc2NyaXB0X2ludChwdHIpIHtcXG4gICAgICBwdHIgPSBiaWdpbnRUb0k1M0NoZWNrZWQocHRyKTtcXG4gICAgICByZXR1cm4gZXZhbChVVEY4VG9TdHJpbmcocHRyKSkgfCAwO1xcbiAgICB9XFxuICAgIHZhciBzYWZlU2V0VGltZW91dCA9IChmdW5jLCB0aW1lb3V0KSA9PlxcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xcbiAgICAgICAgY2FsbFVzZXJDYWxsYmFjayhmdW5jKTtcXG4gICAgICB9LCB0aW1lb3V0KTtcXG4gICAgdmFyIF9lbXNjcmlwdGVuX3NsZWVwID0gKG1zKSA9PlxcbiAgICAgIEFzeW5jaWZ5LmhhbmRsZVNsZWVwKCh3YWtlVXApID0+IHNhZmVTZXRUaW1lb3V0KHdha2VVcCwgbXMpKTtcXG4gICAgX2Vtc2NyaXB0ZW5fc2xlZXAuaXNBc3luYyA9IHRydWU7XFxuICAgIGZ1bmN0aW9uIF9mZF9jbG9zZShmZCkge1xcbiAgICAgIHRyeSB7XFxuICAgICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcXG4gICAgICAgIEZTLmNsb3NlKHN0cmVhbSk7XFxuICAgICAgICByZXR1cm4gMDtcXG4gICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBpZiAodHlwZW9mIEZTID09IFwidW5kZWZpbmVkXCIgfHwgIShlLm5hbWUgPT09IFwiRXJybm9FcnJvclwiKSkgdGhyb3cgZTtcXG4gICAgICAgIHJldHVybiBlLmVycm5vO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICB2YXIgZG9SZWFkdiA9IChzdHJlYW0sIGlvdiwgaW92Y250LCBvZmZzZXQpID0+IHtcXG4gICAgICB2YXIgcmV0ID0gMDtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlvdmNudDsgaSsrKSB7XFxuICAgICAgICB2YXIgcHRyID0gTnVtYmVyKEhFQVBVNjRbaW92IC8gOF0pO1xcbiAgICAgICAgdmFyIGxlbiA9IE51bWJlcihIRUFQVTY0Wyhpb3YgKyA4KSAvIDhdKTtcXG4gICAgICAgIGlvdiArPSAxNjtcXG4gICAgICAgIHZhciBjdXJyID0gRlMucmVhZChzdHJlYW0sIEhFQVA4LCBwdHIsIGxlbiwgb2Zmc2V0KTtcXG4gICAgICAgIGlmIChjdXJyIDwgMCkgcmV0dXJuIC0xO1xcbiAgICAgICAgcmV0ICs9IGN1cnI7XFxuICAgICAgICBpZiAoY3VyciA8IGxlbikgYnJlYWs7XFxuICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPSBcInVuZGVmaW5lZFwiKSB7XFxuICAgICAgICAgIG9mZnNldCArPSBjdXJyO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gcmV0O1xcbiAgICB9O1xcbiAgICBmdW5jdGlvbiBfZmRfcmVhZChmZCwgaW92LCBpb3ZjbnQsIHBudW0pIHtcXG4gICAgICBpb3YgPSBiaWdpbnRUb0k1M0NoZWNrZWQoaW92KTtcXG4gICAgICBpb3ZjbnQgPSBiaWdpbnRUb0k1M0NoZWNrZWQoaW92Y250KTtcXG4gICAgICBwbnVtID0gYmlnaW50VG9JNTNDaGVja2VkKHBudW0pO1xcbiAgICAgIHRyeSB7XFxuICAgICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcXG4gICAgICAgIHZhciBudW0gPSBkb1JlYWR2KHN0cmVhbSwgaW92LCBpb3ZjbnQpO1xcbiAgICAgICAgSEVBUFU2NFtwbnVtIC8gOF0gPSBCaWdJbnQobnVtKTtcXG4gICAgICAgIHJldHVybiAwO1xcbiAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gXCJ1bmRlZmluZWRcIiB8fCAhKGUubmFtZSA9PT0gXCJFcnJub0Vycm9yXCIpKSB0aHJvdyBlO1xcbiAgICAgICAgcmV0dXJuIGUuZXJybm87XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGZ1bmN0aW9uIF9mZF9zZWVrKGZkLCBvZmZzZXQsIHdoZW5jZSwgbmV3T2Zmc2V0KSB7XFxuICAgICAgb2Zmc2V0ID0gYmlnaW50VG9JNTNDaGVja2VkKG9mZnNldCk7XFxuICAgICAgbmV3T2Zmc2V0ID0gYmlnaW50VG9JNTNDaGVja2VkKG5ld09mZnNldCk7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGlmIChpc05hTihvZmZzZXQpKSByZXR1cm4gNjE7XFxuICAgICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcXG4gICAgICAgIEZTLmxsc2VlayhzdHJlYW0sIG9mZnNldCwgd2hlbmNlKTtcXG4gICAgICAgIEhFQVA2NFtuZXdPZmZzZXQgLyA4XSA9IEJpZ0ludChzdHJlYW0ucG9zaXRpb24pO1xcbiAgICAgICAgaWYgKHN0cmVhbS5nZXRkZW50cyAmJiBvZmZzZXQgPT09IDAgJiYgd2hlbmNlID09PSAwKVxcbiAgICAgICAgICBzdHJlYW0uZ2V0ZGVudHMgPSBudWxsO1xcbiAgICAgICAgcmV0dXJuIDA7XFxuICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSBcInVuZGVmaW5lZFwiIHx8ICEoZS5uYW1lID09PSBcIkVycm5vRXJyb3JcIikpIHRocm93IGU7XFxuICAgICAgICByZXR1cm4gZS5lcnJubztcXG4gICAgICB9XFxuICAgIH1cXG4gICAgdmFyIGRvV3JpdGV2ID0gKHN0cmVhbSwgaW92LCBpb3ZjbnQsIG9mZnNldCkgPT4ge1xcbiAgICAgIHZhciByZXQgPSAwO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW92Y250OyBpKyspIHtcXG4gICAgICAgIHZhciBwdHIgPSBOdW1iZXIoSEVBUFU2NFtpb3YgLyA4XSk7XFxuICAgICAgICB2YXIgbGVuID0gTnVtYmVyKEhFQVBVNjRbKGlvdiArIDgpIC8gOF0pO1xcbiAgICAgICAgaW92ICs9IDE2O1xcbiAgICAgICAgdmFyIGN1cnIgPSBGUy53cml0ZShzdHJlYW0sIEhFQVA4LCBwdHIsIGxlbiwgb2Zmc2V0KTtcXG4gICAgICAgIGlmIChjdXJyIDwgMCkgcmV0dXJuIC0xO1xcbiAgICAgICAgcmV0ICs9IGN1cnI7XFxuICAgICAgICBpZiAoY3VyciA8IGxlbikge1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9IFwidW5kZWZpbmVkXCIpIHtcXG4gICAgICAgICAgb2Zmc2V0ICs9IGN1cnI7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiByZXQ7XFxuICAgIH07XFxuICAgIGZ1bmN0aW9uIF9mZF93cml0ZShmZCwgaW92LCBpb3ZjbnQsIHBudW0pIHtcXG4gICAgICBpb3YgPSBiaWdpbnRUb0k1M0NoZWNrZWQoaW92KTtcXG4gICAgICBpb3ZjbnQgPSBiaWdpbnRUb0k1M0NoZWNrZWQoaW92Y250KTtcXG4gICAgICBwbnVtID0gYmlnaW50VG9JNTNDaGVja2VkKHBudW0pO1xcbiAgICAgIHRyeSB7XFxuICAgICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcXG4gICAgICAgIHZhciBudW0gPSBkb1dyaXRldihzdHJlYW0sIGlvdiwgaW92Y250KTtcXG4gICAgICAgIEhFQVBVNjRbcG51bSAvIDhdID0gQmlnSW50KG51bSk7XFxuICAgICAgICByZXR1cm4gMDtcXG4gICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBpZiAodHlwZW9mIEZTID09IFwidW5kZWZpbmVkXCIgfHwgIShlLm5hbWUgPT09IFwiRXJybm9FcnJvclwiKSkgdGhyb3cgZTtcXG4gICAgICAgIHJldHVybiBlLmVycm5vO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICB2YXIgc3RyaW5nVG9VVEY4ID0gKHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpID0+IHtcXG4gICAgICBhc3NlcnQoXFxuICAgICAgICB0eXBlb2YgbWF4Qnl0ZXNUb1dyaXRlID09IFwibnVtYmVyXCIsXFxuICAgICAgICBcInN0cmluZ1RvVVRGOChzdHIsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKSBpcyBtaXNzaW5nIHRoZSB0aGlyZCBwYXJhbWV0ZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGxlbmd0aCBvZiB0aGUgb3V0cHV0IGJ1ZmZlciFcIixcXG4gICAgICApO1xcbiAgICAgIHJldHVybiBzdHJpbmdUb1VURjhBcnJheShzdHIsIEhFQVBVOCwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpO1xcbiAgICB9O1xcbiAgICB2YXIgc3RhY2tBbGxvYyA9IChzeikgPT4gX19lbXNjcmlwdGVuX3N0YWNrX2FsbG9jKHN6KTtcXG4gICAgdmFyIHN0cmluZ1RvVVRGOE9uU3RhY2sgPSAoc3RyKSA9PiB7XFxuICAgICAgdmFyIHNpemUgPSBsZW5ndGhCeXRlc1VURjgoc3RyKSArIDE7XFxuICAgICAgdmFyIHJldCA9IHN0YWNrQWxsb2Moc2l6ZSk7XFxuICAgICAgc3RyaW5nVG9VVEY4KHN0ciwgcmV0LCBzaXplKTtcXG4gICAgICByZXR1cm4gcmV0O1xcbiAgICB9O1xcbiAgICB2YXIgcnVuQW5kQWJvcnRJZkVycm9yID0gKGZ1bmMpID0+IHtcXG4gICAgICB0cnkge1xcbiAgICAgICAgcmV0dXJuIGZ1bmMoKTtcXG4gICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBhYm9ydChlKTtcXG4gICAgICB9XFxuICAgIH07XFxuICAgIHZhciBydW50aW1lS2VlcGFsaXZlUHVzaCA9ICgpID0+IHtcXG4gICAgICBydW50aW1lS2VlcGFsaXZlQ291bnRlciArPSAxO1xcbiAgICB9O1xcbiAgICB2YXIgcnVudGltZUtlZXBhbGl2ZVBvcCA9ICgpID0+IHtcXG4gICAgICBhc3NlcnQocnVudGltZUtlZXBhbGl2ZUNvdW50ZXIgPiAwKTtcXG4gICAgICBydW50aW1lS2VlcGFsaXZlQ291bnRlciAtPSAxO1xcbiAgICB9O1xcbiAgICB2YXIgQXN5bmNpZnkgPSB7XFxuICAgICAgcmV3aW5kQXJndW1lbnRzOiB7fSxcXG4gICAgICBpbnN0cnVtZW50V2FzbUltcG9ydHMoaW1wb3J0cykge1xcbiAgICAgICAgdmFyIGltcG9ydFBhdHRlcm4gPSAvXihpbnZva2VfLip8X19hc3luY2pzX18uKikkLztcXG4gICAgICAgIGZvciAobGV0IFt4LCBvcmlnaW5hbF0gb2YgT2JqZWN0LmVudHJpZXMoaW1wb3J0cykpIHtcXG4gICAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbCA9PSBcImZ1bmN0aW9uXCIpIHtcXG4gICAgICAgICAgICBsZXQgaXNBc3luY2lmeUltcG9ydCA9IG9yaWdpbmFsLmlzQXN5bmMgfHwgaW1wb3J0UGF0dGVybi50ZXN0KHgpO1xcbiAgICAgICAgICAgIGltcG9ydHNbeF0gPSAoLi4uYXJncykgPT4ge1xcbiAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsQXN5bmNpZnlTdGF0ZSA9IEFzeW5jaWZ5LnN0YXRlO1xcbiAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsKC4uLmFyZ3MpO1xcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcXG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZWRUb0Rpc2FibGVkID1cXG4gICAgICAgICAgICAgICAgICBvcmlnaW5hbEFzeW5jaWZ5U3RhdGUgPT09IEFzeW5jaWZ5LlN0YXRlLk5vcm1hbCAmJlxcbiAgICAgICAgICAgICAgICAgIEFzeW5jaWZ5LnN0YXRlID09PSBBc3luY2lmeS5TdGF0ZS5EaXNhYmxlZDtcXG4gICAgICAgICAgICAgICAgdmFyIGlnbm9yZWRJbnZva2UgPSB4LnN0YXJ0c1dpdGgoXCJpbnZva2VfXCIpICYmIHRydWU7XFxuICAgICAgICAgICAgICAgIGlmIChcXG4gICAgICAgICAgICAgICAgICBBc3luY2lmeS5zdGF0ZSAhPT0gb3JpZ2luYWxBc3luY2lmeVN0YXRlICYmXFxuICAgICAgICAgICAgICAgICAgIWlzQXN5bmNpZnlJbXBvcnQgJiZcXG4gICAgICAgICAgICAgICAgICAhY2hhbmdlZFRvRGlzYWJsZWQgJiZcXG4gICAgICAgICAgICAgICAgICAhaWdub3JlZEludm9rZVxcbiAgICAgICAgICAgICAgICApIHtcXG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxuICAgICAgICAgICAgICAgICAgICBgaW1wb3J0ICR7eH0gd2FzIG5vdCBpbiBBU1lOQ0lGWV9JTVBPUlRTLCBidXQgY2hhbmdlZCB0aGUgc3RhdGVgLFxcbiAgICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSxcXG4gICAgICBzYXZlUmV3aW5kQXJndW1lbnRzKGZ1bmNOYW1lLCBwYXNzZWRBcmd1bWVudHMpIHtcXG4gICAgICAgIHJldHVybiAoQXN5bmNpZnkucmV3aW5kQXJndW1lbnRzW2Z1bmNOYW1lXSA9XFxuICAgICAgICAgIEFycmF5LmZyb20ocGFzc2VkQXJndW1lbnRzKSk7XFxuICAgICAgfSxcXG4gICAgICByZXN0b3JlUmV3aW5kQXJndW1lbnRzKGZ1bmNOYW1lKSB7XFxuICAgICAgICByZXR1cm4gQXN5bmNpZnkucmV3aW5kQXJndW1lbnRzW2Z1bmNOYW1lXSB8fCBbXTtcXG4gICAgICB9LFxcbiAgICAgIGluc3RydW1lbnRXYXNtRXhwb3J0cyhleHBvcnRzKSB7XFxuICAgICAgICB2YXIgcmV0ID0ge307XFxuICAgICAgICBmb3IgKGxldCBbeCwgb3JpZ2luYWxdIG9mIE9iamVjdC5lbnRyaWVzKGV4cG9ydHMpKSB7XFxuICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWwgPT0gXCJmdW5jdGlvblwiKSB7XFxuICAgICAgICAgICAgcmV0W3hdID0gKC4uLmFyZ3MpID0+IHtcXG4gICAgICAgICAgICAgIEFzeW5jaWZ5LmV4cG9ydENhbGxTdGFjay5wdXNoKHgpO1xcbiAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgQXN5bmNpZnkuc2F2ZVJld2luZEFyZ3VtZW50cyh4LCBhcmdzKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsKC4uLmFyZ3MpO1xcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcXG4gICAgICAgICAgICAgICAgaWYgKCFBQk9SVCkge1xcbiAgICAgICAgICAgICAgICAgIHZhciB5ID0gQXN5bmNpZnkuZXhwb3J0Q2FsbFN0YWNrLnBvcCgpO1xcbiAgICAgICAgICAgICAgICAgIGFzc2VydCh5ID09PSB4KTtcXG4gICAgICAgICAgICAgICAgICBBc3luY2lmeS5tYXliZVN0b3BVbndpbmQoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0W3hdID0gb3JpZ2luYWw7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiByZXQ7XFxuICAgICAgfSxcXG4gICAgICBTdGF0ZTogeyBOb3JtYWw6IDAsIFVud2luZGluZzogMSwgUmV3aW5kaW5nOiAyLCBEaXNhYmxlZDogMyB9LFxcbiAgICAgIHN0YXRlOiAwLFxcbiAgICAgIFN0YWNrU2l6ZTogNDA5NixcXG4gICAgICBjdXJyRGF0YTogbnVsbCxcXG4gICAgICBoYW5kbGVTbGVlcFJldHVyblZhbHVlOiAwLFxcbiAgICAgIGV4cG9ydENhbGxTdGFjazogW10sXFxuICAgICAgY2FsbFN0YWNrTmFtZVRvSWQ6IHt9LFxcbiAgICAgIGNhbGxTdGFja0lkVG9OYW1lOiB7fSxcXG4gICAgICBjYWxsU3RhY2tJZDogMCxcXG4gICAgICBhc3luY1Byb21pc2VIYW5kbGVyczogbnVsbCxcXG4gICAgICBzbGVlcENhbGxiYWNrczogW10sXFxuICAgICAgZ2V0Q2FsbFN0YWNrSWQoZnVuY05hbWUpIHtcXG4gICAgICAgIHZhciBpZCA9IEFzeW5jaWZ5LmNhbGxTdGFja05hbWVUb0lkW2Z1bmNOYW1lXTtcXG4gICAgICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgIGlkID0gQXN5bmNpZnkuY2FsbFN0YWNrSWQrKztcXG4gICAgICAgICAgQXN5bmNpZnkuY2FsbFN0YWNrTmFtZVRvSWRbZnVuY05hbWVdID0gaWQ7XFxuICAgICAgICAgIEFzeW5jaWZ5LmNhbGxTdGFja0lkVG9OYW1lW2lkXSA9IGZ1bmNOYW1lO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGlkO1xcbiAgICAgIH0sXFxuICAgICAgbWF5YmVTdG9wVW53aW5kKCkge1xcbiAgICAgICAgaWYgKFxcbiAgICAgICAgICBBc3luY2lmeS5jdXJyRGF0YSAmJlxcbiAgICAgICAgICBBc3luY2lmeS5zdGF0ZSA9PT0gQXN5bmNpZnkuU3RhdGUuVW53aW5kaW5nICYmXFxuICAgICAgICAgIEFzeW5jaWZ5LmV4cG9ydENhbGxTdGFjay5sZW5ndGggPT09IDBcXG4gICAgICAgICkge1xcbiAgICAgICAgICBBc3luY2lmeS5zdGF0ZSA9IEFzeW5jaWZ5LlN0YXRlLk5vcm1hbDtcXG4gICAgICAgICAgcnVuQW5kQWJvcnRJZkVycm9yKF9hc3luY2lmeV9zdG9wX3Vud2luZCk7XFxuICAgICAgICAgIGlmICh0eXBlb2YgRmliZXJzICE9IFwidW5kZWZpbmVkXCIpIHtcXG4gICAgICAgICAgICBGaWJlcnMudHJhbXBvbGluZSgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSxcXG4gICAgICB3aGVuRG9uZSgpIHtcXG4gICAgICAgIGFzc2VydChcXG4gICAgICAgICAgQXN5bmNpZnkuY3VyckRhdGEsXFxuICAgICAgICAgIFwiVHJpZWQgdG8gd2FpdCBmb3IgYW4gYXN5bmMgb3BlcmF0aW9uIHdoZW4gbm9uZSBpcyBpbiBwcm9ncmVzcy5cIixcXG4gICAgICAgICk7XFxuICAgICAgICBhc3NlcnQoXFxuICAgICAgICAgICFBc3luY2lmeS5hc3luY1Byb21pc2VIYW5kbGVycyxcXG4gICAgICAgICAgXCJDYW5ub3QgaGF2ZSBtdWx0aXBsZSBhc3luYyBvcGVyYXRpb25zIGluIGZsaWdodCBhdCBvbmNlXCIsXFxuICAgICAgICApO1xcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcXG4gICAgICAgICAgQXN5bmNpZnkuYXN5bmNQcm9taXNlSGFuZGxlcnMgPSB7IHJlc29sdmUsIHJlamVjdCB9O1xcbiAgICAgICAgfSk7XFxuICAgICAgfSxcXG4gICAgICBhbGxvY2F0ZURhdGEoKSB7XFxuICAgICAgICB2YXIgcHRyID0gX21hbGxvYygyNCArIEFzeW5jaWZ5LlN0YWNrU2l6ZSk7XFxuICAgICAgICBBc3luY2lmeS5zZXREYXRhSGVhZGVyKHB0ciwgcHRyICsgMjQsIEFzeW5jaWZ5LlN0YWNrU2l6ZSk7XFxuICAgICAgICBBc3luY2lmeS5zZXREYXRhUmV3aW5kRnVuYyhwdHIpO1xcbiAgICAgICAgcmV0dXJuIHB0cjtcXG4gICAgICB9LFxcbiAgICAgIHNldERhdGFIZWFkZXIocHRyLCBzdGFjaywgc3RhY2tTaXplKSB7XFxuICAgICAgICBIRUFQVTY0W3B0ciAvIDhdID0gQmlnSW50KHN0YWNrKTtcXG4gICAgICAgIEhFQVBVNjRbKHB0ciArIDgpIC8gOF0gPSBCaWdJbnQoc3RhY2sgKyBzdGFja1NpemUpO1xcbiAgICAgIH0sXFxuICAgICAgc2V0RGF0YVJld2luZEZ1bmMocHRyKSB7XFxuICAgICAgICB2YXIgYm90dG9tT2ZDYWxsU3RhY2sgPSBBc3luY2lmeS5leHBvcnRDYWxsU3RhY2tbMF07XFxuICAgICAgICB2YXIgcmV3aW5kSWQgPSBBc3luY2lmeS5nZXRDYWxsU3RhY2tJZChib3R0b21PZkNhbGxTdGFjayk7XFxuICAgICAgICBIRUFQMzJbKHB0ciArIDE2KSAvIDRdID0gcmV3aW5kSWQ7XFxuICAgICAgfSxcXG4gICAgICBnZXREYXRhUmV3aW5kRnVuY05hbWUocHRyKSB7XFxuICAgICAgICB2YXIgaWQgPSBIRUFQMzJbKHB0ciArIDE2KSAvIDRdO1xcbiAgICAgICAgdmFyIG5hbWUgPSBBc3luY2lmeS5jYWxsU3RhY2tJZFRvTmFtZVtpZF07XFxuICAgICAgICByZXR1cm4gbmFtZTtcXG4gICAgICB9LFxcbiAgICAgIGdldERhdGFSZXdpbmRGdW5jKG5hbWUpIHtcXG4gICAgICAgIHZhciBmdW5jID0gd2FzbUV4cG9ydHNbbmFtZV07XFxuICAgICAgICByZXR1cm4gZnVuYztcXG4gICAgICB9LFxcbiAgICAgIGRvUmV3aW5kKHB0cikge1xcbiAgICAgICAgdmFyIG5hbWUgPSBBc3luY2lmeS5nZXREYXRhUmV3aW5kRnVuY05hbWUocHRyKTtcXG4gICAgICAgIHZhciBmdW5jID0gQXN5bmNpZnkuZ2V0RGF0YVJld2luZEZ1bmMobmFtZSk7XFxuICAgICAgICByZXR1cm4gZnVuYyguLi5Bc3luY2lmeS5yZXN0b3JlUmV3aW5kQXJndW1lbnRzKG5hbWUpKTtcXG4gICAgICB9LFxcbiAgICAgIGhhbmRsZVNsZWVwKHN0YXJ0QXN5bmMpIHtcXG4gICAgICAgIGFzc2VydChcXG4gICAgICAgICAgQXN5bmNpZnkuc3RhdGUgIT09IEFzeW5jaWZ5LlN0YXRlLkRpc2FibGVkLFxcbiAgICAgICAgICBcIkFzeW5jaWZ5IGNhbm5vdCBiZSBkb25lIGR1cmluZyBvciBhZnRlciB0aGUgcnVudGltZSBleGl0c1wiLFxcbiAgICAgICAgKTtcXG4gICAgICAgIGlmIChBQk9SVCkgcmV0dXJuO1xcbiAgICAgICAgaWYgKEFzeW5jaWZ5LnN0YXRlID09PSBBc3luY2lmeS5TdGF0ZS5Ob3JtYWwpIHtcXG4gICAgICAgICAgdmFyIHJlYWNoZWRDYWxsYmFjayA9IGZhbHNlO1xcbiAgICAgICAgICB2YXIgcmVhY2hlZEFmdGVyQ2FsbGJhY2sgPSBmYWxzZTtcXG4gICAgICAgICAgc3RhcnRBc3luYygoaGFuZGxlU2xlZXBSZXR1cm5WYWx1ZSA9IDApID0+IHtcXG4gICAgICAgICAgICBhc3NlcnQoXFxuICAgICAgICAgICAgICAhaGFuZGxlU2xlZXBSZXR1cm5WYWx1ZSB8fFxcbiAgICAgICAgICAgICAgICB0eXBlb2YgaGFuZGxlU2xlZXBSZXR1cm5WYWx1ZSA9PSBcIm51bWJlclwiIHx8XFxuICAgICAgICAgICAgICAgIHR5cGVvZiBoYW5kbGVTbGVlcFJldHVyblZhbHVlID09IFwiYm9vbGVhblwiLFxcbiAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgaWYgKEFCT1JUKSByZXR1cm47XFxuICAgICAgICAgICAgQXN5bmNpZnkuaGFuZGxlU2xlZXBSZXR1cm5WYWx1ZSA9IGhhbmRsZVNsZWVwUmV0dXJuVmFsdWU7XFxuICAgICAgICAgICAgcmVhY2hlZENhbGxiYWNrID0gdHJ1ZTtcXG4gICAgICAgICAgICBpZiAoIXJlYWNoZWRBZnRlckNhbGxiYWNrKSB7XFxuICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGFzc2VydChcXG4gICAgICAgICAgICAgICFBc3luY2lmeS5leHBvcnRDYWxsU3RhY2subGVuZ3RoLFxcbiAgICAgICAgICAgICAgXCJXYWtpbmcgdXAgKHN0YXJ0aW5nIHRvIHJld2luZCkgbXVzdCBiZSBkb25lIGZyb20gSlMsIHdpdGhvdXQgY29tcGlsZWQgY29kZSBvbiB0aGUgc3RhY2suXCIsXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICBBc3luY2lmeS5zdGF0ZSA9IEFzeW5jaWZ5LlN0YXRlLlJld2luZGluZztcXG4gICAgICAgICAgICBydW5BbmRBYm9ydElmRXJyb3IoKCkgPT4gX2FzeW5jaWZ5X3N0YXJ0X3Jld2luZChBc3luY2lmeS5jdXJyRGF0YSkpO1xcbiAgICAgICAgICAgIGlmICh0eXBlb2YgTWFpbkxvb3AgIT0gXCJ1bmRlZmluZWRcIiAmJiBNYWluTG9vcC5mdW5jKSB7XFxuICAgICAgICAgICAgICBNYWluTG9vcC5yZXN1bWUoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdmFyIGFzeW5jV2FzbVJldHVyblZhbHVlLFxcbiAgICAgICAgICAgICAgaXNFcnJvciA9IGZhbHNlO1xcbiAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICBhc3luY1dhc21SZXR1cm5WYWx1ZSA9IEFzeW5jaWZ5LmRvUmV3aW5kKEFzeW5jaWZ5LmN1cnJEYXRhKTtcXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgICAgIGFzeW5jV2FzbVJldHVyblZhbHVlID0gZXJyO1xcbiAgICAgICAgICAgICAgaXNFcnJvciA9IHRydWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHZhciBoYW5kbGVkID0gZmFsc2U7XFxuICAgICAgICAgICAgaWYgKCFBc3luY2lmeS5jdXJyRGF0YSkge1xcbiAgICAgICAgICAgICAgdmFyIGFzeW5jUHJvbWlzZUhhbmRsZXJzID0gQXN5bmNpZnkuYXN5bmNQcm9taXNlSGFuZGxlcnM7XFxuICAgICAgICAgICAgICBpZiAoYXN5bmNQcm9taXNlSGFuZGxlcnMpIHtcXG4gICAgICAgICAgICAgICAgQXN5bmNpZnkuYXN5bmNQcm9taXNlSGFuZGxlcnMgPSBudWxsO1xcbiAgICAgICAgICAgICAgICAoaXNFcnJvclxcbiAgICAgICAgICAgICAgICAgID8gYXN5bmNQcm9taXNlSGFuZGxlcnMucmVqZWN0XFxuICAgICAgICAgICAgICAgICAgOiBhc3luY1Byb21pc2VIYW5kbGVycy5yZXNvbHZlKShhc3luY1dhc21SZXR1cm5WYWx1ZSk7XFxuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoaXNFcnJvciAmJiAhaGFuZGxlZCkge1xcbiAgICAgICAgICAgICAgdGhyb3cgYXN5bmNXYXNtUmV0dXJuVmFsdWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgcmVhY2hlZEFmdGVyQ2FsbGJhY2sgPSB0cnVlO1xcbiAgICAgICAgICBpZiAoIXJlYWNoZWRDYWxsYmFjaykge1xcbiAgICAgICAgICAgIEFzeW5jaWZ5LnN0YXRlID0gQXN5bmNpZnkuU3RhdGUuVW53aW5kaW5nO1xcbiAgICAgICAgICAgIEFzeW5jaWZ5LmN1cnJEYXRhID0gQXN5bmNpZnkuYWxsb2NhdGVEYXRhKCk7XFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBNYWluTG9vcCAhPSBcInVuZGVmaW5lZFwiICYmIE1haW5Mb29wLmZ1bmMpIHtcXG4gICAgICAgICAgICAgIE1haW5Mb29wLnBhdXNlKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJ1bkFuZEFib3J0SWZFcnJvcigoKSA9PiBfYXN5bmNpZnlfc3RhcnRfdW53aW5kKEFzeW5jaWZ5LmN1cnJEYXRhKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSBpZiAoQXN5bmNpZnkuc3RhdGUgPT09IEFzeW5jaWZ5LlN0YXRlLlJld2luZGluZykge1xcbiAgICAgICAgICBBc3luY2lmeS5zdGF0ZSA9IEFzeW5jaWZ5LlN0YXRlLk5vcm1hbDtcXG4gICAgICAgICAgcnVuQW5kQWJvcnRJZkVycm9yKF9hc3luY2lmeV9zdG9wX3Jld2luZCk7XFxuICAgICAgICAgIF9mcmVlKEFzeW5jaWZ5LmN1cnJEYXRhKTtcXG4gICAgICAgICAgQXN5bmNpZnkuY3VyckRhdGEgPSBudWxsO1xcbiAgICAgICAgICBBc3luY2lmeS5zbGVlcENhbGxiYWNrcy5mb3JFYWNoKGNhbGxVc2VyQ2FsbGJhY2spO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgYWJvcnQoYGludmFsaWQgc3RhdGU6ICR7QXN5bmNpZnkuc3RhdGV9YCk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gQXN5bmNpZnkuaGFuZGxlU2xlZXBSZXR1cm5WYWx1ZTtcXG4gICAgICB9LFxcbiAgICAgIGhhbmRsZUFzeW5jKHN0YXJ0QXN5bmMpIHtcXG4gICAgICAgIHJldHVybiBBc3luY2lmeS5oYW5kbGVTbGVlcCgod2FrZVVwKSA9PiB7XFxuICAgICAgICAgIHN0YXJ0QXN5bmMoKS50aGVuKHdha2VVcCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9LFxcbiAgICB9O1xcbiAgICB2YXIgZ2V0Q0Z1bmMgPSAoaWRlbnQpID0+IHtcXG4gICAgICB2YXIgZnVuYyA9IE1vZHVsZVtcIl9cIiArIGlkZW50XTtcXG4gICAgICBhc3NlcnQoXFxuICAgICAgICBmdW5jLFxcbiAgICAgICAgXCJDYW5ub3QgY2FsbCB1bmtub3duIGZ1bmN0aW9uIFwiICsgaWRlbnQgKyBcIiwgbWFrZSBzdXJlIGl0IGlzIGV4cG9ydGVkXCIsXFxuICAgICAgKTtcXG4gICAgICByZXR1cm4gZnVuYztcXG4gICAgfTtcXG4gICAgdmFyIHdyaXRlQXJyYXlUb01lbW9yeSA9IChhcnJheSwgYnVmZmVyKSA9PiB7XFxuICAgICAgYXNzZXJ0KFxcbiAgICAgICAgYXJyYXkubGVuZ3RoID49IDAsXFxuICAgICAgICBcIndyaXRlQXJyYXlUb01lbW9yeSBhcnJheSBtdXN0IGhhdmUgYSBsZW5ndGggKHNob3VsZCBiZSBhbiBhcnJheSBvciB0eXBlZCBhcnJheSlcIixcXG4gICAgICApO1xcbiAgICAgIEhFQVA4LnNldChhcnJheSwgYnVmZmVyKTtcXG4gICAgfTtcXG4gICAgdmFyIGNjYWxsID0gKGlkZW50LCByZXR1cm5UeXBlLCBhcmdUeXBlcywgYXJncywgb3B0cykgPT4ge1xcbiAgICAgIHZhciB0b0MgPSB7XFxuICAgICAgICBwb2ludGVyOiAocCkgPT4gQmlnSW50KHApLFxcbiAgICAgICAgc3RyaW5nOiAoc3RyKSA9PiB7XFxuICAgICAgICAgIHZhciByZXQgPSAwO1xcbiAgICAgICAgICBpZiAoc3RyICE9PSBudWxsICYmIHN0ciAhPT0gdW5kZWZpbmVkICYmIHN0ciAhPT0gMCkge1xcbiAgICAgICAgICAgIHJldCA9IHN0cmluZ1RvVVRGOE9uU3RhY2soc3RyKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXR1cm4gQmlnSW50KHJldCk7XFxuICAgICAgICB9LFxcbiAgICAgICAgYXJyYXk6IChhcnIpID0+IHtcXG4gICAgICAgICAgdmFyIHJldCA9IHN0YWNrQWxsb2MoYXJyLmxlbmd0aCk7XFxuICAgICAgICAgIHdyaXRlQXJyYXlUb01lbW9yeShhcnIsIHJldCk7XFxuICAgICAgICAgIHJldHVybiBCaWdJbnQocmV0KTtcXG4gICAgICAgIH0sXFxuICAgICAgfTtcXG4gICAgICBmdW5jdGlvbiBjb252ZXJ0UmV0dXJuVmFsdWUocmV0KSB7XFxuICAgICAgICBpZiAocmV0dXJuVHlwZSA9PT0gXCJzdHJpbmdcIikge1xcbiAgICAgICAgICByZXR1cm4gVVRGOFRvU3RyaW5nKE51bWJlcihyZXQpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChyZXR1cm5UeXBlID09PSBcInBvaW50ZXJcIikgcmV0dXJuIE51bWJlcihyZXQpO1xcbiAgICAgICAgaWYgKHJldHVyblR5cGUgPT09IFwiYm9vbGVhblwiKSByZXR1cm4gQm9vbGVhbihyZXQpO1xcbiAgICAgICAgcmV0dXJuIHJldDtcXG4gICAgICB9XFxuICAgICAgdmFyIGZ1bmMgPSBnZXRDRnVuYyhpZGVudCk7XFxuICAgICAgdmFyIGNBcmdzID0gW107XFxuICAgICAgdmFyIHN0YWNrID0gMDtcXG4gICAgICBhc3NlcnQocmV0dXJuVHlwZSAhPT0gXCJhcnJheVwiLCBcXCdSZXR1cm4gdHlwZSBzaG91bGQgbm90IGJlIFwiYXJyYXlcIi5cXCcpO1xcbiAgICAgIGlmIChhcmdzKSB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgdmFyIGNvbnZlcnRlciA9IHRvQ1thcmdUeXBlc1tpXV07XFxuICAgICAgICAgIGlmIChjb252ZXJ0ZXIpIHtcXG4gICAgICAgICAgICBpZiAoc3RhY2sgPT09IDApIHN0YWNrID0gc3RhY2tTYXZlKCk7XFxuICAgICAgICAgICAgY0FyZ3NbaV0gPSBjb252ZXJ0ZXIoYXJnc1tpXSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgY0FyZ3NbaV0gPSBhcmdzW2ldO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHZhciBwcmV2aW91c0FzeW5jID0gQXN5bmNpZnkuY3VyckRhdGE7XFxuICAgICAgdmFyIHJldCA9IGZ1bmMoLi4uY0FyZ3MpO1xcbiAgICAgIGZ1bmN0aW9uIG9uRG9uZShyZXQpIHtcXG4gICAgICAgIHJ1bnRpbWVLZWVwYWxpdmVQb3AoKTtcXG4gICAgICAgIGlmIChzdGFjayAhPT0gMCkgc3RhY2tSZXN0b3JlKHN0YWNrKTtcXG4gICAgICAgIHJldHVybiBjb252ZXJ0UmV0dXJuVmFsdWUocmV0KTtcXG4gICAgICB9XFxuICAgICAgdmFyIGFzeW5jTW9kZSA9IG9wdHM/LmFzeW5jO1xcbiAgICAgIHJ1bnRpbWVLZWVwYWxpdmVQdXNoKCk7XFxuICAgICAgaWYgKEFzeW5jaWZ5LmN1cnJEYXRhICE9IHByZXZpb3VzQXN5bmMpIHtcXG4gICAgICAgIGFzc2VydChcXG4gICAgICAgICAgIShwcmV2aW91c0FzeW5jICYmIEFzeW5jaWZ5LmN1cnJEYXRhKSxcXG4gICAgICAgICAgXCJXZSBjYW5ub3Qgc3RhcnQgYW4gYXN5bmMgb3BlcmF0aW9uIHdoZW4gb25lIGlzIGFscmVhZHkgZmxpZ2h0XCIsXFxuICAgICAgICApO1xcbiAgICAgICAgYXNzZXJ0KFxcbiAgICAgICAgICAhKHByZXZpb3VzQXN5bmMgJiYgIUFzeW5jaWZ5LmN1cnJEYXRhKSxcXG4gICAgICAgICAgXCJXZSBjYW5ub3Qgc3RvcCBhbiBhc3luYyBvcGVyYXRpb24gaW4gZmxpZ2h0XCIsXFxuICAgICAgICApO1xcbiAgICAgICAgYXNzZXJ0KFxcbiAgICAgICAgICBhc3luY01vZGUsXFxuICAgICAgICAgIFwiVGhlIGNhbGwgdG8gXCIgK1xcbiAgICAgICAgICAgIGlkZW50ICtcXG4gICAgICAgICAgICBcIiBpcyBydW5uaW5nIGFzeW5jaHJvbm91c2x5LiBJZiB0aGlzIHdhcyBpbnRlbmRlZCwgYWRkIHRoZSBhc3luYyBvcHRpb24gdG8gdGhlIGNjYWxsL2N3cmFwIGNhbGwuXCIsXFxuICAgICAgICApO1xcbiAgICAgICAgcmV0dXJuIEFzeW5jaWZ5LndoZW5Eb25lKCkudGhlbihvbkRvbmUpO1xcbiAgICAgIH1cXG4gICAgICByZXQgPSBvbkRvbmUocmV0KTtcXG4gICAgICBpZiAoYXN5bmNNb2RlKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJldCk7XFxuICAgICAgcmV0dXJuIHJldDtcXG4gICAgfTtcXG4gICAgRlMuY3JlYXRlUHJlbG9hZGVkRmlsZSA9IEZTX2NyZWF0ZVByZWxvYWRlZEZpbGU7XFxuICAgIEZTLnN0YXRpY0luaXQoKTtcXG4gICAgTW9kdWxlW1wicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdID0gTWFpbkxvb3AucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xcbiAgICBNb2R1bGVbXCJwYXVzZU1haW5Mb29wXCJdID0gTWFpbkxvb3AucGF1c2U7XFxuICAgIE1vZHVsZVtcInJlc3VtZU1haW5Mb29wXCJdID0gTWFpbkxvb3AucmVzdW1lO1xcbiAgICBNYWluTG9vcC5pbml0KCk7XFxuICAgIGZ1bmN0aW9uIGNoZWNrSW5jb21pbmdNb2R1bGVBUEkoKSB7XFxuICAgICAgaWdub3JlZE1vZHVsZVByb3AoXCJmZXRjaFNldHRpbmdzXCIpO1xcbiAgICB9XFxuICAgIHZhciB3YXNtSW1wb3J0cyA9IHtcXG4gICAgICBfX2Fzc2VydF9mYWlsOiBfX19hc3NlcnRfZmFpbCxcXG4gICAgICBfX3N5c2NhbGxfZmNudGw2NDogX19fc3lzY2FsbF9mY250bDY0LFxcbiAgICAgIF9fc3lzY2FsbF9mc3RhdDY0OiBfX19zeXNjYWxsX2ZzdGF0NjQsXFxuICAgICAgX19zeXNjYWxsX2lvY3RsOiBfX19zeXNjYWxsX2lvY3RsLFxcbiAgICAgIF9fc3lzY2FsbF9vcGVuYXQ6IF9fX3N5c2NhbGxfb3BlbmF0LFxcbiAgICAgIF9hYm9ydF9qczogX19hYm9ydF9qcyxcXG4gICAgICBfZW1zY3JpcHRlbl9ydW50aW1lX2tlZXBhbGl2ZV9jbGVhcjogX19lbXNjcmlwdGVuX3J1bnRpbWVfa2VlcGFsaXZlX2NsZWFyLFxcbiAgICAgIF9tbWFwX2pzOiBfX21tYXBfanMsXFxuICAgICAgX211bm1hcF9qczogX19tdW5tYXBfanMsXFxuICAgICAgX3NldGl0aW1lcl9qczogX19zZXRpdGltZXJfanMsXFxuICAgICAgZW1zY3JpcHRlbl9kYXRlX25vdzogX2Vtc2NyaXB0ZW5fZGF0ZV9ub3csXFxuICAgICAgZW1zY3JpcHRlbl9yZXNpemVfaGVhcDogX2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXAsXFxuICAgICAgZW1zY3JpcHRlbl9ydW5fc2NyaXB0X2ludDogX2Vtc2NyaXB0ZW5fcnVuX3NjcmlwdF9pbnQsXFxuICAgICAgZW1zY3JpcHRlbl9zbGVlcDogX2Vtc2NyaXB0ZW5fc2xlZXAsXFxuICAgICAgZXhpdDogX2V4aXQsXFxuICAgICAgZmRfY2xvc2U6IF9mZF9jbG9zZSxcXG4gICAgICBmZF9yZWFkOiBfZmRfcmVhZCxcXG4gICAgICBmZF9zZWVrOiBfZmRfc2VlayxcXG4gICAgICBmZF93cml0ZTogX2ZkX3dyaXRlLFxcbiAgICAgIHByb2NfZXhpdDogX3Byb2NfZXhpdCxcXG4gICAgfTtcXG4gICAgdmFyIHdhc21FeHBvcnRzID0gYXdhaXQgY3JlYXRlV2FzbSgpO1xcbiAgICB2YXIgX19fd2FzbV9jYWxsX2N0b3JzID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcIl9fd2FzbV9jYWxsX2N0b3JzXCIsIDApO1xcbiAgICB2YXIgX21hbGxvYyA9IChNb2R1bGVbXCJfbWFsbG9jXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcIm1hbGxvY1wiLCAxKSk7XFxuICAgIHZhciBfZnJlZSA9IChNb2R1bGVbXCJfZnJlZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJmcmVlXCIsIDEpKTtcXG4gICAgdmFyIF9zZW5kX2ludF90b19DID0gKE1vZHVsZVtcIl9zZW5kX2ludF90b19DXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcXG4gICAgICBcInNlbmRfaW50X3RvX0NcIixcXG4gICAgICAxLFxcbiAgICApKTtcXG4gICAgdmFyIF9zZW5kX2Zsb2F0X3RvX0MgPSAoTW9kdWxlW1wiX3NlbmRfZmxvYXRfdG9fQ1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXFxuICAgICAgXCJzZW5kX2Zsb2F0X3RvX0NcIixcXG4gICAgICAxLFxcbiAgICApKTtcXG4gICAgdmFyIF9zZW5kX2RvdWJsZV90b19DID0gKE1vZHVsZVtcIl9zZW5kX2RvdWJsZV90b19DXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcXG4gICAgICBcInNlbmRfZG91YmxlX3RvX0NcIixcXG4gICAgICAxLFxcbiAgICApKTtcXG4gICAgdmFyIF9zZW5kX2NoYXJfdG9fQyA9IChNb2R1bGVbXCJfc2VuZF9jaGFyX3RvX0NcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFxcbiAgICAgIFwic2VuZF9jaGFyX3RvX0NcIixcXG4gICAgICAxLFxcbiAgICApKTtcXG4gICAgdmFyIF9zZW5kX3N0cmluZ190b19DID0gKE1vZHVsZVtcIl9zZW5kX3N0cmluZ190b19DXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcXG4gICAgICBcInNlbmRfc3RyaW5nX3RvX0NcIixcXG4gICAgICAxLFxcbiAgICApKTtcXG4gICAgdmFyIF9yZWFudWRhcl9lamVjdWNpb24gPSAoTW9kdWxlW1wiX3JlYW51ZGFyX2VqZWN1Y2lvblwiXSA9XFxuICAgICAgY3JlYXRlRXhwb3J0V3JhcHBlcihcInJlYW51ZGFyX2VqZWN1Y2lvblwiLCAxKSk7XFxuICAgIHZhciBfc3RyZXJyb3IgPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwic3RyZXJyb3JcIiwgMSk7XFxuICAgIHZhciBfZmZsdXNoID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImZmbHVzaFwiLCAxKTtcXG4gICAgdmFyIF9tYWluID0gKE1vZHVsZVtcIl9tYWluXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcIl9fbWFpbl9hcmdjX2FyZ3ZcIiwgMikpO1xcbiAgICB2YXIgX2Vtc2NyaXB0ZW5fYnVpbHRpbl9tZW1hbGlnbiA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXFxuICAgICAgXCJlbXNjcmlwdGVuX2J1aWx0aW5fbWVtYWxpZ25cIixcXG4gICAgICAyLFxcbiAgICApO1xcbiAgICB2YXIgX19lbXNjcmlwdGVuX3RpbWVvdXQgPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiX2Vtc2NyaXB0ZW5fdGltZW91dFwiLCAyKTtcXG4gICAgdmFyIF9lbXNjcmlwdGVuX3N0YWNrX2luaXQgPSB3YXNtRXhwb3J0c1tcImVtc2NyaXB0ZW5fc3RhY2tfaW5pdFwiXTtcXG4gICAgdmFyIF9lbXNjcmlwdGVuX3N0YWNrX2dldF9mcmVlID0gd2FzbUV4cG9ydHNbXCJlbXNjcmlwdGVuX3N0YWNrX2dldF9mcmVlXCJdO1xcbiAgICB2YXIgX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2Jhc2UgPSB3YXNtRXhwb3J0c1tcImVtc2NyaXB0ZW5fc3RhY2tfZ2V0X2Jhc2VcIl07XFxuICAgIHZhciBfZW1zY3JpcHRlbl9zdGFja19nZXRfZW5kID0gd2FzbUV4cG9ydHNbXCJlbXNjcmlwdGVuX3N0YWNrX2dldF9lbmRcIl07XFxuICAgIHZhciBfX2Vtc2NyaXB0ZW5fc3RhY2tfcmVzdG9yZSA9IHdhc21FeHBvcnRzW1wiX2Vtc2NyaXB0ZW5fc3RhY2tfcmVzdG9yZVwiXTtcXG4gICAgdmFyIF9fZW1zY3JpcHRlbl9zdGFja19hbGxvYyA9IHdhc21FeHBvcnRzW1wiX2Vtc2NyaXB0ZW5fc3RhY2tfYWxsb2NcIl07XFxuICAgIHZhciBfZW1zY3JpcHRlbl9zdGFja19nZXRfY3VycmVudCA9XFxuICAgICAgd2FzbUV4cG9ydHNbXCJlbXNjcmlwdGVuX3N0YWNrX2dldF9jdXJyZW50XCJdO1xcbiAgICB2YXIgX19fY3hhX2luY3JlbWVudF9leGNlcHRpb25fcmVmY291bnQgPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFxcbiAgICAgIFwiX19jeGFfaW5jcmVtZW50X2V4Y2VwdGlvbl9yZWZjb3VudFwiLFxcbiAgICAgIDEsXFxuICAgICk7XFxuICAgIHZhciBkeW5DYWxsX2pqID0gKE1vZHVsZVtcImR5bkNhbGxfampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFxcbiAgICAgIFwiZHluQ2FsbF9qalwiLFxcbiAgICAgIDIsXFxuICAgICkpO1xcbiAgICB2YXIgZHluQ2FsbF9qampqID0gKE1vZHVsZVtcImR5bkNhbGxfampqalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXFxuICAgICAgXCJkeW5DYWxsX2pqampcIixcXG4gICAgICA0LFxcbiAgICApKTtcXG4gICAgdmFyIGR5bkNhbGxfdmpqID0gKE1vZHVsZVtcImR5bkNhbGxfdmpqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcXG4gICAgICBcImR5bkNhbGxfdmpqXCIsXFxuICAgICAgMyxcXG4gICAgKSk7XFxuICAgIHZhciBkeW5DYWxsX2lqamogPSAoTW9kdWxlW1wiZHluQ2FsbF9pampqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcXG4gICAgICBcImR5bkNhbGxfaWpqalwiLFxcbiAgICAgIDQsXFxuICAgICkpO1xcbiAgICB2YXIgZHluQ2FsbF9pamlpID0gKE1vZHVsZVtcImR5bkNhbGxfaWppaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXFxuICAgICAgXCJkeW5DYWxsX2lqaWlcIixcXG4gICAgICA0LFxcbiAgICApKTtcXG4gICAgdmFyIGR5bkNhbGxfaWogPSAoTW9kdWxlW1wiZHluQ2FsbF9palwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXFxuICAgICAgXCJkeW5DYWxsX2lqXCIsXFxuICAgICAgMixcXG4gICAgKSk7XFxuICAgIHZhciBkeW5DYWxsX2pqaWkgPSAoTW9kdWxlW1wiZHluQ2FsbF9qamlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcXG4gICAgICBcImR5bkNhbGxfamppaVwiLFxcbiAgICAgIDQsXFxuICAgICkpO1xcbiAgICB2YXIgZHluQ2FsbF9qamppID0gKE1vZHVsZVtcImR5bkNhbGxfampqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXFxuICAgICAgXCJkeW5DYWxsX2pqamlcIixcXG4gICAgICA0LFxcbiAgICApKTtcXG4gICAgdmFyIGR5bkNhbGxfaWpkaWlpaSA9IChNb2R1bGVbXCJkeW5DYWxsX2lqZGlpaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFxcbiAgICAgIFwiZHluQ2FsbF9pamRpaWlpXCIsXFxuICAgICAgNyxcXG4gICAgKSk7XFxuICAgIHZhciBkeW5DYWxsX3YgPSAoTW9kdWxlW1wiZHluQ2FsbF92XCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdlwiLCAxKSk7XFxuICAgIHZhciBkeW5DYWxsX3ZpID0gKE1vZHVsZVtcImR5bkNhbGxfdmlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFxcbiAgICAgIFwiZHluQ2FsbF92aVwiLFxcbiAgICAgIDIsXFxuICAgICkpO1xcbiAgICB2YXIgX2FzeW5jaWZ5X3N0YXJ0X3Vud2luZCA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXFxuICAgICAgXCJhc3luY2lmeV9zdGFydF91bndpbmRcIixcXG4gICAgICAxLFxcbiAgICApO1xcbiAgICB2YXIgX2FzeW5jaWZ5X3N0b3BfdW53aW5kID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImFzeW5jaWZ5X3N0b3BfdW53aW5kXCIsIDApO1xcbiAgICB2YXIgX2FzeW5jaWZ5X3N0YXJ0X3Jld2luZCA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXFxuICAgICAgXCJhc3luY2lmeV9zdGFydF9yZXdpbmRcIixcXG4gICAgICAxLFxcbiAgICApO1xcbiAgICB2YXIgX2FzeW5jaWZ5X3N0b3BfcmV3aW5kID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImFzeW5jaWZ5X3N0b3BfcmV3aW5kXCIsIDApO1xcbiAgICBmdW5jdGlvbiBhcHBseVNpZ25hdHVyZUNvbnZlcnNpb25zKHdhc21FeHBvcnRzKSB7XFxuICAgICAgd2FzbUV4cG9ydHMgPSBPYmplY3QuYXNzaWduKHt9LCB3YXNtRXhwb3J0cyk7XFxuICAgICAgdmFyIG1ha2VXcmFwcGVyX3BwID0gKGYpID0+IChhMCkgPT4gTnVtYmVyKGYoQmlnSW50KGEwKSkpO1xcbiAgICAgIHZhciBtYWtlV3JhcHBlcl9fcCA9IChmKSA9PiAoYTApID0+IGYoQmlnSW50KGEwKSk7XFxuICAgICAgdmFyIG1ha2VXcmFwcGVyX3BfID0gKGYpID0+IChhMCkgPT4gTnVtYmVyKGYoYTApKTtcXG4gICAgICB2YXIgbWFrZVdyYXBwZXJfX19QUCA9IChmKSA9PiAoYTAsIGExLCBhMikgPT5cXG4gICAgICAgIGYoYTAsIEJpZ0ludChhMSA/IGExIDogMCksIEJpZ0ludChhMiA/IGEyIDogMCkpO1xcbiAgICAgIHZhciBtYWtlV3JhcHBlcl9wcHAgPSAoZikgPT4gKGEwLCBhMSkgPT5cXG4gICAgICAgIE51bWJlcihmKEJpZ0ludChhMCksIEJpZ0ludChhMSkpKTtcXG4gICAgICB2YXIgbWFrZVdyYXBwZXJfcCA9IChmKSA9PiAoKSA9PiBOdW1iZXIoZigpKTtcXG4gICAgICB2YXIgbWFrZVdyYXBwZXJfX3BfID0gKGYpID0+IChhMCwgYTEpID0+IGYoQmlnSW50KGEwKSwgYTEpO1xcbiAgICAgIHZhciBtYWtlV3JhcHBlcl9fcF9fXyA9IChmKSA9PiAoYTAsIGExLCBhMiwgYTMpID0+XFxuICAgICAgICBmKEJpZ0ludChhMCksIGExLCBhMiwgYTMpO1xcbiAgICAgIHZhciBtYWtlV3JhcHBlcl9fcF9fID0gKGYpID0+IChhMCwgYTEsIGEyKSA9PiBmKEJpZ0ludChhMCksIGExLCBhMik7XFxuICAgICAgdmFyIG1ha2VXcmFwcGVyX19wX19fX19fID0gKGYpID0+IChhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNikgPT5cXG4gICAgICAgIGYoQmlnSW50KGEwKSwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNik7XFxuICAgICAgd2FzbUV4cG9ydHNbXCJtYWxsb2NcIl0gPSBtYWtlV3JhcHBlcl9wcCh3YXNtRXhwb3J0c1tcIm1hbGxvY1wiXSk7XFxuICAgICAgd2FzbUV4cG9ydHNbXCJmcmVlXCJdID0gbWFrZVdyYXBwZXJfX3Aod2FzbUV4cG9ydHNbXCJmcmVlXCJdKTtcXG4gICAgICB3YXNtRXhwb3J0c1tcInN0cmVycm9yXCJdID0gbWFrZVdyYXBwZXJfcF8od2FzbUV4cG9ydHNbXCJzdHJlcnJvclwiXSk7XFxuICAgICAgd2FzbUV4cG9ydHNbXCJmZmx1c2hcIl0gPSBtYWtlV3JhcHBlcl9fcCh3YXNtRXhwb3J0c1tcImZmbHVzaFwiXSk7XFxuICAgICAgd2FzbUV4cG9ydHNbXCJfX21haW5fYXJnY19hcmd2XCJdID0gbWFrZVdyYXBwZXJfX19QUChcXG4gICAgICAgIHdhc21FeHBvcnRzW1wiX19tYWluX2FyZ2NfYXJndlwiXSxcXG4gICAgICApO1xcbiAgICAgIHdhc21FeHBvcnRzW1wiZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduXCJdID0gbWFrZVdyYXBwZXJfcHBwKFxcbiAgICAgICAgd2FzbUV4cG9ydHNbXCJlbXNjcmlwdGVuX2J1aWx0aW5fbWVtYWxpZ25cIl0sXFxuICAgICAgKTtcXG4gICAgICB3YXNtRXhwb3J0c1tcImVtc2NyaXB0ZW5fc3RhY2tfZ2V0X2Jhc2VcIl0gPSBtYWtlV3JhcHBlcl9wKFxcbiAgICAgICAgd2FzbUV4cG9ydHNbXCJlbXNjcmlwdGVuX3N0YWNrX2dldF9iYXNlXCJdLFxcbiAgICAgICk7XFxuICAgICAgd2FzbUV4cG9ydHNbXCJlbXNjcmlwdGVuX3N0YWNrX2dldF9lbmRcIl0gPSBtYWtlV3JhcHBlcl9wKFxcbiAgICAgICAgd2FzbUV4cG9ydHNbXCJlbXNjcmlwdGVuX3N0YWNrX2dldF9lbmRcIl0sXFxuICAgICAgKTtcXG4gICAgICB3YXNtRXhwb3J0c1tcIl9lbXNjcmlwdGVuX3N0YWNrX3Jlc3RvcmVcIl0gPSBtYWtlV3JhcHBlcl9fcChcXG4gICAgICAgIHdhc21FeHBvcnRzW1wiX2Vtc2NyaXB0ZW5fc3RhY2tfcmVzdG9yZVwiXSxcXG4gICAgICApO1xcbiAgICAgIHdhc21FeHBvcnRzW1wiX2Vtc2NyaXB0ZW5fc3RhY2tfYWxsb2NcIl0gPSBtYWtlV3JhcHBlcl9wcChcXG4gICAgICAgIHdhc21FeHBvcnRzW1wiX2Vtc2NyaXB0ZW5fc3RhY2tfYWxsb2NcIl0sXFxuICAgICAgKTtcXG4gICAgICB3YXNtRXhwb3J0c1tcImVtc2NyaXB0ZW5fc3RhY2tfZ2V0X2N1cnJlbnRcIl0gPSBtYWtlV3JhcHBlcl9wKFxcbiAgICAgICAgd2FzbUV4cG9ydHNbXCJlbXNjcmlwdGVuX3N0YWNrX2dldF9jdXJyZW50XCJdLFxcbiAgICAgICk7XFxuICAgICAgd2FzbUV4cG9ydHNbXCJfX2N4YV9pbmNyZW1lbnRfZXhjZXB0aW9uX3JlZmNvdW50XCJdID0gbWFrZVdyYXBwZXJfX3AoXFxuICAgICAgICB3YXNtRXhwb3J0c1tcIl9fY3hhX2luY3JlbWVudF9leGNlcHRpb25fcmVmY291bnRcIl0sXFxuICAgICAgKTtcXG4gICAgICB3YXNtRXhwb3J0c1tcImR5bkNhbGxfampcIl0gPSBtYWtlV3JhcHBlcl9fcF8od2FzbUV4cG9ydHNbXCJkeW5DYWxsX2pqXCJdKTtcXG4gICAgICB3YXNtRXhwb3J0c1tcImR5bkNhbGxfampqalwiXSA9IG1ha2VXcmFwcGVyX19wX19fKFxcbiAgICAgICAgd2FzbUV4cG9ydHNbXCJkeW5DYWxsX2pqampcIl0sXFxuICAgICAgKTtcXG4gICAgICB3YXNtRXhwb3J0c1tcImR5bkNhbGxfdmpqXCJdID0gbWFrZVdyYXBwZXJfX3BfXyh3YXNtRXhwb3J0c1tcImR5bkNhbGxfdmpqXCJdKTtcXG4gICAgICB3YXNtRXhwb3J0c1tcImR5bkNhbGxfaWpqalwiXSA9IG1ha2VXcmFwcGVyX19wX19fKFxcbiAgICAgICAgd2FzbUV4cG9ydHNbXCJkeW5DYWxsX2lqampcIl0sXFxuICAgICAgKTtcXG4gICAgICB3YXNtRXhwb3J0c1tcImR5bkNhbGxfaWppaVwiXSA9IG1ha2VXcmFwcGVyX19wX19fKFxcbiAgICAgICAgd2FzbUV4cG9ydHNbXCJkeW5DYWxsX2lqaWlcIl0sXFxuICAgICAgKTtcXG4gICAgICB3YXNtRXhwb3J0c1tcImR5bkNhbGxfaWpcIl0gPSBtYWtlV3JhcHBlcl9fcF8od2FzbUV4cG9ydHNbXCJkeW5DYWxsX2lqXCJdKTtcXG4gICAgICB3YXNtRXhwb3J0c1tcImR5bkNhbGxfamppaVwiXSA9IG1ha2VXcmFwcGVyX19wX19fKFxcbiAgICAgICAgd2FzbUV4cG9ydHNbXCJkeW5DYWxsX2pqaWlcIl0sXFxuICAgICAgKTtcXG4gICAgICB3YXNtRXhwb3J0c1tcImR5bkNhbGxfampqaVwiXSA9IG1ha2VXcmFwcGVyX19wX19fKFxcbiAgICAgICAgd2FzbUV4cG9ydHNbXCJkeW5DYWxsX2pqamlcIl0sXFxuICAgICAgKTtcXG4gICAgICB3YXNtRXhwb3J0c1tcImR5bkNhbGxfaWpkaWlpaVwiXSA9IG1ha2VXcmFwcGVyX19wX19fX19fKFxcbiAgICAgICAgd2FzbUV4cG9ydHNbXCJkeW5DYWxsX2lqZGlpaWlcIl0sXFxuICAgICAgKTtcXG4gICAgICB3YXNtRXhwb3J0c1tcImR5bkNhbGxfdlwiXSA9IG1ha2VXcmFwcGVyX19wKHdhc21FeHBvcnRzW1wiZHluQ2FsbF92XCJdKTtcXG4gICAgICB3YXNtRXhwb3J0c1tcImR5bkNhbGxfdmlcIl0gPSBtYWtlV3JhcHBlcl9fcF8od2FzbUV4cG9ydHNbXCJkeW5DYWxsX3ZpXCJdKTtcXG4gICAgICB3YXNtRXhwb3J0c1tcImFzeW5jaWZ5X3N0YXJ0X3Vud2luZFwiXSA9IG1ha2VXcmFwcGVyX19wKFxcbiAgICAgICAgd2FzbUV4cG9ydHNbXCJhc3luY2lmeV9zdGFydF91bndpbmRcIl0sXFxuICAgICAgKTtcXG4gICAgICB3YXNtRXhwb3J0c1tcImFzeW5jaWZ5X3N0YXJ0X3Jld2luZFwiXSA9IG1ha2VXcmFwcGVyX19wKFxcbiAgICAgICAgd2FzbUV4cG9ydHNbXCJhc3luY2lmeV9zdGFydF9yZXdpbmRcIl0sXFxuICAgICAgKTtcXG4gICAgICByZXR1cm4gd2FzbUV4cG9ydHM7XFxuICAgIH1cXG4gICAgTW9kdWxlW1wicnVuXCJdID0gcnVuO1xcbiAgICBNb2R1bGVbXCJjYWxsTWFpblwiXSA9IGNhbGxNYWluO1xcbiAgICBNb2R1bGVbXCJjY2FsbFwiXSA9IGNjYWxsO1xcbiAgICBNb2R1bGVbXCJzdHJpbmdUb1VURjhcIl0gPSBzdHJpbmdUb1VURjg7XFxuICAgIE1vZHVsZVtcImxlbmd0aEJ5dGVzVVRGOFwiXSA9IGxlbmd0aEJ5dGVzVVRGODtcXG4gICAgdmFyIG1pc3NpbmdMaWJyYXJ5U3ltYm9scyA9IFtcXG4gICAgICBcIndyaXRlSTUzVG9JNjRcIixcXG4gICAgICBcIndyaXRlSTUzVG9JNjRDbGFtcGVkXCIsXFxuICAgICAgXCJ3cml0ZUk1M1RvSTY0U2lnbmFsaW5nXCIsXFxuICAgICAgXCJ3cml0ZUk1M1RvVTY0Q2xhbXBlZFwiLFxcbiAgICAgIFwid3JpdGVJNTNUb1U2NFNpZ25hbGluZ1wiLFxcbiAgICAgIFwicmVhZEk1M0Zyb21JNjRcIixcXG4gICAgICBcInJlYWRJNTNGcm9tVTY0XCIsXFxuICAgICAgXCJjb252ZXJ0STMyUGFpclRvSTUzXCIsXFxuICAgICAgXCJjb252ZXJ0STMyUGFpclRvSTUzQ2hlY2tlZFwiLFxcbiAgICAgIFwiY29udmVydFUzMlBhaXJUb0k1M1wiLFxcbiAgICAgIFwiZ2V0VGVtcFJldDBcIixcXG4gICAgICBcInNldFRlbXBSZXQwXCIsXFxuICAgICAgXCJpbmV0UHRvbjRcIixcXG4gICAgICBcImluZXROdG9wNFwiLFxcbiAgICAgIFwiaW5ldFB0b242XCIsXFxuICAgICAgXCJpbmV0TnRvcDZcIixcXG4gICAgICBcInJlYWRTb2NrYWRkclwiLFxcbiAgICAgIFwid3JpdGVTb2NrYWRkclwiLFxcbiAgICAgIFwiZW1zY3JpcHRlbkxvZ1wiLFxcbiAgICAgIFwicmVhZEVtQXNtQXJnc1wiLFxcbiAgICAgIFwianN0b2lfcVwiLFxcbiAgICAgIFwiZ2V0RXhlY3V0YWJsZU5hbWVcIixcXG4gICAgICBcImxpc3Rlbk9uY2VcIixcXG4gICAgICBcImF1dG9SZXN1bWVBdWRpb0NvbnRleHRcIixcXG4gICAgICBcImR5bkNhbGxMZWdhY3lcIixcXG4gICAgICBcImdldER5bkNhbGxlclwiLFxcbiAgICAgIFwiZHluQ2FsbFwiLFxcbiAgICAgIFwiYXNtanNNYW5nbGVcIixcXG4gICAgICBcIkhhbmRsZUFsbG9jYXRvclwiLFxcbiAgICAgIFwiZ2V0TmF0aXZlVHlwZVNpemVcIixcXG4gICAgICBcImFkZE9uSW5pdFwiLFxcbiAgICAgIFwiYWRkT25Qb3N0Q3RvclwiLFxcbiAgICAgIFwiYWRkT25QcmVNYWluXCIsXFxuICAgICAgXCJhZGRPbkV4aXRcIixcXG4gICAgICBcIlNUQUNLX1NJWkVcIixcXG4gICAgICBcIlNUQUNLX0FMSUdOXCIsXFxuICAgICAgXCJQT0lOVEVSX1NJWkVcIixcXG4gICAgICBcIkFTU0VSVElPTlNcIixcXG4gICAgICBcImN3cmFwXCIsXFxuICAgICAgXCJ1bGViMTI4RW5jb2RlXCIsXFxuICAgICAgXCJnZW5lcmF0ZUZ1bmNUeXBlXCIsXFxuICAgICAgXCJjb252ZXJ0SnNGdW5jdGlvblRvV2FzbVwiLFxcbiAgICAgIFwiZ2V0RW1wdHlUYWJsZVNsb3RcIixcXG4gICAgICBcInVwZGF0ZVRhYmxlTWFwXCIsXFxuICAgICAgXCJnZXRGdW5jdGlvbkFkZHJlc3NcIixcXG4gICAgICBcImFkZEZ1bmN0aW9uXCIsXFxuICAgICAgXCJyZW1vdmVGdW5jdGlvblwiLFxcbiAgICAgIFwicmVhbGx5TmVnYXRpdmVcIixcXG4gICAgICBcInVuU2lnblwiLFxcbiAgICAgIFwic3RyTGVuXCIsXFxuICAgICAgXCJyZVNpZ25cIixcXG4gICAgICBcImZvcm1hdFN0cmluZ1wiLFxcbiAgICAgIFwiaW50QXJyYXlUb1N0cmluZ1wiLFxcbiAgICAgIFwiQXNjaWlUb1N0cmluZ1wiLFxcbiAgICAgIFwic3RyaW5nVG9Bc2NpaVwiLFxcbiAgICAgIFwiVVRGMTZUb1N0cmluZ1wiLFxcbiAgICAgIFwic3RyaW5nVG9VVEYxNlwiLFxcbiAgICAgIFwibGVuZ3RoQnl0ZXNVVEYxNlwiLFxcbiAgICAgIFwiVVRGMzJUb1N0cmluZ1wiLFxcbiAgICAgIFwic3RyaW5nVG9VVEYzMlwiLFxcbiAgICAgIFwibGVuZ3RoQnl0ZXNVVEYzMlwiLFxcbiAgICAgIFwic3RyaW5nVG9OZXdVVEY4XCIsXFxuICAgICAgXCJyZWdpc3RlcktleUV2ZW50Q2FsbGJhY2tcIixcXG4gICAgICBcIm1heWJlQ1N0cmluZ1RvSnNTdHJpbmdcIixcXG4gICAgICBcImZpbmRFdmVudFRhcmdldFwiLFxcbiAgICAgIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIsXFxuICAgICAgXCJmaWxsTW91c2VFdmVudERhdGFcIixcXG4gICAgICBcInJlZ2lzdGVyTW91c2VFdmVudENhbGxiYWNrXCIsXFxuICAgICAgXCJyZWdpc3RlcldoZWVsRXZlbnRDYWxsYmFja1wiLFxcbiAgICAgIFwicmVnaXN0ZXJVaUV2ZW50Q2FsbGJhY2tcIixcXG4gICAgICBcInJlZ2lzdGVyRm9jdXNFdmVudENhbGxiYWNrXCIsXFxuICAgICAgXCJmaWxsRGV2aWNlT3JpZW50YXRpb25FdmVudERhdGFcIixcXG4gICAgICBcInJlZ2lzdGVyRGV2aWNlT3JpZW50YXRpb25FdmVudENhbGxiYWNrXCIsXFxuICAgICAgXCJmaWxsRGV2aWNlTW90aW9uRXZlbnREYXRhXCIsXFxuICAgICAgXCJyZWdpc3RlckRldmljZU1vdGlvbkV2ZW50Q2FsbGJhY2tcIixcXG4gICAgICBcInNjcmVlbk9yaWVudGF0aW9uXCIsXFxuICAgICAgXCJmaWxsT3JpZW50YXRpb25DaGFuZ2VFdmVudERhdGFcIixcXG4gICAgICBcInJlZ2lzdGVyT3JpZW50YXRpb25DaGFuZ2VFdmVudENhbGxiYWNrXCIsXFxuICAgICAgXCJmaWxsRnVsbHNjcmVlbkNoYW5nZUV2ZW50RGF0YVwiLFxcbiAgICAgIFwicmVnaXN0ZXJGdWxsc2NyZWVuQ2hhbmdlRXZlbnRDYWxsYmFja1wiLFxcbiAgICAgIFwiSlNFdmVudHNfcmVxdWVzdEZ1bGxzY3JlZW5cIixcXG4gICAgICBcIkpTRXZlbnRzX3Jlc2l6ZUNhbnZhc0ZvckZ1bGxzY3JlZW5cIixcXG4gICAgICBcInJlZ2lzdGVyUmVzdG9yZU9sZFN0eWxlXCIsXFxuICAgICAgXCJoaWRlRXZlcnl0aGluZ0V4Y2VwdEdpdmVuRWxlbWVudFwiLFxcbiAgICAgIFwicmVzdG9yZUhpZGRlbkVsZW1lbnRzXCIsXFxuICAgICAgXCJzZXRMZXR0ZXJib3hcIixcXG4gICAgICBcInNvZnRGdWxsc2NyZWVuUmVzaXplV2ViR0xSZW5kZXJUYXJnZXRcIixcXG4gICAgICBcImRvUmVxdWVzdEZ1bGxzY3JlZW5cIixcXG4gICAgICBcImZpbGxQb2ludGVybG9ja0NoYW5nZUV2ZW50RGF0YVwiLFxcbiAgICAgIFwicmVnaXN0ZXJQb2ludGVybG9ja0NoYW5nZUV2ZW50Q2FsbGJhY2tcIixcXG4gICAgICBcInJlZ2lzdGVyUG9pbnRlcmxvY2tFcnJvckV2ZW50Q2FsbGJhY2tcIixcXG4gICAgICBcInJlcXVlc3RQb2ludGVyTG9ja1wiLFxcbiAgICAgIFwiZmlsbFZpc2liaWxpdHlDaGFuZ2VFdmVudERhdGFcIixcXG4gICAgICBcInJlZ2lzdGVyVmlzaWJpbGl0eUNoYW5nZUV2ZW50Q2FsbGJhY2tcIixcXG4gICAgICBcInJlZ2lzdGVyVG91Y2hFdmVudENhbGxiYWNrXCIsXFxuICAgICAgXCJmaWxsR2FtZXBhZEV2ZW50RGF0YVwiLFxcbiAgICAgIFwicmVnaXN0ZXJHYW1lcGFkRXZlbnRDYWxsYmFja1wiLFxcbiAgICAgIFwicmVnaXN0ZXJCZWZvcmVVbmxvYWRFdmVudENhbGxiYWNrXCIsXFxuICAgICAgXCJmaWxsQmF0dGVyeUV2ZW50RGF0YVwiLFxcbiAgICAgIFwiYmF0dGVyeVwiLFxcbiAgICAgIFwicmVnaXN0ZXJCYXR0ZXJ5RXZlbnRDYWxsYmFja1wiLFxcbiAgICAgIFwic2V0Q2FudmFzRWxlbWVudFNpemVcIixcXG4gICAgICBcImdldENhbnZhc0VsZW1lbnRTaXplXCIsXFxuICAgICAgXCJqc1N0YWNrVHJhY2VcIixcXG4gICAgICBcImdldENhbGxzdGFja1wiLFxcbiAgICAgIFwiY29udmVydFBDdG9Tb3VyY2VMb2NhdGlvblwiLFxcbiAgICAgIFwiZ2V0RW52U3RyaW5nc1wiLFxcbiAgICAgIFwiY2hlY2tXYXNpQ2xvY2tcIixcXG4gICAgICBcIndhc2lSaWdodHNUb011c2xPRmxhZ3NcIixcXG4gICAgICBcIndhc2lPRmxhZ3NUb011c2xPRmxhZ3NcIixcXG4gICAgICBcInNldEltbWVkaWF0ZVdyYXBwZWRcIixcXG4gICAgICBcInNhZmVSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIixcXG4gICAgICBcImNsZWFySW1tZWRpYXRlV3JhcHBlZFwiLFxcbiAgICAgIFwicmVnaXN0ZXJQb3N0TWFpbkxvb3BcIixcXG4gICAgICBcInJlZ2lzdGVyUHJlTWFpbkxvb3BcIixcXG4gICAgICBcImdldFByb21pc2VcIixcXG4gICAgICBcIm1ha2VQcm9taXNlXCIsXFxuICAgICAgXCJpZHNUb1Byb21pc2VzXCIsXFxuICAgICAgXCJtYWtlUHJvbWlzZUNhbGxiYWNrXCIsXFxuICAgICAgXCJFeGNlcHRpb25JbmZvXCIsXFxuICAgICAgXCJmaW5kTWF0Y2hpbmdDYXRjaFwiLFxcbiAgICAgIFwiQnJvd3Nlcl9hc3luY1ByZXBhcmVEYXRhQ291bnRlclwiLFxcbiAgICAgIFwiaXNMZWFwWWVhclwiLFxcbiAgICAgIFwieWRheUZyb21EYXRlXCIsXFxuICAgICAgXCJhcnJheVN1bVwiLFxcbiAgICAgIFwiYWRkRGF5c1wiLFxcbiAgICAgIFwiZ2V0U29ja2V0RnJvbUZEXCIsXFxuICAgICAgXCJnZXRTb2NrZXRBZGRyZXNzXCIsXFxuICAgICAgXCJGU191bmxpbmtcIixcXG4gICAgICBcIkZTX21rZGlyVHJlZVwiLFxcbiAgICAgIFwiX3NldE5ldHdvcmtDYWxsYmFja1wiLFxcbiAgICAgIFwiaGVhcE9iamVjdEZvcldlYkdMVHlwZVwiLFxcbiAgICAgIFwidG9UeXBlZEFycmF5SW5kZXhcIixcXG4gICAgICBcIndlYmdsX2VuYWJsZV9BTkdMRV9pbnN0YW5jZWRfYXJyYXlzXCIsXFxuICAgICAgXCJ3ZWJnbF9lbmFibGVfT0VTX3ZlcnRleF9hcnJheV9vYmplY3RcIixcXG4gICAgICBcIndlYmdsX2VuYWJsZV9XRUJHTF9kcmF3X2J1ZmZlcnNcIixcXG4gICAgICBcIndlYmdsX2VuYWJsZV9XRUJHTF9tdWx0aV9kcmF3XCIsXFxuICAgICAgXCJ3ZWJnbF9lbmFibGVfRVhUX3BvbHlnb25fb2Zmc2V0X2NsYW1wXCIsXFxuICAgICAgXCJ3ZWJnbF9lbmFibGVfRVhUX2NsaXBfY29udHJvbFwiLFxcbiAgICAgIFwid2ViZ2xfZW5hYmxlX1dFQkdMX3BvbHlnb25fbW9kZVwiLFxcbiAgICAgIFwiZW1zY3JpcHRlbldlYkdMR2V0XCIsXFxuICAgICAgXCJjb21wdXRlVW5wYWNrQWxpZ25lZEltYWdlU2l6ZVwiLFxcbiAgICAgIFwiY29sb3JDaGFubmVsc0luR2xUZXh0dXJlRm9ybWF0XCIsXFxuICAgICAgXCJlbXNjcmlwdGVuV2ViR0xHZXRUZXhQaXhlbERhdGFcIixcXG4gICAgICBcImVtc2NyaXB0ZW5XZWJHTEdldFVuaWZvcm1cIixcXG4gICAgICBcIndlYmdsR2V0VW5pZm9ybUxvY2F0aW9uXCIsXFxuICAgICAgXCJ3ZWJnbFByZXBhcmVVbmlmb3JtTG9jYXRpb25zQmVmb3JlRmlyc3RVc2VcIixcXG4gICAgICBcIndlYmdsR2V0TGVmdEJyYWNlUG9zXCIsXFxuICAgICAgXCJlbXNjcmlwdGVuV2ViR0xHZXRWZXJ0ZXhBdHRyaWJcIixcXG4gICAgICBcIl9fZ2xHZXRBY3RpdmVBdHRyaWJPclVuaWZvcm1cIixcXG4gICAgICBcIndyaXRlR0xBcnJheVwiLFxcbiAgICAgIFwicmVnaXN0ZXJXZWJHbEV2ZW50Q2FsbGJhY2tcIixcXG4gICAgICBcIkFMTE9DX05PUk1BTFwiLFxcbiAgICAgIFwiQUxMT0NfU1RBQ0tcIixcXG4gICAgICBcImFsbG9jYXRlXCIsXFxuICAgICAgXCJ3cml0ZVN0cmluZ1RvTWVtb3J5XCIsXFxuICAgICAgXCJ3cml0ZUFzY2lpVG9NZW1vcnlcIixcXG4gICAgICBcInNldEVyck5vXCIsXFxuICAgICAgXCJkZW1hbmdsZVwiLFxcbiAgICAgIFwic3RhY2tUcmFjZVwiLFxcbiAgICBdO1xcbiAgICBtaXNzaW5nTGlicmFyeVN5bWJvbHMuZm9yRWFjaChtaXNzaW5nTGlicmFyeVN5bWJvbCk7XFxuICAgIHZhciB1bmV4cG9ydGVkU3ltYm9scyA9IFtcXG4gICAgICBcImFkZFJ1bkRlcGVuZGVuY3lcIixcXG4gICAgICBcInJlbW92ZVJ1bkRlcGVuZGVuY3lcIixcXG4gICAgICBcIm91dFwiLFxcbiAgICAgIFwiZXJyXCIsXFxuICAgICAgXCJhYm9ydFwiLFxcbiAgICAgIFwid2FzbU1lbW9yeVwiLFxcbiAgICAgIFwid2FzbUV4cG9ydHNcIixcXG4gICAgICBcIndyaXRlU3RhY2tDb29raWVcIixcXG4gICAgICBcImNoZWNrU3RhY2tDb29raWVcIixcXG4gICAgICBcIklOVDUzX01BWFwiLFxcbiAgICAgIFwiSU5UNTNfTUlOXCIsXFxuICAgICAgXCJiaWdpbnRUb0k1M0NoZWNrZWRcIixcXG4gICAgICBcInN0YWNrU2F2ZVwiLFxcbiAgICAgIFwic3RhY2tSZXN0b3JlXCIsXFxuICAgICAgXCJzdGFja0FsbG9jXCIsXFxuICAgICAgXCJwdHJUb1N0cmluZ1wiLFxcbiAgICAgIFwiemVyb01lbW9yeVwiLFxcbiAgICAgIFwiZXhpdEpTXCIsXFxuICAgICAgXCJnZXRIZWFwTWF4XCIsXFxuICAgICAgXCJncm93TWVtb3J5XCIsXFxuICAgICAgXCJFTlZcIixcXG4gICAgICBcIkVSUk5PX0NPREVTXCIsXFxuICAgICAgXCJzdHJFcnJvclwiLFxcbiAgICAgIFwiRE5TXCIsXFxuICAgICAgXCJQcm90b2NvbHNcIixcXG4gICAgICBcIlNvY2tldHNcIixcXG4gICAgICBcInRpbWVyc1wiLFxcbiAgICAgIFwid2Fybk9uY2VcIixcXG4gICAgICBcInJlYWRFbUFzbUFyZ3NBcnJheVwiLFxcbiAgICAgIFwianN0b2lfc1wiLFxcbiAgICAgIFwiaGFuZGxlRXhjZXB0aW9uXCIsXFxuICAgICAgXCJrZWVwUnVudGltZUFsaXZlXCIsXFxuICAgICAgXCJydW50aW1lS2VlcGFsaXZlUHVzaFwiLFxcbiAgICAgIFwicnVudGltZUtlZXBhbGl2ZVBvcFwiLFxcbiAgICAgIFwiY2FsbFVzZXJDYWxsYmFja1wiLFxcbiAgICAgIFwibWF5YmVFeGl0XCIsXFxuICAgICAgXCJhc3luY0xvYWRcIixcXG4gICAgICBcImFsaWduTWVtb3J5XCIsXFxuICAgICAgXCJtbWFwQWxsb2NcIixcXG4gICAgICBcIndhc21UYWJsZVwiLFxcbiAgICAgIFwibm9FeGl0UnVudGltZVwiLFxcbiAgICAgIFwiYWRkT25QcmVSdW5cIixcXG4gICAgICBcImFkZE9uUG9zdFJ1blwiLFxcbiAgICAgIFwiZ2V0Q0Z1bmNcIixcXG4gICAgICBcInNpZ1RvV2FzbVR5cGVzXCIsXFxuICAgICAgXCJmcmVlVGFibGVJbmRleGVzXCIsXFxuICAgICAgXCJmdW5jdGlvbnNJblRhYmxlTWFwXCIsXFxuICAgICAgXCJzZXRWYWx1ZVwiLFxcbiAgICAgIFwiZ2V0VmFsdWVcIixcXG4gICAgICBcIlBBVEhcIixcXG4gICAgICBcIlBBVEhfRlNcIixcXG4gICAgICBcIlVURjhEZWNvZGVyXCIsXFxuICAgICAgXCJVVEY4QXJyYXlUb1N0cmluZ1wiLFxcbiAgICAgIFwiVVRGOFRvU3RyaW5nXCIsXFxuICAgICAgXCJzdHJpbmdUb1VURjhBcnJheVwiLFxcbiAgICAgIFwiaW50QXJyYXlGcm9tU3RyaW5nXCIsXFxuICAgICAgXCJVVEYxNkRlY29kZXJcIixcXG4gICAgICBcInN0cmluZ1RvVVRGOE9uU3RhY2tcIixcXG4gICAgICBcIndyaXRlQXJyYXlUb01lbW9yeVwiLFxcbiAgICAgIFwiSlNFdmVudHNcIixcXG4gICAgICBcInNwZWNpYWxIVE1MVGFyZ2V0c1wiLFxcbiAgICAgIFwiZmluZENhbnZhc0V2ZW50VGFyZ2V0XCIsXFxuICAgICAgXCJjdXJyZW50RnVsbHNjcmVlblN0cmF0ZWd5XCIsXFxuICAgICAgXCJyZXN0b3JlT2xkV2luZG93ZWRTdHlsZVwiLFxcbiAgICAgIFwiVU5XSU5EX0NBQ0hFXCIsXFxuICAgICAgXCJFeGl0U3RhdHVzXCIsXFxuICAgICAgXCJkb1JlYWR2XCIsXFxuICAgICAgXCJkb1dyaXRldlwiLFxcbiAgICAgIFwiaW5pdFJhbmRvbUZpbGxcIixcXG4gICAgICBcInJhbmRvbUZpbGxcIixcXG4gICAgICBcInNhZmVTZXRUaW1lb3V0XCIsXFxuICAgICAgXCJlbVNldEltbWVkaWF0ZVwiLFxcbiAgICAgIFwiZW1DbGVhckltbWVkaWF0ZV9kZXBzXCIsXFxuICAgICAgXCJlbUNsZWFySW1tZWRpYXRlXCIsXFxuICAgICAgXCJwcm9taXNlTWFwXCIsXFxuICAgICAgXCJ1bmNhdWdodEV4Y2VwdGlvbkNvdW50XCIsXFxuICAgICAgXCJleGNlcHRpb25MYXN0XCIsXFxuICAgICAgXCJleGNlcHRpb25DYXVnaHRcIixcXG4gICAgICBcIkJyb3dzZXJcIixcXG4gICAgICBcImdldFByZWxvYWRlZEltYWdlRGF0YV9fZGF0YVwiLFxcbiAgICAgIFwid2dldFwiLFxcbiAgICAgIFwiTU9OVEhfREFZU19SRUdVTEFSXCIsXFxuICAgICAgXCJNT05USF9EQVlTX0xFQVBcIixcXG4gICAgICBcIk1PTlRIX0RBWVNfUkVHVUxBUl9DVU1VTEFUSVZFXCIsXFxuICAgICAgXCJNT05USF9EQVlTX0xFQVBfQ1VNVUxBVElWRVwiLFxcbiAgICAgIFwiU1lTQ0FMTFNcIixcXG4gICAgICBcInByZWxvYWRQbHVnaW5zXCIsXFxuICAgICAgXCJGU19jcmVhdGVQcmVsb2FkZWRGaWxlXCIsXFxuICAgICAgXCJGU19tb2RlU3RyaW5nVG9GbGFnc1wiLFxcbiAgICAgIFwiRlNfZ2V0TW9kZVwiLFxcbiAgICAgIFwiRlNfc3RkaW5fZ2V0Q2hhcl9idWZmZXJcIixcXG4gICAgICBcIkZTX3N0ZGluX2dldENoYXJcIixcXG4gICAgICBcIkZTX2NyZWF0ZVBhdGhcIixcXG4gICAgICBcIkZTX2NyZWF0ZURldmljZVwiLFxcbiAgICAgIFwiRlNfcmVhZEZpbGVcIixcXG4gICAgICBcIkZTXCIsXFxuICAgICAgXCJGU19jcmVhdGVEYXRhRmlsZVwiLFxcbiAgICAgIFwiRlNfY3JlYXRlTGF6eUZpbGVcIixcXG4gICAgICBcIk1FTUZTXCIsXFxuICAgICAgXCJUVFlcIixcXG4gICAgICBcIlBJUEVGU1wiLFxcbiAgICAgIFwiU09DS0ZTXCIsXFxuICAgICAgXCJ0ZW1wRml4ZWRMZW5ndGhBcnJheVwiLFxcbiAgICAgIFwibWluaVRlbXBXZWJHTEZsb2F0QnVmZmVyc1wiLFxcbiAgICAgIFwibWluaVRlbXBXZWJHTEludEJ1ZmZlcnNcIixcXG4gICAgICBcIkdMXCIsXFxuICAgICAgXCJBTFwiLFxcbiAgICAgIFwiR0xVVFwiLFxcbiAgICAgIFwiRUdMXCIsXFxuICAgICAgXCJHTEVXXCIsXFxuICAgICAgXCJJREJTdG9yZVwiLFxcbiAgICAgIFwicnVuQW5kQWJvcnRJZkVycm9yXCIsXFxuICAgICAgXCJBc3luY2lmeVwiLFxcbiAgICAgIFwiRmliZXJzXCIsXFxuICAgICAgXCJTRExcIixcXG4gICAgICBcIlNETF9nZnhcIixcXG4gICAgICBcImFsbG9jYXRlVVRGOFwiLFxcbiAgICAgIFwiYWxsb2NhdGVVVEY4T25TdGFja1wiLFxcbiAgICAgIFwicHJpbnRcIixcXG4gICAgICBcInByaW50RXJyXCIsXFxuICAgIF07XFxuICAgIHVuZXhwb3J0ZWRTeW1ib2xzLmZvckVhY2godW5leHBvcnRlZFJ1bnRpbWVTeW1ib2wpO1xcbiAgICB2YXIgY2FsbGVkUnVuO1xcbiAgICBmdW5jdGlvbiBjYWxsTWFpbihhcmdzID0gW10pIHtcXG4gICAgICBhc3NlcnQoXFxuICAgICAgICBydW5EZXBlbmRlbmNpZXMgPT0gMCxcXG4gICAgICAgIFxcJ2Nhbm5vdCBjYWxsIG1haW4gd2hlbiBhc3luYyBkZXBlbmRlbmNpZXMgcmVtYWluISAobGlzdGVuIG9uIE1vZHVsZVtcIm9uUnVudGltZUluaXRpYWxpemVkXCJdKVxcJyxcXG4gICAgICApO1xcbiAgICAgIGFzc2VydChcXG4gICAgICAgIHR5cGVvZiBvblByZVJ1bnMgPT09IFwidW5kZWZpbmVkXCIgfHwgb25QcmVSdW5zLmxlbmd0aCA9PSAwLFxcbiAgICAgICAgXCJjYW5ub3QgY2FsbCBtYWluIHdoZW4gcHJlUnVuIGZ1bmN0aW9ucyByZW1haW4gdG8gYmUgY2FsbGVkXCIsXFxuICAgICAgKTtcXG4gICAgICB2YXIgZW50cnlGdW5jdGlvbiA9IF9tYWluO1xcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzUHJvZ3JhbSk7XFxuICAgICAgdmFyIGFyZ2MgPSBhcmdzLmxlbmd0aDtcXG4gICAgICB2YXIgYXJndiA9IHN0YWNrQWxsb2MoKGFyZ2MgKyAxKSAqIDgpO1xcbiAgICAgIHZhciBhcmd2X3B0ciA9IGFyZ3Y7XFxuICAgICAgYXJncy5mb3JFYWNoKChhcmcpID0+IHtcXG4gICAgICAgIEhFQVBVNjRbYXJndl9wdHIgLyA4XSA9IEJpZ0ludChzdHJpbmdUb1VURjhPblN0YWNrKGFyZykpO1xcbiAgICAgICAgYXJndl9wdHIgKz0gODtcXG4gICAgICB9KTtcXG4gICAgICBIRUFQVTY0W2FyZ3ZfcHRyIC8gOF0gPSBCaWdJbnQoMCk7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIHZhciByZXQgPSBlbnRyeUZ1bmN0aW9uKGFyZ2MsIEJpZ0ludChhcmd2KSk7XFxuICAgICAgICBleGl0SlMocmV0LCB0cnVlKTtcXG4gICAgICAgIHJldHVybiByZXQ7XFxuICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgcmV0dXJuIGhhbmRsZUV4Y2VwdGlvbihlKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgZnVuY3Rpb24gc3RhY2tDaGVja0luaXQoKSB7XFxuICAgICAgX2Vtc2NyaXB0ZW5fc3RhY2tfaW5pdCgpO1xcbiAgICAgIHdyaXRlU3RhY2tDb29raWUoKTtcXG4gICAgfVxcbiAgICBmdW5jdGlvbiBydW4oYXJncyA9IGFyZ3VtZW50c18pIHtcXG4gICAgICBpZiAocnVuRGVwZW5kZW5jaWVzID4gMCkge1xcbiAgICAgICAgLy8gZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gcnVuO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICBzdGFja0NoZWNrSW5pdCgpO1xcbiAgICAgIHByZVJ1bigpO1xcbiAgICAgIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSB7XFxuICAgICAgICAvLyBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBydW47XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICAgIGZ1bmN0aW9uIGRvUnVuKCkge1xcbiAgICAgICAgYXNzZXJ0KCFjYWxsZWRSdW4pO1xcbiAgICAgICAgY2FsbGVkUnVuID0gdHJ1ZTtcXG4gICAgICAgIE1vZHVsZVtcImNhbGxlZFJ1blwiXSA9IHRydWU7XFxuICAgICAgICBpZiAoQUJPUlQpIHJldHVybjtcXG4gICAgICAgIGluaXRSdW50aW1lKCk7XFxuICAgICAgICBGUy53cml0ZUZpbGUoXCJvdXRwdXQuZWxmXCIsIGFyZ3NbMF0pO1xcbiAgICAgICAgYXJncy5zaGlmdCgpO1xcbiAgICAgICAgcHJlTWFpbigpO1xcbiAgICAgICAgcmVhZHlQcm9taXNlUmVzb2x2ZShNb2R1bGUpO1xcbiAgICAgICAgTW9kdWxlW1wib25SdW50aW1lSW5pdGlhbGl6ZWRcIl0/LigpO1xcbiAgICAgICAgdmFyIG5vSW5pdGlhbFJ1biA9IE1vZHVsZVtcIm5vSW5pdGlhbFJ1blwiXTtcXG4gICAgICAgIGxlZ2FjeU1vZHVsZVByb3AoXCJub0luaXRpYWxSdW5cIiwgXCJub0luaXRpYWxSdW5cIik7XFxuICAgICAgICBjYWxsTWFpbihhcmdzKTtcXG4gICAgICAgIHBvc3RSdW4oKTtcXG4gICAgICB9XFxuICAgICAgaWYgKE1vZHVsZVtcInNldFN0YXR1c1wiXSkge1xcbiAgICAgICAgTW9kdWxlW1wic2V0U3RhdHVzXCJdKFwiUnVubmluZy4uLlwiKTtcXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IE1vZHVsZVtcInNldFN0YXR1c1wiXShcIlwiKSwgMSk7XFxuICAgICAgICAgIGRvUnVuKCk7XFxuICAgICAgICB9LCAxKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZG9SdW4oKTtcXG4gICAgICB9XFxuICAgICAgY2hlY2tTdGFja0Nvb2tpZSgpO1xcbiAgICB9XFxuICAgIGZ1bmN0aW9uIGNoZWNrVW5mbHVzaGVkQ29udGVudCgpIHtcXG4gICAgICB2YXIgb2xkT3V0ID0gb3V0O1xcbiAgICAgIHZhciBvbGRFcnIgPSBlcnI7XFxuICAgICAgdmFyIGhhcyA9IGZhbHNlO1xcbiAgICAgIG91dCA9IGVyciA9ICh4KSA9PiB7XFxuICAgICAgICBoYXMgPSB0cnVlO1xcbiAgICAgIH07XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIF9mZmx1c2goMCk7XFxuICAgICAgICBbXCJzdGRvdXRcIiwgXCJzdGRlcnJcIl0uZm9yRWFjaCgobmFtZSkgPT4ge1xcbiAgICAgICAgICB2YXIgaW5mbyA9IEZTLmFuYWx5emVQYXRoKFwiL2Rldi9cIiArIG5hbWUpO1xcbiAgICAgICAgICBpZiAoIWluZm8pIHJldHVybjtcXG4gICAgICAgICAgdmFyIHN0cmVhbSA9IGluZm8ub2JqZWN0O1xcbiAgICAgICAgICB2YXIgcmRldiA9IHN0cmVhbS5yZGV2O1xcbiAgICAgICAgICB2YXIgdHR5ID0gVFRZLnR0eXNbcmRldl07XFxuICAgICAgICAgIGlmICh0dHk/Lm91dHB1dD8ubGVuZ3RoKSB7XFxuICAgICAgICAgICAgaGFzID0gdHJ1ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfSBjYXRjaCAoZSkge31cXG4gICAgICBvdXQgPSBvbGRPdXQ7XFxuICAgICAgZXJyID0gb2xkRXJyO1xcbiAgICAgIGlmIChoYXMpIHtcXG4gICAgICAgIHdhcm5PbmNlKFxcbiAgICAgICAgICBcInN0ZGlvIHN0cmVhbXMgaGFkIGNvbnRlbnQgaW4gdGhlbSB0aGF0IHdhcyBub3QgZmx1c2hlZC4geW91IHNob3VsZCBzZXQgRVhJVF9SVU5USU1FIHRvIDEgKHNlZSB0aGUgRW1zY3JpcHRlbiBGQVEpLCBvciBtYWtlIHN1cmUgdG8gZW1pdCBhIG5ld2xpbmUgd2hlbiB5b3UgcHJpbnRmIGV0Yy5cIixcXG4gICAgICAgICk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChNb2R1bGVbXCJwcmVJbml0XCJdKSB7XFxuICAgICAgaWYgKHR5cGVvZiBNb2R1bGVbXCJwcmVJbml0XCJdID09IFwiZnVuY3Rpb25cIilcXG4gICAgICAgIE1vZHVsZVtcInByZUluaXRcIl0gPSBbTW9kdWxlW1wicHJlSW5pdFwiXV07XFxuICAgICAgd2hpbGUgKE1vZHVsZVtcInByZUluaXRcIl0ubGVuZ3RoID4gMCkge1xcbiAgICAgICAgTW9kdWxlW1wicHJlSW5pdFwiXS5wb3AoKSgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvLyBydW4oKTtcXG4gICAgbW9kdWxlUnRuID0gcmVhZHlQcm9taXNlO1xcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgT2JqZWN0LmtleXMoTW9kdWxlKSkge1xcbiAgICAgIGlmICghKHByb3AgaW4gbW9kdWxlQXJnKSkge1xcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZUFyZywgcHJvcCwge1xcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICAgIGdldCgpIHtcXG4gICAgICAgICAgICBhYm9ydChcXG4gICAgICAgICAgICAgIGBBY2Nlc3MgdG8gbW9kdWxlIHByb3BlcnR5IChcXCcke3Byb3B9XFwnKSBpcyBubyBsb25nZXIgcG9zc2libGUgdmlhIHRoZSBtb2R1bGUgY29uc3RydWN0b3IgYXJndW1lbnQ7IEluc3RlYWQsIHVzZSB0aGUgcmVzdWx0IG9mIHRoZSBtb2R1bGUgY29uc3RydWN0b3IuYCxcXG4gICAgICAgICAgICApO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJlYWR5UHJvbWlzZVJlc29sdmUoTW9kdWxlKTtcXG4gICAgcmV0dXJuIG1vZHVsZVJ0bjtcXG4gIH07XFxufSkoKTtcXG4oKCkgPT4ge1xcbiAgLy8gQ3JlYXRlIGEgc21hbGwsIG5ldmVyLWFzeW5jIHdyYXBwZXIgYXJvdW5kIE1vZHVsZSB3aGljaFxcbiAgLy8gY2hlY2tzIGZvciBjYWxsZXJzIGluY29ycmVjdGx5IHVzaW5nIGl0IHdpdGggYG5ld2AuXFxuICB2YXIgcmVhbF9Nb2R1bGUgPSBNb2R1bGU7XFxuICBNb2R1bGUgPSBmdW5jdGlvbiAoYXJnKSB7XFxuICAgIGlmIChuZXcudGFyZ2V0KVxcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZHVsZSgpIHNob3VsZCBub3QgYmUgY2FsbGVkIHdpdGggYG5ldyBNb2R1bGUoKWBcIik7XFxuICAgIHJldHVybiByZWFsX01vZHVsZShhcmcpO1xcbiAgfTtcXG59KSgpO1xcbmV4cG9ydCBkZWZhdWx0IE1vZHVsZTtcXG4nOyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUEsRUFBRSxHQUFHQyxPQUFPLENBQUMsSUFBSSxDQUFDO0FBQ3hCLE1BQU1DLElBQUksR0FBR0QsT0FBTyxDQUFDLE1BQU0sQ0FBQztBQUU1QkUsTUFBTSxDQUFDQyxPQUFPLEdBQUcsU0FBU0MsV0FBV0EsQ0FBQ0MsSUFBSSxFQUFFQyxHQUFHLEVBQUU7RUFDL0MsTUFBTUMsTUFBTSxHQUFHRixJQUFJLENBQUNFLE1BQU07O0VBRTFCO0VBQ0EsTUFBTUMsT0FBTyxHQUFHLENBQ2QsdUJBQXVCLEVBQ3ZCLDBDQUEwQyxFQUMxQyw4Q0FBOEMsQ0FDL0M7RUFFRCxNQUFNQyxlQUFlLEdBQUdELE9BQU8sQ0FBQ0UsS0FBSyxDQUFFQyxDQUFDLElBQUtKLE1BQU0sQ0FBQ0ssUUFBUSxDQUFDRCxDQUFDLENBQUMsQ0FBQztFQUNoRSxJQUFJLENBQUNGLGVBQWUsRUFBRSxPQUFPRixNQUFNOztFQUVuQztFQUNBLE1BQU1NLFdBQVcsR0FBR1osSUFBSSxDQUFDYSxJQUFJLENBQUNDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLENBQUMsRUFBRSxZQUFZLENBQUM7RUFDMUQsSUFBSWpCLEVBQUUsQ0FBQ2tCLFVBQVUsQ0FBQ0osV0FBVyxDQUFDLEVBQUU7SUFDOUIsT0FBT2QsRUFBRSxDQUFDbUIsWUFBWSxDQUFDTCxXQUFXLEVBQUUsTUFBTSxDQUFDO0VBQzdDOztFQUVBO0VBQ0EsT0FBT00sZUFBZTtBQUN4QixDQUFDO0FBRUQsTUFBTUEsZUFBZSxHQUFHLHl3dU1BQXl3dU0iLCJpZ25vcmVMaXN0IjpbXX0=","map":{"version":3,"names":["fs","require","path","module","exports","transformer","file","api","source","anchors","isExpectedInput","every","a","includes","desiredPath","join","process","cwd","existsSync","readFileSync","DESIRED_CONTENT"],"sourceRoot":"/home/juancarlos/Escritorio/prueba/creator-sail-executor/c_emulator/","sources":["transform64.js"],"sourcesContent":["/**\n * transform.js (jscodeshift)\n *\n * Exact codemod: converts the specific provided original.js into the specific provided deseado.js.\n * For safety, it checks a few anchor strings; if they don't match, it leaves the file unchanged.\n *\n * Usage:\n *   # Option A: run with embedded desired content (no extra files needed)\n *   npx jscodeshift -t transform.js original.js\n *\n *   # Option B: if you prefer not to embed, keep a deseado.js next to where you run the command:\n *   cp deseado.js /path/where/you/run/\n *   npx jscodeshift -t transform.js original.js\n */\nconst fs = require('fs');\nconst path = require('path');\n\nmodule.exports = function transformer(file, api) {\n  const source = file.source;\n\n  // Anchors to confirm we're looking at the expected input file.\n  const anchors = [\n    'var Module = (() => {',\n    'return async function (moduleArg = {}) {',\n    'var readyPromiseResolve, readyPromiseReject;'\n  ];\n\n  const isExpectedInput = anchors.every((a) => source.includes(a));\n  if (!isExpectedInput) return source;\n\n  // If a deseado.js exists in the current working directory, prefer it.\n  const desiredPath = path.join(process.cwd(), 'deseado.js');\n  if (fs.existsSync(desiredPath)) {\n    return fs.readFileSync(desiredPath, 'utf8');\n  }\n\n  // Otherwise fall back to the embedded content.\n  return DESIRED_CONTENT;\n};\n\nconst DESIRED_CONTENT = 'import { instructions } from \"@/core/assembler/assembler.mjs\";\\nimport { readRegister, writeRegister, notifyRegisterUpdate } from \"@/core/register/registerOperations.mjs\";\\nimport { crex_findReg_bytag, crex_findReg } from \"@/core/register/registerLookup.mjs\"\\nimport { status, PC_REG_INDEX, REGISTERS, getPC, main_memory, config_cache, L1_cache_memory, L1_I_cache_memory, L1_D_cache_memory, L2_D_cache_memory, L2_I_cache_memory, L2_cache_memory, updateCacheMem  } from \"@/core/core.mjs\";\\nimport { setInstructions } from \"@/core/assembler/assembler.mjs\";\\nimport { display_print } from \"../../IO.mjs\";\\nimport { SYSCALL } from \"@/core/capi/syscall.mts\";\\nimport { coreEvents } from \"@/core/events.mts\";\\nimport { show_notification } from \"@/web/utils.mjs\";\\nimport { reset_disable, instruction_disable, run_disable, stop_disable, isFinished } from \"@/web/utils.mjs\";\\nimport { architecture } from \"../../../core.mjs\";\\nimport { clearAllRegisterGlows } from \"@/core/register/registerGlowState.mjs\";\\n\\nexport var userMode64 = false;\\n\\nvar Module = (() => {\\n  var _scriptName = import.meta.url;\\n  var insn_number;\\n\\n  return async function (moduleArg = {}) {\\n    document.app.$data.is_breakpoint = instructions[0].Break;\\n    var pc_sail = crex_findReg_bytag(\"program_counter\");\\n    var pc_min = architecture.memory_layout.text.start;\\n    var pc_max = architecture.memory_layout.text.end;\\n    var hiden_executed, hiden_next_execute;\\n\\n    var registers_before_function = [ \\n      { name: \"t0\", can_operate : false},\\n      { name: \"t1\", can_operate : false},\\n      { name: \"t2\", can_operate : false},\\n      { name: \"t3\", can_operate : false},\\n      { name: \"t4\", can_operate : false}, \\n      { name: \"t5\", can_operate : false},\\n      { name: \"t6\", can_operate : false},\\n      { name: \"s0\", can_operate : false},\\n      { name: \"s1\", can_operate : false},\\n      { name: \"s2\", can_operate : false},\\n      { name: \"s3\", can_operate : false},\\n      { name: \"s4\", can_operate : false}, \\n      { name: \"s5\", can_operate : false},\\n      { name: \"s6\", can_operate : false},\\n      { name: \"s7\", can_operate : false},\\n      { name: \"s8\", can_operate : false},\\n      { name: \"s9\", can_operate : false},\\n      { name: \"s10\", can_operate : false}, \\n      { name: \"s11\", can_operate : false}\\n    ]\\n    var callstack_convention = [];\\n    var inside_function = false;\\n    Module = Module || {};\\n    var moduleRtn;\\n\\n    var Module = moduleArg;\\n    var readyPromiseResolve, readyPromiseReject;\\n    var readyPromise = new Promise((resolve, reject) => {\\n      readyPromiseResolve = resolve;\\n      readyPromiseReject = reject;\\n    });\\n    var ENVIRONMENT_IS_WEB = true;\\n    var ENVIRONMENT_IS_WORKER = false;\\n    var ENVIRONMENT_IS_NODE = false;\\n    var ENVIRONMENT_IS_SHELL = false;\\n    var moduleOverrides = Object.assign({}, Module);\\n    var arguments_ = [];\\n    var thisProgram = \"./this.program\";\\n    var quit_ = (status, toThrow) => {\\n      throw toThrow;\\n    };\\n    var scriptDirectory = \"\";\\n    function locateFile(path) {\\n      if (Module[\"locateFile\"]) {\\n        return Module[\"locateFile\"](path, scriptDirectory);\\n      }\\n      return scriptDirectory + path;\\n    }\\n    var readAsync, readBinary;\\n    if (ENVIRONMENT_IS_SHELL) {\\n      if (\\n        (typeof process == \"object\" && typeof require === \"function\") ||\\n        typeof window == \"object\" ||\\n        typeof WorkerGlobalScope != \"undefined\"\\n      )\\n        throw new Error(\\n          \"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\",\\n        );\\n    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\\n      if (ENVIRONMENT_IS_WORKER) {\\n        scriptDirectory = self.location.href;\\n      } else if (typeof document != \"undefined\" && document.currentScript) {\\n        scriptDirectory = document.currentScript.src;\\n      }\\n      if (_scriptName) {\\n        scriptDirectory = _scriptName;\\n      }\\n      if (scriptDirectory.startsWith(\"blob:\")) {\\n        scriptDirectory = \"\";\\n      } else {\\n        scriptDirectory = scriptDirectory.slice(\\n          0,\\n          scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1,\\n        );\\n      }\\n      if (\\n        !(typeof window == \"object\" || typeof WorkerGlobalScope != \"undefined\")\\n      )\\n        throw new Error(\\n          \"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\",\\n        );\\n      {\\n        readAsync = async (url) => {\\n          assert(!isFileURI(url), \"readAsync does not work with file:// URLs\");\\n          var response = await fetch(url, { credentials: \"same-origin\" });\\n          if (response.ok) {\\n            return response.arrayBuffer();\\n          }\\n          throw new Error(response.status + \" : \" + response.url);\\n        };\\n      }\\n    } else {\\n      throw new Error(\"environment detection error\");\\n    }\\n\\n\\n    // const instructionExp = /\\\\[(\\\\d+)\\\\] \\\\[(\\\\w+)\\\\]: 0x([0-9A-Fa-f]+) \\\\(0x([0-9A-Fa-f]+)\\\\) (\\\\w+) ([^,]+), ([^,]+)(?:, (.+))?/;\\n    var instructionExp = /\\\\[(\\\\d+)\\\\] \\\\[(\\\\w+)\\\\]: 0x([0-9A-Fa-f]+) \\\\(0x([0-9A-Fa-f]+)\\\\) ([\\\\w.]+)(?: ([^,]+), ([^,]+)(?:, (.+))?)?/;\\n    var registerExp = /([xf]\\\\d+) (<-) 0x([0-9A-Fa-f]+)/; // /(x\\\\d+) (<-|->) 0x([0-9A-Fa-f]+)/;\\n    var vectorExp = /(v\\\\d+) (<-) 0x([0-9A-Fa-f]+)/;\\n    var memoryExp = /mem\\\\[0x([0-9A-Fa-f]+)\\\\]\\\\s*(<-|->)\\\\s*0x([0-9A-Fa-f]+)/;\\n    var CSRTypeExp = /(CSR\\\\S*)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(0x)([\\\\dA-Fa-f]{1,16})/;\\n    var CSRExp = /^(CSR)\\\\s+(\\\\w+)\\\\s+(<-|->)\\\\s+0x([0-9a-fA-F]+)(?:\\\\s+(.*))?$/;\\n    var jumpExp = /Next_PC:\\\\s*0x([0-9a-fA-F]+)/;\\n    // var cacheExp = /^\\\\[(\\\\d+)\\\\]\\\\s+(L1_I|L1_D|L1|L2|L2_I|L2_D):\\\\s*\\\\((0x[0-9A-Fa-f]+)\\\\)\\\\s$/;\\n    var cacheExp = /^\\\\[(\\\\d+)\\\\]\\\\s+(L1_I|L1_D|L1|L2|L2_I|L2_D):\\\\s*\\\\((0x[0-9A-Fa-f]+)\\\\)\\\\s*$/;\\n    var configCacheExp = /^Configuration:\\\\s*([A-Za-z_][A-Za-z0-9_]*)\\\\s*<-\\\\s*(\\\\S+)\\\\s*$/;\\n    // var displayExp = /^[A-Za-z\\\\s]+:\\\\s*(.*)$/;\\n    // var displayExp = /^([\\\\w\\\\s]+):\\\\s*(.*)$/;     \\n    var displayExp = /^ECALL\\\\s+(SIGNED|UNSIGNED|STRING|CHAR|FLOAT|DOUBLE):\\\\s*(.+)$/; \\n    var instoper = \"\";\\n    var syscall_print_code = -1;\\n    var prev_add_to_jump;\\n    // var type_to_write;\\n\\n\\n\\n    function updateCacheStat(index, access, data=\"\") {\\n      switch(access) {\\n        case \"Cache L1 hit inst\":\\n          if (instructions[index].L1_I == 0)\\n            instructions[index].L1_I = 3;\\n          else if (instructions[index].L1_I == 3)\\n            instructions[index].L1_I = 3;\\n          else if (instructions[index].L1_I == 4)\\n            instructions[index].L1_I = 1;\\n          break;\\n        case \"Cache L1 miss inst\":\\n          if (instructions[index].L1_I == 0)\\n            instructions[index].L1_I = 4;\\n          else if (instructions[index].L1_I == 4)\\n            instructions[index].L1_I = 4;\\n          else if (instructions[index].L1_I == 3)\\n            instructions[index].L1_I = 1;\\n          break;\\n        case \"Cache L1 miss\":\\n          if (instructions[index].L1_I == 0)\\n            instructions[index].L1_I = 4;\\n          else if (instructions[index].L1_I == 4)\\n            instructions[index].L1_I = 4;\\n          else if (instructions[index].L1_I == 3)\\n            instructions[index].L1_I = 1;\\n          break;\\n        case \"Cache L1 hit data\":\\n          if(data !== \"\") {\\n            let lastv = parseInt(data[data.length - 1], 16);\\n            if (lastv < 4) data = data.slice(0, -1) + \"0\";\\n            else if (lastv < 8) data = data.slice(0, -1) + \"4\";\\n            else if (lastv < 12) data = data.slice(0, -1) +  \"8\";\\n            else data = data.slice(0, -1) + \"C\";\\n            let memindex = parseInt(data, 16);\\n            if (main_memory[memindex].L1_D == 0)\\n              main_memory[parseInt(data, 16)].L1_D = 3;\\n            else if (main_memory[memindex].L1_D == 3)\\n              main_memory[parseInt(data, 16)].L1_D = 3;\\n            else if (main_memory[memindex].L1_D == 4)\\n              main_memory[parseInt(data, 16)].L1_D = 1;\\n          }\\n          if (instructions[index].L1_D == 0)\\n            instructions[index].L1_D = 3;\\n          else if (instructions[index].L1_D == 3)\\n            instructions[index].L1_D = 3;\\n          else if (instructions[index].L1_D == 4)\\n            instructions[index].L1_D = 1;\\n          break;\\n        case \"Cache L1 miss data\":\\n          if(data !== \"\") {\\n            let lastv = parseInt(data[data.length - 1], 16);\\n            if (lastv < 4) data = data.slice(0, -1) + \"0\";\\n            else if (lastv < 8) data = data.slice(0, -1) + \"4\";\\n            else if (lastv < 12) data = data.slice(0, -1) +  \"8\";\\n            else data = data.slice(0, -1) + \"C\";\\n            let memindex = parseInt(data, 16);\\n            if (main_memory[memindex].L1_D == 0)\\n              main_memory[parseInt(data, 16)].L1_D = 4;\\n            else if (main_memory[memindex].L1_D == 4)\\n              main_memory[parseInt(data, 16)].L1_D = 4;\\n            else if (main_memory[memindex].L1_D == 3)\\n              main_memory[parseInt(data, 16)].L1_D = 1;\\n          }\\n          if (instructions[index].L1_D == 0)\\n            instructions[index].L1_D = 4;\\n          else if (instructions[index].L1_D == 4)\\n            instructions[index].L1_D = 4;\\n          else if (instructions[index].L1_D == 3)\\n            instructions[index].L1_D = 1;\\n          break;\\n        case \"Cache L1_I hit\":\\n          if (instructions[index].L1_I == 0)\\n            instructions[index].L1_I = 3;\\n          else if (instructions[index].L1_I == 4)\\n            instructions[index].L1_I = 1;\\n          break;\\n        case \"Cache L1_I miss\":\\n          if (instructions[index].L1_I == 0)\\n            instructions[index].L1_I = 4;\\n          else if (instructions[index].L1_I == 3)\\n            instructions[index].L1_I = 1;\\n          else if (instructions[index].L1_I == 4)\\n            instructions[index].L1_I = 4;\\n          break;\\n        case \"Cache L1_D hit\":\\n          if(data !== \"\") {\\n            let lastv = parseInt(data[data.length - 1], 16);\\n            if (lastv < 4) data = data.slice(0, -1) + \"0\";\\n            else if (lastv < 8) data = data.slice(0, -1) + \"4\";\\n            else if (lastv < 12) data = data.slice(0, -1) +  \"8\";\\n            else data = data.slice(0, -1) + \"C\";\\n            let memindex = parseInt(data, 16);\\n            if (main_memory[memindex].L1_D == 0)\\n              main_memory[parseInt(data, 16)].L1_D = 3;\\n            else if (main_memory[memindex].L1_D == 3)\\n              main_memory[parseInt(data, 16)].L1_D = 3;\\n            else if (main_memory[memindex].L1_D == 4)\\n              main_memory[parseInt(data, 16)].L1_D = 1;\\n          }\\n          if (instructions[index].L1_D == 0)\\n            instructions[index].L1_D = 3;\\n          else if (instructions[index].L1_D == 3)\\n            instructions[index].L1_D = 3;\\n          else if (instructions[index].L1_D == 4)\\n            instructions[index].L1_D = 1;\\n          break;\\n        case \"Cache L1_D miss\":\\n          if(data !== \"\") {\\n            let lastv = parseInt(data[data.length - 1], 16);\\n            if (lastv < 4) data = data.slice(0, -1) + \"0\";\\n            else if (lastv < 8) data = data.slice(0, -1) + \"4\";\\n            else if (lastv < 12) data = data.slice(0, -1) +  \"8\";\\n            else data = data.slice(0, -1) + \"C\";\\n            let memindex = parseInt(data, 16);\\n            if (main_memory[memindex].L1_D == 0)\\n              main_memory[parseInt(data, 16)].L1_D = 4;\\n            else if (main_memory[memindex].L1_D == 4)\\n              main_memory[parseInt(data, 16)].L1_D = 4;\\n            else if (main_memory[memindex].L1_D == 3)\\n              main_memory[parseInt(data, 16)].L1_D = 1;\\n          }\\n          if (instructions[index].L1_D == 0)\\n            instructions[index].L1_D = 4;\\n          else if (instructions[index].L1_D == 4)\\n            instructions[index].L1_D = 4;\\n          else if (instructions[index].L1_D == 3)\\n            instructions[index].L1_D = 1;\\n          break;\\n        case \"Cache L2 hit inst\":\\n          if (instructions[index].L2_I == 0)\\n            instructions[index].L2_I = 3;\\n          else if (instructions[index].L2_I == 3)\\n            instructions[index].L2_I = 3;\\n          else if (instructions[index].L2_I == 4)\\n            instructions[index].L2_I = 1;\\n          break;\\n        case \"Cache L2 miss inst\":\\n          if (instructions[index].L2_I == 0)\\n            instructions[index].L2_I = 4;\\n          else if (instructions[index].L2_I == 4)\\n            instructions[index].L2_I = 4;\\n          else if (instructions[index].L2_I == 3)\\n            instructions[index].L2_I = 1;\\n          break;\\n        case \"Cache L2_I hit\":\\n          if (instructions[index].L2_I == 0)\\n            instructions[index].L2_I = 3;\\n          else if (instructions[index].L2_I == 3)\\n            instructions[index].L2_I = 3;\\n          else if (instructions[index].L2_I == 4)\\n            instructions[index].L2_I = 1;\\n          break;\\n        case \"Cache L2_I miss\":\\n          if (instructions[index].L2_I == 0)\\n            instructions[index].L2_I = 4;\\n          else if (instructions[index].L2_I == 4)\\n            instructions[index].L2_I = 4;\\n          else if (instructions[index].L2_I == 3)\\n            instructions[index].L2_I = 1;\\n          break;\\n        case \"Cache L2 hit data\":\\n          if(data !== \"\") {\\n            let lastv = parseInt(data[data.length - 1], 16);\\n            if (lastv < 4) data = data.slice(0, -1) + \"0\";\\n            else if (lastv < 8) data = data.slice(0, -1) + \"4\";\\n            else if (lastv < 12) data = data.slice(0, -1) +  \"8\";\\n            else data = data.slice(0, -1) + \"C\";\\n            let memindex = parseInt(data, 16);\\n            if (main_memory[memindex].L2_D == 0)\\n              main_memory[parseInt(data, 16)].L2_D = 3;\\n            else if (main_memory[memindex].L2_D == 3)\\n              main_memory[parseInt(data, 16)].L2_D = 3;\\n            else if (main_memory[memindex].L2_D == 4)\\n              main_memory[parseInt(data, 16)].L2_D = 1;\\n          }\\n          if (instructions[index].L2_D == 0)\\n            instructions[index].L2_D = 3;\\n          else if (instructions[index].L2_D == 3)\\n            instructions[index].L2_D = 3;\\n          else if (instructions[index].L2_D == 4)\\n            instructions[index].L2_D = 1;\\n          break;\\n        case \"Cache L2 miss data\":\\n          if(data !== \"\") {\\n            let lastv = parseInt(data[data.length - 1], 16);\\n            if (lastv < 4) data = data.slice(0, -1) + \"0\";\\n            else if (lastv < 8) data = data.slice(0, -1) + \"4\";\\n            else if (lastv < 12) data = data.slice(0, -1) +  \"8\";\\n            else data = data.slice(0, -1) + \"C\";\\n            let memindex = parseInt(data, 16);\\n            if (main_memory[memindex].L2_D == 0)\\n              main_memory[parseInt(data, 16)].L2_D = 4;\\n            else if (main_memory[memindex].L2_D == 4)\\n              main_memory[parseInt(data, 16)].L2_D = 4;\\n            else if (main_memory[memindex].L2_D == 3)\\n              main_memory[parseInt(data, 16)].L2_D = 1;\\n          }\\n          if (instructions[index].L2_D == 0)\\n            instructions[index].L2_D = 4;\\n          else if (instructions[index].L2_D == 4)\\n            instructions[index].L2_D = 4;\\n          else if (instructions[index].L2_D == 3)\\n            instructions[index].L2_D = 1;\\n          break;\\n        case \"Cache L2_D hit\":\\n          if(data !== \"\") {\\n            let lastv = parseInt(data[data.length - 1], 16);\\n            if (lastv < 4) data = data.slice(0, -1) + \"0\";\\n            else if (lastv < 8) data = data.slice(0, -1) + \"4\";\\n            else if (lastv < 12) data = data.slice(0, -1) +  \"8\";\\n            else data = data.slice(0, -1) + \"C\";\\n            let memindex = parseInt(data, 16);\\n            if (main_memory[memindex].L2_D == 0)\\n              main_memory[parseInt(data, 16)].L2_D = 3;\\n            else if (main_memory[memindex].L2_D == 3)\\n              main_memory[parseInt(data, 16)].L2_D = 3;\\n            else if (main_memory[memindex].L2_D == 4)\\n              main_memory[parseInt(data, 16)].L2_D = 1;\\n          }\\n          if (instructions[index].L2_D == 0)\\n            instructions[index].L2_D = 3;\\n          else if (instructions[index].L2_D == 3)\\n            instructions[index].L2_D = 3;\\n          else if (instructions[index].L2_D == 4)\\n            instructions[index].L2_D = 1;\\n          break;\\n        case \"Cache L2_D miss\":\\n          if(data !== \"\") {\\n            let lastv = parseInt(data[data.length - 1], 16);\\n            if (lastv < 4) data = data.slice(0, -1) + \"0\";\\n            else if (lastv < 8) data = data.slice(0, -1) + \"4\";\\n            else if (lastv < 12) data = data.slice(0, -1) +  \"8\";\\n            else data = data.slice(0, -1) + \"C\";\\n            let memindex = parseInt(data, 16);\\n            if (main_memory[memindex].L2_D == 0)\\n              main_memory[parseInt(data, 16)].L2_D = 4;\\n            else if (main_memory[memindex].L2_D == 4)\\n              main_memory[parseInt(data, 16)].L2_D = 4;\\n            else if (main_memory[memindex].L2_D == 3)\\n              main_memory[parseInt(data, 16)].L2_D = 1;\\n          }\\n          if (instructions[index].L2_D == 0)\\n            instructions[index].L2_D = 4;\\n          else if (instructions[index].L2_D == 4)\\n            instructions[index].L2_D = 4;\\n          else if (instructions[index].L2_D == 3)\\n            instructions[index].L2_D = 1;\\n          break;\\n      }\\n\\n    }\\n\\n\\n    async function check_call_convention_temp_regs(instMatch) {\\n      if(((instMatch[7] != undefined && (instMatch[7].includes(\"t\") || (instMatch[7].includes(\"s\") && !instMatch[7].includes(\"sp\")) ) ) || (instMatch[8] != undefined && (instMatch[8].includes(\"t\") || (instMatch[8].includes(\"s\") && !instMatch[8].includes(\"sp\")) ))) && instMatch[6] !== undefined && inside_function) {\\n        if((instMatch[5] != \"li\" && instMatch[5] != \"lui\" && instMatch[5] != \"la\") ){\\n          for (var i = 0; i < callstack_convention[callstack_convention.length - 1].length; i++ ){\\n            (callstack_convention[callstack_convention.length - 1][i].name === instMatch[7] || callstack_convention[callstack_convention.length - 1][i].name === instMatch[8]) &&\\n            (callstack_convention[callstack_convention.length - 1][i].can_operate === false) ? show_notification(\"Possible failure in the parameter passing convention\", \"danger\") : 0 ; \\n          }\\n            \\n            // callstack_convention[callstack_convention.length - 1].name \\n\\n        }\\n      }\\n      if (instMatch[6] !== undefined && (instMatch[6].includes(\"t\") || (instMatch[6].includes(\"s\") && !instMatch[6].includes(\"sp\"))) && inside_function) {\\n        for (var i = 0; i < callstack_convention[callstack_convention.length - 1].length; i++ ){\\n          callstack_convention[callstack_convention.length - 1][i].can_operate = (callstack_convention[callstack_convention.length - 1][i].name === instMatch[6]) ? true : callstack_convention[callstack_convention.length - 1][i].can_operate; \\n        }\\n      }\\n    }\\n\\n    \\n\\n    // var to_measure = \"\";\\n    var start_m, start_m;\\n    var cache_inst;\\n\\n    function writeMemory(value, addr) {\\n      // Primero pasar el valor al formato hexadecimal por pares\\n      if (value.startsWith(\"0x\"))\\n        value = value.slice(2);\\n      if (value.length % 2 !== 0)\\n        value = \"0\" + value;\\n\\n      // const bytes = new Uint8Array(value.length / 2);\\n      for (let i = 0; i < value.length / 2; i ++) {\\n        main_memory.write((addr + BigInt(i)), Number(\"0x\" + value.substring(i*2, i * 2 + 2)));\\n      }\\n\\n      // if (memoMatch[2] === \\'<-\\'){\\n      //     switch(op){\\n      //       case \\'sh\\': // Para almacenar un half\\n      //       writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'half\\');\\n      //       break;\\n      //       case \\'sb\\': // Para almacenar un byte\\n      //       writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'byte\\');\\n      //       break;\\n      //       case \\'sw\\': // Para almacenar un int/word\\n      //       writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'word\\');\\n      //       break;\\n      //       case \\'fsw\\': // Para almacenar un float\\n      //       writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'float\\');\\n      //       break;\\n      //       case \\'fsd\\': // Para almacenar un double\\n      //       writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'double\\');\\n      //       break;\\n      //       case \\'vse8.v\\':\\n      //       writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'byte\\');\\n      //         break;\\n      //       case \\'vse16.v\\':\\n      //       writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'half\\');\\n      //         break;\\n      //       case \\'vse32.v\\':\\n      //       writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'word\\');\\n      //         break;\\n      //       case \\'vse64.v\\':\\n      //         writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'double\\');\\n      //         break;\\n      //       default:\\n      //         break;\\n      //     }\\n      //   }\\n    }\\n\\n    // var no_print_more = false;\\n    Module[\\'print\\'] = function (message) {\\n      // console.log(message);\\n      if (message === \"Divergence execution detected: Aborted.\")\\n        show_notification(message, \"danger\");\\n      if (message === \"err call_convenction\")\\n        show_notification(\"Possible failure in the parameter passing convention\", \"warning\");\\n      \\n      if (message === \"May your execution has an infinity loop.\"){\\n        document.app.$data.execution_mode_run = 1;\\n        show_notification(\"May your execution has an infinity loop\", \"danger\");\\n        instructions[hiden_executed]._rowVariant = \"info\";\\n        instructions[hiden_next_execute]._rowVariant = \"success\";\\n      }\\n      \\n      var next_add_to_jump;\\n      let instMatch        = message.match(instructionExp);\\n      let regiMatch        = message.match(registerExp);\\n      let memoMatch        = message.match(memoryExp);\\n      let printMatch       = message.match(displayExp);\\n      let CSRMatch         = message.match(CSRTypeExp);\\n      let CSREMatch        = message.match(CSRExp);\\n      let vectorMatch      = message.match(vectorExp);\\n      let jumpMatch        = message.match(jumpExp);\\n      let cacheMatch       = message.match(cacheExp);\\n      let configCacheMatch = message.match(configCacheExp);\\n\\n      if (message.startsWith(\"Cache\") || message.startsWith(\"Next_PC:\")){\\n        if (message.includes(\"Cache prefetch\")) {\\n          let newpc = message.substring(15,message.length).toLowerCase();\\n          cache_inst = instructions.findIndex(insn => insn.Address === (\"0x\" + BigInt(newpc).toString(16)));\\n        } else if (message.includes(\"Next_PC:\")) {\\n          let newpc = message.substring(9, message.length).toLowerCase();\\n          cache_inst = instructions.findIndex(insn => insn.Address == (\"0x\" + BigInt(newpc).toString(16)));\\n        }\\n        if (cache_inst != -1 && document.app.$data.execution_mode_run === 1) {\\n          let hexmatch = message.match(/0x[0-9A-Fa-f]+$/);\\n          if (hexmatch && !message.startsWith(\"Cache prefetch\")) {\\n            let hexa = hexmatch[0];\\n            message = message.replace(/on:\\\\s*0x[0-9A-Fa-f]+$/, \"\").trim();\\n            updateCacheStat(cache_inst, message, hexa);\\n          }else {\\n            updateCacheStat(cache_inst, message);\\n          }\\n          \\n        }\\n      }\\n\\n\\n      if (jumpMatch){\\n        jumpMatch[1] = \"0x\" + jumpMatch[1].replace(/^0+/, \\'\\');\\n        if (jumpMatch[1] === \"0x\") jumpMatch[1] = \"0x0\";\\n        // console.log(jumpMatch);\\n        const current_ins = instructions.findIndex(insn => insn.Address === (jumpMatch[1].toLowerCase()));\\n        \\n          for (var i = 0; i < instructions.length; i++){\\n            if(instructions[i]._rowVariant === \"success\" && document.app.$data.execution_mode_run !== 0) // ajustar lo del user mode\\n              instructions[i]._rowVariant = \"\";\\n          }\\n        if (current_ins !== -1) instructions[current_ins]._rowVariant = \"success\";\\n      }\\n\\n      if (configCacheMatch) {\\n        // console.log(configCacheMatch);\\n        switch(configCacheMatch[1]) {\\n          case \"L1_I_SIZE\":\\n            config_cache.push({configuration: \"Size L1_I\", value: configCacheMatch[2] + \" lines\"});\\n            break;\\n          case \"L1_D_SIZE\":\\n            config_cache.push({configuration: \"Size L1_D\", value: configCacheMatch[2] + \" lines\"});\\n            break;\\n          case \"L1_SIZE\":\\n            config_cache.push({configuration: \"Size L1\", value: configCacheMatch[2] + \" lines\"});\\n            break;\\n          case \"L2_I_SIZE\":\\n            config_cache.push({configuration: \"Size L2_I\", value: configCacheMatch[2] + \" lines\"});\\n            break;\\n          case \"L2_D_SIZE\":\\n            config_cache.push({configuration: \"Size L2_D\", value: configCacheMatch[2] + \" lines\"});\\n            break;\\n          case \"L2_SIZE\":\\n            config_cache.push({configuration: \"Size L2\", value: configCacheMatch[2] + \" lines\"});\\n            break;\\n          case \"Rep_policy\":\\n            config_cache.push({configuration: \"Replacement policy\", value: configCacheMatch[2]});\\n            break;\\n          case \"L1_I_BLOCK_SIZE\":\\n            config_cache.push({configuration: \"Size Cache L1_I block\", value: configCacheMatch[2] + \" bits\"});\\n            break;\\n          case \"L1_D_BLOCK_SIZE\":\\n            config_cache.push({configuration: \"Size Cache L1_D block\", value: configCacheMatch[2] + \" bits\"});\\n            break;\\n          case \"L1_BLOCK_SIZE\":\\n            config_cache.push({configuration: \"Size Cache L1 block\", value: configCacheMatch[2] + \" bits\"});\\n            break;\\n          case \"L2_I_BLOCK_SIZE\":\\n            config_cache.push({configuration: \"Size Cache L2_I block\", value: configCacheMatch[2] + \" bits\"});\\n            break;\\n          case \"L2_D_BLOCK_SIZE\":\\n            config_cache.push({configuration: \"Size Cache L2_D block\", value: configCacheMatch[2] + \" bits\"});\\n            break;\\n          case \"L2_BLOCK_SIZE\":\\n            config_cache.push({configuration: \"Size Cache L2 block\", value: configCacheMatch[2] + \" bits\"});\\n            break;\\n        }\\n      }\\n\\n      if (cacheMatch) {\\n        console.log(cacheMatch);\\n        // updateCacheMem(parseInt(cacheMatch[1],10), cacheMatch[2], cacheMatch[3], parseInt(cacheMatch[4], 10));\\n        switch(cacheMatch[2]) {\\n          case \"L1_I\":\\n            updateCacheMem(parseInt(cacheMatch[1],10), cacheMatch[2], cacheMatch[3], document.app.$data.L1_I_size_block);\\n          break;\\n          case \"L1_D\":\\n            updateCacheMem(parseInt(cacheMatch[1],10), cacheMatch[2], cacheMatch[3], document.app.$data.L1_D_size_block);\\n            \\n          break;\\n          case \"L1\":\\n            updateCacheMem(parseInt(cacheMatch[1],10), cacheMatch[2], cacheMatch[3], document.app.$data.L1_size_block);\\n            \\n          break;\\n          case \"L2_I\":\\n            updateCacheMem(parseInt(cacheMatch[1],10), cacheMatch[2], cacheMatch[3], document.app.$data.L2_I_size_block);\\n            \\n          break;\\n          case \"L2_D\":\\n            updateCacheMem(parseInt(cacheMatch[1],10), cacheMatch[2], cacheMatch[3], document.app.$data.L2_D_size_block);\\n            \\n          break;\\n          case \"L2\":\\n            updateCacheMem(parseInt(cacheMatch[1],10), cacheMatch[2], cacheMatch[3], document.app.$data.L2_size_block);\\n            \\n          break;\\n\\n        }\\n      }\\n\\n      if(CSREMatch){\\n        console.log(CSREMatch);\\n        if (CSREMatch[2] !== \"vtype\" && CSREMatch[2] !== \"vl\"){\\n          let regtowrite = crex_findReg(CSREMatch[2]);\\n          if(regtowrite.match !== 0)\\n            writeRegister(CSREMatch[4], regtowrite.indexComp, regtowrite.indexElem);\\n        }\\n      }\\n      if (CSRMatch){\\n        if (CSRMatch[2] === \"vtype\"){\\n          var size_elem = parseInt(CSRMatch[5], 16).toString(2).padStart(32, \\'0\\');\\n          size_elem = size_elem.slice(26, 29);\\n          console.log(\"Tamaño: \", size_elem);\\n          if(size_elem === \"000\"){\\n            document.app.$data.v_length = 8;\\n            // length_vext = 8;\\n            // architecture.components[3].total_elements = 64;\\n          } else if (size_elem === \"001\") {\\n            document.app.$data.v_length = 16;\\n            // length_vext = 16;\\n            // architecture.components[3].total_elements = 32;\\n          } else if (size_elem === \"010\"){\\n            document.app.$data.v_length = 32;\\n            // length_vext = 32;\\n            // architecture.components[3].total_elements = 16;\\n          }else {\\n            document.app.$data.v_length = 64;\\n            // length_vext = 64;\\n            // architecture.components[3].total_elements = 8;\\n          }\\n          // architecture.components[3].length_elem = length_vext;\\n        }\\n        else if (CSRMatch[2] === \"vl\"){\\n          // architecture.components[3].elems_op = parseInt(CSRMatch[5], 16);\\n        }\\n      }\\n      if (vectorMatch){\\n        let regtowrite = crex_findReg(vectorMatch[1]);\\n        writeRegister(vectorMatch[3], regtowrite.indexComp, regtowrite.indexElem);\\n      }\\n      if (instMatch && /*(instMatch[2] === \\'U\\' ||*/ ((parseInt(instMatch[3], 16) >= pc_min) && parseInt(instMatch[3], 16) < parseInt(\"0x20000\", 16) )){\\n        clearAllRegisterGlows();\\n        coreEvents.emit(\"step-about-to-execute\");\\n        userMode64 = true;\\n        if (inside_function) \\n          check_call_convention_temp_regs(instMatch);\\n\\n\\n        //Actualizamos el pc\\n        writeRegister(BigInt(parseInt(instMatch[3], 16)), pc_sail.indexComp, pc_sail.indexElem);\\n        for (var i = 0; i < instructions.length; i++) {\\n          if (instructions[i]._rowVariant === \"info\")\\n            instructions[i]._rowVariant = \"\";\\n        }\\n        instoper = \"\";\\n        // console.log(\"PC actual:\",pc_sail);\\n        // if ((instMatch[5].includes(\"w\") || instMatch[5].includes(\".s\") || instMatch[5].includes(\".w\")) && !instMatch.includes(\".d\"))\\n        //   type_toWrite = 32;\\n        // else if (instMatch[5].includes(\"d\"))\\n        //   type_toWrite = 64;\\n        // else \\n        //   type_toWrite = 0;\\n        console.log(\"Instruccion: \", instMatch);\\n        const current_ins = instructions.findIndex(insn => ( \\'0x\\' + (insn.Address.slice(2)).padStart(16, \\'0\\')) === (\"0x\"+instMatch[3].toLowerCase()));\\n        if (current_ins !== -1) {\\n        if(prev_add_to_jump !== undefined){\\n          instructions[prev_add_to_jump]._rowVariant = \"\";\\n          prev_add_to_jump = undefined;\\n        }\\n\\n        if (instructions[current_ins].loaded.includes(\"jalr\")){\\n          var next_add = instructions[current_ins].loaded.split(\"\\\\t\");\\n          var match = next_add[1].match(/(-?\\\\d+)\\\\((\\\\w+)\\\\)/);\\n\\n          if (match === undefined || match === null) {\\n            match = \"zero\";\\n            var aux_reg = crex_findReg(match);\\n            var aux_val = readRegister(aux_reg.indexComp, aux_reg.indexElem);\\n            \\n            next_add_to_jump = aux_val.toString(16);\\n            next_add_to_jump = instructions.findIndex(insn => insn.Address === (\"0x\"+next_add_to_jump.toLowerCase()));\\n            prev_add_to_jump = current_ins;\\n          }else {\\n            var aux_reg = crex_findReg(match[2]);\\n            var aux_val = readRegister(aux_reg.indexComp, aux_reg.indexElem);\\n            \\n            next_add_to_jump = (aux_val + BigInt(parseInt(match[1], 10))).toString(16);\\n            next_add_to_jump = instructions.findIndex(insn => insn.Address === (\"0x\"+next_add_to_jump.toLowerCase()));\\n            prev_add_to_jump = current_ins;\\n          }\\n\\n          // creator_callstack_enter(instructions[next_add_to_jump].Label); \\n          // track_stack_enter(instructions[next_add_to_jump].Label);\\n          // callstack_convention.push(structuredClone(registers_before_function));\\n          // inside_function = true;\\n\\n          console.log(\"Siguiente direccion del jalr: \", next_add);\\n        } \\n        if (instructions[current_ins].loaded.includes(\"jal\") && !instructions[current_ins].loaded.includes(\"jalr\")){\\n          var next_add = instructions[current_ins].loaded.split(\"\\\\t\");\\n          console.log(\"Siguiente direccion del jal: \", next_add);\\n\\n        } \\n        if (instructions[current_ins].loaded.includes(\"ret\") && !instructions[current_ins].loaded.includes(\"mret\")){\\n          // Mirar el ra\\n          var aux_reg = crex_findReg(\"ra\");\\n          next_add_to_jump = readRegister(aux_reg.indexComp, aux_reg.indexElem).toString(16);\\n          next_add_to_jump = instructions.findIndex(insn => ( \\'0x\\' + (insn.Address.slice(2))) === (\"0x\"+next_add_to_jump.toLowerCase()));\\n          if (next_add_to_jump !== -1) {\\n            prev_add_to_jump = current_ins;\\n            // track_stack_leave();\\n            // creator_callstack_leave();\\n            // callstack_convention.pop();\\n            // inside_function = (callstack_convention.length > 0); \\n          } else {\\n            next_add_to_jump = undefined;\\n          }\\n        } \\n        // Primero caso de paso a paso\\n        if (document.app.$data.execution_mode_run === 1){\\n          instructions[current_ins]._rowVariant = \\'info\\';\\n          if (current_ins < instructions.length - 1 || next_add_to_jump !== undefined){\\n            instructions[(next_add_to_jump !== undefined) ? next_add_to_jump : (current_ins + 1)]._rowVariant = \\'success\\';\\n            document.app.$data.is_breakpoint = instructions[(next_add_to_jump !== undefined) ? next_add_to_jump : (current_ins + 1)].Break;\\n          }\\n          if (current_ins > 0 || prev_add_to_jump !== undefined)\\n            instructions[(prev_add_to_jump !== undefined && prev_add_to_jump !== current_ins) ? prev_add_to_jump : ((current_ins > 0) ? current_ins -1 : 0)]._rowVariant = \\'\\';\\n        }\\n        // Para el caso de run without stop y la siguiente instruccion es un breakpoint\\n        else if (document.app.$data.execution_mode_run === 0){\\n          // se almacena el estado de la instruccion en caso de que haya una parada por infinity loop\\n          hiden_executed = current_ins;\\n          if (current_ins < instructions.length - 1  || next_add_to_jump !== undefined) {\\n            hiden_next_execute = (next_add_to_jump !== undefined) ? next_add_to_jump : current_ins + 1;\\n          } else \\n            hiden_next_execute = current_ins + 1;\\n\\n\\n          if (current_ins < instructions.length - 1 || next_add_to_jump !== undefined) {\\n            document.app.$data.is_breakpoint = instructions[(next_add_to_jump !== undefined) ? next_add_to_jump : (current_ins + 1)].Break;\\n          }\\n          if(document.app.$data.is_breakpoint){\\n            instructions[current_ins]._rowVariant = \\'info\\';\\n            if (current_ins < instructions.length - 1  || next_add_to_jump !== undefined) {\\n              instructions[(next_add_to_jump !== undefined) ? next_add_to_jump : (current_ins + 1)]._rowVariant = \\'success\\';\\n            }\\n            coreEvents.emit(\"pause-execution\");\\n          }else {\\n            instructions[current_ins]._rowVariant = \\'\\';\\n          }\\n          if (current_ins > 0  || prev_add_to_jump !== undefined)\\n            instructions[(prev_add_to_jump !== undefined && prev_add_to_jump !== current_ins) ? prev_add_to_jump : ((current_ins > 0) ? current_ins -1 : 0)]._rowVariant = \\'\\';\\n\\n        }\\n        else\\n          instructions[current_ins]._rowVariant = \\'\\';\\n        \\n        if (instMatch[5] === \"ecall\"){\\n          let argument_register = crex_findReg(\"a7\"); // obtenemos el registro para ver que llamada al sistema es\\n          let syscall_code = readRegister(argument_register.indexComp, argument_register.indexElem); // Lectura del registro para obtener el valor\\n      \\n          switch(syscall_code){\\n            case 5n:\\n              if(document.app.$data.execution_mode_run === 0){\\n                insn_number = current_ins;\\n                instructions[current_ins]._rowVariant = \"info\";\\n                if (current_ins < instructions.length -1  || next_add_to_jump !== undefined)\\n                  instructions[(next_add_to_jump !== undefined) ? next_add_to_jump : (current_ins + 1)]._rowVariant = \\'success\\';\\n                  // instructions[current_ins +1]._rowVariant = \"success\";\\n              }\\n              document.app.$data.last_execution_mode_run = document.app.$data.execution_mode_run;\\n              document.app.$data.execution_mode_run = 2;\\n              // last_execution_mode_run = document.app.$data.execution_mode_run;\\n              // document.app.$data.execution_mode_run = 2;\\n              // Manejo para enteros\\n              // capi_read_int(\\'a0\\');\\n              SYSCALL.read(\\'a0\\', \"int\");\\n              break;\\n            case 6n:\\n              if(document.app.$data.execution_mode_run === 0){\\n                insn_number = current_ins;\\n                instructions[current_ins]._rowVariant = \"info\";\\n                if (current_ins < instructions.length -1 || next_add_to_jump !== undefined)\\n                  instructions[(next_add_to_jump !== undefined) ? next_add_to_jump : (current_ins + 1)]._rowVariant = \\'success\\';\\n            \\n                  // instructions[current_ins +1]._rowVariant = \"success\";\\n              }\\n              document.app.$data.last_execution_mode_run = document.app.$data.execution_mode_run;\\n              document.app.$data.execution_mode_run = 2;\\n              // last_execution_mode_run = document.app.$data.execution_mode_run;\\n              // document.app.$data.execution_mode_run = 2;\\n              // Manejo para floats\\n              // capi_read_float(\\'fa0\\');\\n              SYSCALL.read(\"fa0\", \"float\");\\n              break;\\n            case 7n:\\n              if(document.app.$data.execution_mode_run === 0){\\n                insn_number = current_ins;\\n                instructions[current_ins]._rowVariant = \"info\";\\n                if (current_ins < instructions.length -1 || next_add_to_jump !== undefined)\\n                  instructions[(next_add_to_jump !== undefined) ? next_add_to_jump : (current_ins + 1)]._rowVariant = \\'success\\';\\n            \\n                  // instructions[current_ins +1]._rowVariant = \"success\";\\n              }\\n              document.app.$data.last_execution_mode_run = document.app.$data.execution_mode_run;\\n              document.app.$data.execution_mode_run = 2;\\n              // Manejo para double\\n              // capi_read_double(\\'fa0\\');\\n              SYSCALL.read(\"fa0\", \"double\");\\n              break;\\n            case 8n:\\n              if(document.app.$data.execution_mode_run === 0){\\n                insn_number = current_ins;\\n                instructions[current_ins]._rowVariant = \"info\";\\n                if (current_ins < instructions.length -1 || next_add_to_jump !== undefined)\\n                  instructions[(next_add_to_jump !== undefined) ? next_add_to_jump : (current_ins + 1)]._rowVariant = \\'success\\';\\n            \\n                  // instructions[current_ins +1]._rowVariant = \"success\";\\n              }\\n              document.app.$data.last_execution_mode_run = document.app.$data.execution_mode_run;\\n              document.app.$data.execution_mode_run = 2;\\n              // Manejo para strings\\n              // capi_read_string(\\'a0\\',\\'a1\\');\\n              SYSCALL.read(\"a0\", \"string\", \"a1\");\\n              break;\\n      \\n            case 12n:\\n              if(document.app.$data.execution_mode_run === 0){\\n                instructions[current_ins]._rowVariant = \"info\";\\n                if (current_ins < instructions.length -1 || next_add_to_jump !== undefined)\\n                  instructions[(next_add_to_jump !== undefined) ? next_add_to_jump : (current_ins + 1)]._rowVariant = \\'success\\';\\n                  // instructions[current_ins +1]._rowVariant = \"success\";\\n              }\\n              document.app.$data.last_execution_mode_run = document.app.$data.execution_mode_run;\\n              document.app.$data.execution_mode_run = 2;\\n              // last_execution_mode_run = document.app.$data.execution_mode_run;\\n              // document.app.$data.execution_mode_run = 2;\\n              // Manejo para char\\n              // capi_read_char(\\'a0\\');\\n              SYSCALL.read(\"a0\", \"char\");\\n              break;\\n            default:\\n              // console.log(\"No hago nada.\");\\n              syscall_print_code = syscall_code;\\n              break;\\n          }\\n      \\n          next_add_to_jump = undefined;\\n        }\\n\\n\\n\\n        instoper = instMatch[5];\\n\\n      }\\n\\n      } else if (instMatch && (parseInt(instMatch[3], 16) <= pc_min || parseInt(instMatch[3], 16) >= pc_max ))\\n        userMode64 = false;\\n\\n\\n      if (regiMatch /*&& userMode === true*/) {\\n        // En caso de ser escritura \\'<-\\' pintamos el valor en el registro que corresponde\\n        if (regiMatch[2] === \\'<-\\'){\\n          let regtowrite = crex_findReg(regiMatch[1]);\\n          if (regtowrite.indexComp === 2){\\n            if (regiMatch[3].startsWith(\"0x\")) regiMatch[3] = regiMatch[3].slice(2).replace(/^0+/, \\'\\');\\n            else regiMatch[3] = regiMatch[3].replace(/^0+/, \\'\\');\\n            if (regiMatch[3].length <= 8){\\n              regiMatch[3] = regiMatch[3].padStart(8, \"0\");\\n              writeRegister(BigInt(\"0x\" + regiMatch[3]), regtowrite.indexComp, regtowrite.indexElem, \"SFP-Reg\");\\n            }\\n            else{\\n              // if (type_toWrite === 32){\\n              //   regiMatch[3] = regiMatch[3].slice(8,16);\\n              //   writeRegister(hex2float(regiMatch[3]), regtowrite.indexComp, regtowrite.indexElem, \"SFP-Reg\");\\n              // }\\n              // else if (type_toWrite === 64)\\n              //   writeRegister(hex2double(regiMatch[3]), regtowrite.indexComp, regtowrite.indexElem, \"DFP-Reg\");\\n              // else \\n                writeRegister(BigInt(\"0x\" + regiMatch[3]), regtowrite.indexComp, regtowrite.indexElem, \"DFP-Reg\");\\n              // type_to_write = 0;\\n            }\\n          }\\n          else  \\n            writeRegister(BigInt(parseInt(regiMatch[3], 16)), regtowrite.indexComp, regtowrite.indexElem);\\n        }\\n        \\n      }\\n\\n      if (memoMatch /*&& userMode === true*/) {\\n        // En caso de ser escritura \\'<-\\' pintamos el valor en la posicion de memoria\\n        if (memoMatch[2] === \\'<-\\'){\\n\\n          writeMemory(memoMatch[3], BigInt(parseInt(memoMatch[1], 16)));\\n          // console.log(\"Operador: \", instoper);\\n          // switch(instoper){\\n          //   case \\'sh\\': // Para almacenar un half\\n          // writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'half\\');\\n              \\n          //   break;\\n          //   case \\'sb\\': // Para almacenar un byte\\n          //     writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'byte\\');\\n          //   break;\\n          //   case \\'sd\\':\\n          //     writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'dword\\');\\n          //   break;\\n          //   case \\'sw\\': // Para almacenar un int/word\\n          //     writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'word\\');\\n          //   break;\\n          //   case \\'fsw\\': // Para almacenar un float\\n          //     writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'float\\');\\n          //   break;\\n          //   case \\'fsd\\': // Para almacenar un double\\n          //     writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'double\\');\\n          //   break;\\n          //   case \\'vse8.v\\':\\n          //     writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'byte\\');\\n          //     break;\\n          //   case \\'vse16.v\\':\\n          //     writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'half\\');\\n          //     break;\\n          //   case \\'vse32.v\\':\\n          //     writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'word\\');\\n          //     break;\\n          //   case \\'vse64.v\\':\\n          //     writeMemory(memoMatch[3], parseInt(memoMatch[1], 16), \\'double\\');\\n          //     break;\\n          //   default:\\n          //     break;\\n          // }\\n\\n          // instoper = \"\";\\n        }\\n      \\n      }\\n\\n      \\n\\n      if(printMatch && syscall_print_code !== -1){\\n\\n        let value_2_print = printMatch[2].trim();\\n        console.log(\"Estoy dentro de ecall a imprimir\");\\n        // console.log(message);\\n        console.log(\"Valor a imprimir: \", value_2_print); \\n        switch(syscall_print_code){\\n\\n          case 1n: // Print int\\n            // SYSCALL.print(Number(parseInt(value_2_print)), \"int32\");\\n\\n            display_print(value_2_print);\\n            // display_print(full_print(parseInt(value_2_print), null, false));\\n            syscall_print_code = -1;\\n            break;\\n          case 2n: // Print float\\n            // SYSCALL.print(Number(parseFloat(value_2_print)), \"float\");\\n            display_print(value_2_print);\\n            // display_print(full_print(parseFloat(value_2_print), 0, true));\\n            syscall_print_code = -1;\\n            break;\\n\\n          case 3n: // Print double\\n            // SYSCALL.print(Number(parseFloat(value_2_print)), \"double\");\\n            display_print(value_2_print);\\n            // display_print(full_print(parseFloat(value_2_print), 0, true));\\n            syscall_print_code = -1;\\n            break;\\n\\n          case 4n: // Print String \\n            display_print(value_2_print);\\n            syscall_print_code = -1;\\n            break;\\n\\n          case 11n: // Print char\\n            // SYSCALL.print(BigInt(value_2_print.charCodeAt(0)), char);\\n            display_print(value_2_print);\\n            syscall_print_code = -1;\\n            break;\\n\\n          default: // Rest of syscall codes not able to print\\n          syscall_print_code = -1;\\n            break;\\n\\n        }\\n\\n      }\\n\\n\\n\\n      // if (!no_print_more)\\n        console.log(message);\\n\\n    }\\n\\n    Module[\\'printErr\\'] = function (message) {\\n      // if (message.includes(\"Execution:\") || message.includes(\"Instructions:\") || message.includes(\"Perf:\"))\\n      //   show_notification(message, \"success\");\\n      // else \\n      console.warn(message);\\n    }\\n\\n\\n    var out = Module[\"print\"] /*|| console.log.bind(console)*/;\\n    var err = Module[\"printErr\"] /*|| console.error.bind(console)*/;\\n\\n\\n    Object.assign(Module, moduleOverrides);\\n    moduleOverrides = null;\\n    checkIncomingModuleAPI();\\n    if (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\\n    legacyModuleProp(\"arguments\", \"arguments_\");\\n    if (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\\n    legacyModuleProp(\"thisProgram\", \"thisProgram\");\\n    assert(\\n      typeof Module[\"memoryInitializerPrefixURL\"] == \"undefined\",\\n      \"Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead\",\\n    );\\n    assert(\\n      typeof Module[\"pthreadMainPrefixURL\"] == \"undefined\",\\n      \"Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead\",\\n    );\\n    assert(\\n      typeof Module[\"cdInitializerPrefixURL\"] == \"undefined\",\\n      \"Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead\",\\n    );\\n    assert(\\n      typeof Module[\"filePackagePrefixURL\"] == \"undefined\",\\n      \"Module.filePackagePrefixURL option was removed, use Module.locateFile instead\",\\n    );\\n    assert(\\n      typeof Module[\"read\"] == \"undefined\",\\n      \"Module.read option was removed\",\\n    );\\n    assert(\\n      typeof Module[\"readAsync\"] == \"undefined\",\\n      \"Module.readAsync option was removed (modify readAsync in JS)\",\\n    );\\n    assert(\\n      typeof Module[\"readBinary\"] == \"undefined\",\\n      \"Module.readBinary option was removed (modify readBinary in JS)\",\\n    );\\n    assert(\\n      typeof Module[\"setWindowTitle\"] == \"undefined\",\\n      \"Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)\",\\n    );\\n    assert(\\n      typeof Module[\"TOTAL_MEMORY\"] == \"undefined\",\\n      \"Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY\",\\n    );\\n    legacyModuleProp(\"asm\", \"wasmExports\");\\n    legacyModuleProp(\"readAsync\", \"readAsync\");\\n    legacyModuleProp(\"readBinary\", \"readBinary\");\\n    legacyModuleProp(\"setWindowTitle\", \"setWindowTitle\");\\n    assert(\\n      !ENVIRONMENT_IS_WORKER,\\n      \"worker environment detected but not enabled at build time.  Add `worker` to `-sENVIRONMENT` to enable.\",\\n    );\\n    assert(\\n      !ENVIRONMENT_IS_NODE,\\n      \"node environment detected but not enabled at build time.  Add `node` to `-sENVIRONMENT` to enable.\",\\n    );\\n    assert(\\n      !ENVIRONMENT_IS_SHELL,\\n      \"shell environment detected but not enabled at build time.  Add `shell` to `-sENVIRONMENT` to enable.\",\\n    );\\n    var wasmBinary = Module[\"wasmBinary\"];\\n    legacyModuleProp(\"wasmBinary\", \"wasmBinary\");\\n    if (typeof WebAssembly != \"object\") {\\n      err(\"no native wasm support detected\");\\n    }\\n    var wasmMemory;\\n    var ABORT = false;\\n    var EXITSTATUS;\\n    function assert(condition, text) {\\n      if (!condition) {\\n        abort(\"Assertion failed\" + (text ? \": \" + text : \"\"));\\n      }\\n    }\\n    var HEAP8,\\n      HEAPU8,\\n      HEAP16,\\n      HEAPU16,\\n      HEAP32,\\n      HEAPU32,\\n      HEAPF32,\\n      HEAP64,\\n      HEAPU64,\\n      HEAPF64;\\n    var runtimeInitialized = false;\\n    var isFileURI = (filename) => filename.startsWith(\"file://\");\\n    function writeStackCookie() {\\n      var max = _emscripten_stack_get_end();\\n      assert((max & 3) == 0);\\n      if (max == 0) {\\n        max += 4;\\n      }\\n      HEAPU32[max / 4] = 34821223;\\n      HEAPU32[(max + 4) / 4] = 2310721022;\\n      HEAPU32[0 / 4] = 1668509029;\\n    }\\n    function checkStackCookie() {\\n      if (ABORT) return;\\n      var max = _emscripten_stack_get_end();\\n      if (max == 0) {\\n        max += 4;\\n      }\\n      var cookie1 = HEAPU32[max / 4];\\n      var cookie2 = HEAPU32[(max + 4) / 4];\\n      if (cookie1 != 34821223 || cookie2 != 2310721022) {\\n        abort(\\n          `Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`,\\n        );\\n      }\\n      if (HEAPU32[0 / 4] != 1668509029) {\\n        abort(\\n          \"Runtime error: The application has corrupted its heap memory area (address zero)!\",\\n        );\\n      }\\n    }\\n    (() => {\\n      var h16 = new Int16Array(1);\\n      var h8 = new Int8Array(h16.buffer);\\n      h16[0] = 25459;\\n      if (h8[0] !== 115 || h8[1] !== 99)\\n        throw \"Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)\";\\n    })();\\n    if (Module[\"ENVIRONMENT\"]) {\\n      throw new Error(\\n        \"Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)\",\\n      );\\n    }\\n    function legacyModuleProp(prop, newName, incoming = true) {\\n      if (!Object.getOwnPropertyDescriptor(Module, prop)) {\\n        Object.defineProperty(Module, prop, {\\n          configurable: true,\\n          get() {\\n            let extra = incoming\\n              ? \" (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\"\\n              : \"\";\\n            abort(\\n              `\\\\`Module.${prop}\\\\` has been replaced by \\\\`${newName}\\\\`` + extra,\\n            );\\n          },\\n        });\\n      }\\n    }\\n    function ignoredModuleProp(prop) {\\n      if (Object.getOwnPropertyDescriptor(Module, prop)) {\\n        abort(\\n          `\\\\`Module.${prop}\\\\` was supplied but \\\\`${prop}\\\\` not included in INCOMING_MODULE_JS_API`,\\n        );\\n      }\\n    }\\n    function isExportedByForceFilesystem(name) {\\n      return (\\n        name === \"FS_createPath\" ||\\n        name === \"FS_createDataFile\" ||\\n        name === \"FS_createPreloadedFile\" ||\\n        name === \"FS_unlink\" ||\\n        name === \"addRunDependency\" ||\\n        name === \"FS_createLazyFile\" ||\\n        name === \"FS_createDevice\" ||\\n        name === \"removeRunDependency\"\\n      );\\n    }\\n    function hookGlobalSymbolAccess(sym, func) {\\n      if (\\n        typeof globalThis != \"undefined\" &&\\n        !Object.getOwnPropertyDescriptor(globalThis, sym)\\n      ) {\\n        Object.defineProperty(globalThis, sym, {\\n          configurable: true,\\n          get() {\\n            func();\\n            return undefined;\\n          },\\n        });\\n      }\\n    }\\n    function missingGlobal(sym, msg) {\\n      hookGlobalSymbolAccess(sym, () => {\\n        warnOnce(`\\\\`${sym}\\\\` is not longer defined by emscripten. ${msg}`);\\n      });\\n    }\\n    missingGlobal(\"buffer\", \"Please use HEAP8.buffer or wasmMemory.buffer\");\\n    missingGlobal(\"asm\", \"Please use wasmExports instead\");\\n    function missingLibrarySymbol(sym) {\\n      hookGlobalSymbolAccess(sym, () => {\\n        var msg = `\\\\`${sym}\\\\` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line`;\\n        var librarySymbol = sym;\\n        if (!librarySymbol.startsWith(\"_\")) {\\n          librarySymbol = \"$\" + sym;\\n        }\\n        msg += ` (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE=\\'${librarySymbol}\\')`;\\n        if (isExportedByForceFilesystem(sym)) {\\n          msg +=\\n            \". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you\";\\n        }\\n        warnOnce(msg);\\n      });\\n      unexportedRuntimeSymbol(sym);\\n    }\\n    function unexportedRuntimeSymbol(sym) {\\n      if (!Object.getOwnPropertyDescriptor(Module, sym)) {\\n        Object.defineProperty(Module, sym, {\\n          configurable: true,\\n          get() {\\n            var msg = `\\'${sym}\\' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`;\\n            if (isExportedByForceFilesystem(sym)) {\\n              msg +=\\n                \". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you\";\\n            }\\n            abort(msg);\\n          },\\n        });\\n      }\\n    }\\n    function updateMemoryViews() {\\n      var b = wasmMemory.buffer;\\n      Module[\"HEAP8\"] = HEAP8 = new Int8Array(b);\\n      Module[\"HEAP16\"] = HEAP16 = new Int16Array(b);\\n      Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(b);\\n      Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(b);\\n      Module[\"HEAP32\"] = HEAP32 = new Int32Array(b);\\n      Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(b);\\n      Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(b);\\n      Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(b);\\n      Module[\"HEAP64\"] = HEAP64 = new BigInt64Array(b);\\n      Module[\"HEAPU64\"] = HEAPU64 = new BigUint64Array(b);\\n    }\\n    assert(\\n      !Module[\"STACK_SIZE\"],\\n      \"STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time\",\\n    );\\n    assert(\\n      typeof Int32Array != \"undefined\" &&\\n        typeof Float64Array !== \"undefined\" &&\\n        Int32Array.prototype.subarray != undefined &&\\n        Int32Array.prototype.set != undefined,\\n      \"JS engine does not provide full typed array support\",\\n    );\\n    assert(\\n      !Module[\"wasmMemory\"],\\n      \"Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally\",\\n    );\\n    assert(\\n      !Module[\"INITIAL_MEMORY\"],\\n      \"Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically\",\\n    );\\n    function preRun() {\\n      if (Module[\"preRun\"]) {\\n        if (typeof Module[\"preRun\"] == \"function\")\\n          Module[\"preRun\"] = [Module[\"preRun\"]];\\n        while (Module[\"preRun\"].length) {\\n          addOnPreRun(Module[\"preRun\"].shift());\\n        }\\n      }\\n      callRuntimeCallbacks(onPreRuns);\\n    }\\n    function initRuntime() {\\n      assert(!runtimeInitialized);\\n      runtimeInitialized = true;\\n      checkStackCookie();\\n      if (!Module[\"noFSInit\"] && !FS.initialized) FS.init();\\n      TTY.init();\\n      wasmExports[\"__wasm_call_ctors\"]();\\n      FS.ignorePermissions = false;\\n    }\\n    function preMain() {\\n      checkStackCookie();\\n    }\\n    function postRun() {\\n      checkStackCookie();\\n      if (Module[\"postRun\"]) {\\n        if (typeof Module[\"postRun\"] == \"function\")\\n          Module[\"postRun\"] = [Module[\"postRun\"]];\\n        while (Module[\"postRun\"].length) {\\n          addOnPostRun(Module[\"postRun\"].shift());\\n        }\\n      }\\n      callRuntimeCallbacks(onPostRuns);\\n    }\\n    var runDependencies = 0;\\n    var dependenciesFulfilled = null;\\n    var runDependencyTracking = {};\\n    var runDependencyWatcher = null;\\n    function getUniqueRunDependency(id) {\\n      var orig = id;\\n      while (1) {\\n        if (!runDependencyTracking[id]) return id;\\n        id = orig + Math.random();\\n      }\\n    }\\n    function addRunDependency(id) {\\n      runDependencies++;\\n      Module[\"monitorRunDependencies\"]?.(runDependencies);\\n      if (id) {\\n        assert(!runDependencyTracking[id]);\\n        runDependencyTracking[id] = 1;\\n        if (\\n          runDependencyWatcher === null &&\\n          typeof setInterval != \"undefined\"\\n        ) {\\n          runDependencyWatcher = setInterval(() => {\\n            if (ABORT) {\\n              clearInterval(runDependencyWatcher);\\n              runDependencyWatcher = null;\\n              return;\\n            }\\n            var shown = false;\\n            for (var dep in runDependencyTracking) {\\n              if (!shown) {\\n                shown = true;\\n                err(\"still waiting on run dependencies:\");\\n              }\\n              err(`dependency: ${dep}`);\\n            }\\n            if (shown) {\\n              err(\"(end of list)\");\\n            }\\n          }, 1e4);\\n        }\\n      } else {\\n        err(\"warning: run dependency added without ID\");\\n      }\\n    }\\n    function removeRunDependency(id) {\\n      runDependencies--;\\n      Module[\"monitorRunDependencies\"]?.(runDependencies);\\n      if (id) {\\n        assert(runDependencyTracking[id]);\\n        delete runDependencyTracking[id];\\n      } else {\\n        err(\"warning: run dependency removed without ID\");\\n      }\\n      if (runDependencies == 0) {\\n        if (runDependencyWatcher !== null) {\\n          clearInterval(runDependencyWatcher);\\n          runDependencyWatcher = null;\\n        }\\n        if (dependenciesFulfilled) {\\n          var callback = dependenciesFulfilled;\\n          dependenciesFulfilled = null;\\n          callback();\\n        }\\n      }\\n    }\\n    function abort(what) {\\n      Module[\"onAbort\"]?.(what);\\n      what = \"Aborted(\" + what + \")\";\\n      err(what);\\n      ABORT = true;\\n      if (what.indexOf(\"RuntimeError: unreachable\") >= 0) {\\n        what +=\\n          \\'. \"unreachable\" may be due to ASYNCIFY_STACK_SIZE not being large enough (try increasing it)\\';\\n      }\\n      var e = new WebAssembly.RuntimeError(what);\\n      readyPromiseReject(e);\\n      throw e;\\n    }\\n    function createExportWrapper(name, nargs) {\\n      return (...args) => {\\n        assert(\\n          runtimeInitialized,\\n          `native function \\\\`${name}\\\\` called before runtime initialization`,\\n        );\\n        var f = wasmExports[name];\\n        assert(f, `exported native function \\\\`${name}\\\\` not found`);\\n        assert(\\n          args.length <= nargs,\\n          `native function \\\\`${name}\\\\` called with ${args.length} args but expects ${nargs}`,\\n        );\\n        return f(...args);\\n      };\\n    }\\n    var wasmBinaryFile;\\n    function findWasmBinary() {\\n      if (Module[\"locateFile\"]) {\\n        return locateFile(\"riscv_sim_RV64.wasm\");\\n      }\\n      return new URL(\"riscv_sim_RV64.wasm\", import.meta.url).href;\\n    }\\n    function getBinarySync(file) {\\n      if (file == wasmBinaryFile && wasmBinary) {\\n        return new Uint8Array(wasmBinary);\\n      }\\n      if (readBinary) {\\n        return readBinary(file);\\n      }\\n      throw \"both async and sync fetching of the wasm failed\";\\n    }\\n    async function getWasmBinary(binaryFile) {\\n      if (!wasmBinary) {\\n        try {\\n          var response = await readAsync(binaryFile);\\n          return new Uint8Array(response);\\n        } catch {}\\n      }\\n      return getBinarySync(binaryFile);\\n    }\\n    async function instantiateArrayBuffer(binaryFile, imports) {\\n      try {\\n        var binary = await getWasmBinary(binaryFile);\\n        var instance = await WebAssembly.instantiate(binary, imports);\\n        return instance;\\n      } catch (reason) {\\n        err(`failed to asynchronously prepare wasm: ${reason}`);\\n        if (isFileURI(wasmBinaryFile)) {\\n          err(\\n            `warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`,\\n          );\\n        }\\n        abort(reason);\\n      }\\n    }\\n    async function instantiateAsync(binary, binaryFile, imports) {\\n      if (!binary && typeof WebAssembly.instantiateStreaming == \"function\") {\\n        try {\\n          var response = fetch(binaryFile, { credentials: \"same-origin\" });\\n          var instantiationResult = await WebAssembly.instantiateStreaming(\\n            response,\\n            imports,\\n          );\\n          return instantiationResult;\\n        } catch (reason) {\\n          err(`wasm streaming compile failed: ${reason}`);\\n          err(\"falling back to ArrayBuffer instantiation\");\\n        }\\n      }\\n      return instantiateArrayBuffer(binaryFile, imports);\\n    }\\n    function getWasmImports() {\\n      Asyncify.instrumentWasmImports(wasmImports);\\n      return { env: wasmImports, wasi_snapshot_preview1: wasmImports };\\n    }\\n    async function createWasm() {\\n      function receiveInstance(instance, module) {\\n        wasmExports = instance.exports;\\n        wasmExports = Asyncify.instrumentWasmExports(wasmExports);\\n        wasmExports = applySignatureConversions(wasmExports);\\n        wasmMemory = wasmExports[\"memory\"];\\n        assert(wasmMemory, \"memory not found in wasm exports\");\\n        updateMemoryViews();\\n        removeRunDependency(\"wasm-instantiate\");\\n        return wasmExports;\\n      }\\n      addRunDependency(\"wasm-instantiate\");\\n      var trueModule = Module;\\n      function receiveInstantiationResult(result) {\\n        assert(\\n          Module === trueModule,\\n          \"the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?\",\\n        );\\n        trueModule = null;\\n        return receiveInstance(result[\"instance\"]);\\n      }\\n      var info = getWasmImports();\\n      if (Module[\"instantiateWasm\"]) {\\n        return new Promise((resolve, reject) => {\\n          try {\\n            Module[\"instantiateWasm\"](info, (mod, inst) => {\\n              receiveInstance(mod, inst);\\n              resolve(mod.exports);\\n            });\\n          } catch (e) {\\n            err(`Module.instantiateWasm callback failed with error: ${e}`);\\n            reject(e);\\n          }\\n        });\\n      }\\n      wasmBinaryFile ??= findWasmBinary();\\n      try {\\n        var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);\\n        var exports = receiveInstantiationResult(result);\\n        return exports;\\n      } catch (e) {\\n        readyPromiseReject(e);\\n        return Promise.reject(e);\\n      }\\n    }\\n    class ExitStatus {\\n      name = \"ExitStatus\";\\n      constructor(status) {\\n        this.message = `Program terminated with exit(${status})`;\\n        this.status = status;\\n      }\\n    }\\n    var callRuntimeCallbacks = (callbacks) => {\\n      while (callbacks.length > 0) {\\n        callbacks.shift()(Module);\\n      }\\n    };\\n    var onPostRuns = [];\\n    var addOnPostRun = (cb) => onPostRuns.unshift(cb);\\n    var onPreRuns = [];\\n    var addOnPreRun = (cb) => onPreRuns.unshift(cb);\\n    var noExitRuntime = Module[\"noExitRuntime\"] || true;\\n    var ptrToString = (ptr) => {\\n      assert(typeof ptr === \"number\");\\n      return \"0x\" + ptr.toString(16).padStart(8, \"0\");\\n    };\\n    var stackRestore = (val) => __emscripten_stack_restore(val);\\n    var stackSave = () => _emscripten_stack_get_current();\\n    var warnOnce = (text) => {\\n      warnOnce.shown ||= {};\\n      if (!warnOnce.shown[text]) {\\n        warnOnce.shown[text] = 1;\\n        err(text);\\n      }\\n    };\\n    var INT53_MAX = 9007199254740992;\\n    var INT53_MIN = -9007199254740992;\\n    var bigintToI53Checked = (num) =>\\n      num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);\\n    var UTF8Decoder =\\n      typeof TextDecoder != \"undefined\" ? new TextDecoder() : undefined;\\n    var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {\\n      var endIdx = idx + maxBytesToRead;\\n      var endPtr = idx;\\n      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\\n      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\\n        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\\n      }\\n      var str = \"\";\\n      while (idx < endPtr) {\\n        var u0 = heapOrArray[idx++];\\n        if (!(u0 & 128)) {\\n          str += String.fromCharCode(u0);\\n          continue;\\n        }\\n        var u1 = heapOrArray[idx++] & 63;\\n        if ((u0 & 224) == 192) {\\n          str += String.fromCharCode(((u0 & 31) << 6) | u1);\\n          continue;\\n        }\\n        var u2 = heapOrArray[idx++] & 63;\\n        if ((u0 & 240) == 224) {\\n          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\\n        } else {\\n          if ((u0 & 248) != 240)\\n            warnOnce(\\n              \"Invalid UTF-8 leading byte \" +\\n                ptrToString(u0) +\\n                \" encountered when deserializing a UTF-8 string in wasm memory to a JS string!\",\\n            );\\n          u0 =\\n            ((u0 & 7) << 18) |\\n            (u1 << 12) |\\n            (u2 << 6) |\\n            (heapOrArray[idx++] & 63);\\n        }\\n        if (u0 < 65536) {\\n          str += String.fromCharCode(u0);\\n        } else {\\n          var ch = u0 - 65536;\\n          str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));\\n        }\\n      }\\n      return str;\\n    };\\n    var UTF8ToString = (ptr, maxBytesToRead) => {\\n      assert(\\n        typeof ptr == \"number\",\\n        `UTF8ToString expects a number (got ${typeof ptr})`,\\n      );\\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\\n    };\\n    function ___assert_fail(condition, filename, line, func) {\\n      condition = bigintToI53Checked(condition);\\n      filename = bigintToI53Checked(filename);\\n      func = bigintToI53Checked(func);\\n      return abort(\\n        `Assertion failed: ${UTF8ToString(condition)}, at: ` +\\n          [\\n            filename ? UTF8ToString(filename) : \"unknown filename\",\\n            line,\\n            func ? UTF8ToString(func) : \"unknown function\",\\n          ],\\n      );\\n    }\\n    var syscallGetVarargP = () => {\\n      assert(SYSCALLS.varargs != undefined);\\n      var ret = Number(HEAPU64[SYSCALLS.varargs / 8]);\\n      SYSCALLS.varargs += 8;\\n      return ret;\\n    };\\n    var syscallGetVarargI = () => {\\n      assert(SYSCALLS.varargs != undefined);\\n      var ret = HEAP32[+SYSCALLS.varargs / 4];\\n      SYSCALLS.varargs += 4;\\n      return ret;\\n    };\\n    var PATH = {\\n      isAbs: (path) => path.charAt(0) === \"/\",\\n      splitPath: (filename) => {\\n        var splitPathRe =\\n          /^(\\\\/?|)([\\\\s\\\\S]*?)((?:\\\\.{1,2}|[^\\\\/]+?|)(\\\\.[^.\\\\/]*|))(?:[\\\\/]*)$/;\\n        return splitPathRe.exec(filename).slice(1);\\n      },\\n      normalizeArray: (parts, allowAboveRoot) => {\\n        var up = 0;\\n        for (var i = parts.length - 1; i >= 0; i--) {\\n          var last = parts[i];\\n          if (last === \".\") {\\n            parts.splice(i, 1);\\n          } else if (last === \"..\") {\\n            parts.splice(i, 1);\\n            up++;\\n          } else if (up) {\\n            parts.splice(i, 1);\\n            up--;\\n          }\\n        }\\n        if (allowAboveRoot) {\\n          for (; up; up--) {\\n            parts.unshift(\"..\");\\n          }\\n        }\\n        return parts;\\n      },\\n      normalize: (path) => {\\n        var isAbsolute = PATH.isAbs(path),\\n          trailingSlash = path.slice(-1) === \"/\";\\n        path = PATH.normalizeArray(\\n          path.split(\"/\").filter((p) => !!p),\\n          !isAbsolute,\\n        ).join(\"/\");\\n        if (!path && !isAbsolute) {\\n          path = \".\";\\n        }\\n        if (path && trailingSlash) {\\n          path += \"/\";\\n        }\\n        return (isAbsolute ? \"/\" : \"\") + path;\\n      },\\n      dirname: (path) => {\\n        var result = PATH.splitPath(path),\\n          root = result[0],\\n          dir = result[1];\\n        if (!root && !dir) {\\n          return \".\";\\n        }\\n        if (dir) {\\n          dir = dir.slice(0, -1);\\n        }\\n        return root + dir;\\n      },\\n      basename: (path) => path && path.match(/([^\\\\/]+|\\\\/)\\\\/*$/)[1],\\n      join: (...paths) => PATH.normalize(paths.join(\"/\")),\\n      join2: (l, r) => PATH.normalize(l + \"/\" + r),\\n    };\\n    var initRandomFill = () => (view) => crypto.getRandomValues(view);\\n    var randomFill = (view) => {\\n      (randomFill = initRandomFill())(view);\\n    };\\n    var PATH_FS = {\\n      resolve: (...args) => {\\n        var resolvedPath = \"\",\\n          resolvedAbsolute = false;\\n        for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\\n          var path = i >= 0 ? args[i] : FS.cwd();\\n          if (typeof path != \"string\") {\\n            throw new TypeError(\"Arguments to path.resolve must be strings\");\\n          } else if (!path) {\\n            return \"\";\\n          }\\n          resolvedPath = path + \"/\" + resolvedPath;\\n          resolvedAbsolute = PATH.isAbs(path);\\n        }\\n        resolvedPath = PATH.normalizeArray(\\n          resolvedPath.split(\"/\").filter((p) => !!p),\\n          !resolvedAbsolute,\\n        ).join(\"/\");\\n        return (resolvedAbsolute ? \"/\" : \"\") + resolvedPath || \".\";\\n      },\\n      relative: (from, to) => {\\n        from = PATH_FS.resolve(from).slice(1);\\n        to = PATH_FS.resolve(to).slice(1);\\n        function trim(arr) {\\n          var start = 0;\\n          for (; start < arr.length; start++) {\\n            if (arr[start] !== \"\") break;\\n          }\\n          var end = arr.length - 1;\\n          for (; end >= 0; end--) {\\n            if (arr[end] !== \"\") break;\\n          }\\n          if (start > end) return [];\\n          return arr.slice(start, end - start + 1);\\n        }\\n        var fromParts = trim(from.split(\"/\"));\\n        var toParts = trim(to.split(\"/\"));\\n        var length = Math.min(fromParts.length, toParts.length);\\n        var samePartsLength = length;\\n        for (var i = 0; i < length; i++) {\\n          if (fromParts[i] !== toParts[i]) {\\n            samePartsLength = i;\\n            break;\\n          }\\n        }\\n        var outputParts = [];\\n        for (var i = samePartsLength; i < fromParts.length; i++) {\\n          outputParts.push(\"..\");\\n        }\\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\\n        return outputParts.join(\"/\");\\n      },\\n    };\\n    var FS_stdin_getChar_buffer = [];\\n    var lengthBytesUTF8 = (str) => {\\n      var len = 0;\\n      for (var i = 0; i < str.length; ++i) {\\n        var c = str.charCodeAt(i);\\n        if (c <= 127) {\\n          len++;\\n        } else if (c <= 2047) {\\n          len += 2;\\n        } else if (c >= 55296 && c <= 57343) {\\n          len += 4;\\n          ++i;\\n        } else {\\n          len += 3;\\n        }\\n      }\\n      return len;\\n    };\\n    var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\\n      assert(\\n        typeof str === \"string\",\\n        `stringToUTF8Array expects a string (got ${typeof str})`,\\n      );\\n      if (!(maxBytesToWrite > 0)) return 0;\\n      var startIdx = outIdx;\\n      var endIdx = outIdx + maxBytesToWrite - 1;\\n      for (var i = 0; i < str.length; ++i) {\\n        var u = str.charCodeAt(i);\\n        if (u >= 55296 && u <= 57343) {\\n          var u1 = str.charCodeAt(++i);\\n          u = (65536 + ((u & 1023) << 10)) | (u1 & 1023);\\n        }\\n        if (u <= 127) {\\n          if (outIdx >= endIdx) break;\\n          heap[outIdx++] = u;\\n        } else if (u <= 2047) {\\n          if (outIdx + 1 >= endIdx) break;\\n          heap[outIdx++] = 192 | (u >> 6);\\n          heap[outIdx++] = 128 | (u & 63);\\n        } else if (u <= 65535) {\\n          if (outIdx + 2 >= endIdx) break;\\n          heap[outIdx++] = 224 | (u >> 12);\\n          heap[outIdx++] = 128 | ((u >> 6) & 63);\\n          heap[outIdx++] = 128 | (u & 63);\\n        } else {\\n          if (outIdx + 3 >= endIdx) break;\\n          if (u > 1114111)\\n            warnOnce(\\n              \"Invalid Unicode code point \" +\\n                ptrToString(u) +\\n                \" encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).\",\\n            );\\n          heap[outIdx++] = 240 | (u >> 18);\\n          heap[outIdx++] = 128 | ((u >> 12) & 63);\\n          heap[outIdx++] = 128 | ((u >> 6) & 63);\\n          heap[outIdx++] = 128 | (u & 63);\\n        }\\n      }\\n      heap[outIdx] = 0;\\n      return outIdx - startIdx;\\n    };\\n    var intArrayFromString = (stringy, dontAddNull, length) => {\\n      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\\n      var u8array = new Array(len);\\n      var numBytesWritten = stringToUTF8Array(\\n        stringy,\\n        u8array,\\n        0,\\n        u8array.length,\\n      );\\n      if (dontAddNull) u8array.length = numBytesWritten;\\n      return u8array;\\n    };\\n    var FS_stdin_getChar = () => {\\n      if (!FS_stdin_getChar_buffer.length) {\\n        var result = null;\\n        if (\\n          typeof window != \"undefined\" &&\\n          typeof window.prompt == \"function\"\\n        ) {\\n          result = window.prompt(\"Input: \");\\n          if (result !== null) {\\n            result += \"\\\\n\";\\n          }\\n        } else {\\n        }\\n        if (!result) {\\n          return null;\\n        }\\n        FS_stdin_getChar_buffer = intArrayFromString(result, true);\\n      }\\n      return FS_stdin_getChar_buffer.shift();\\n    };\\n    var TTY = {\\n      ttys: [],\\n      init() {},\\n      shutdown() {},\\n      register(dev, ops) {\\n        TTY.ttys[dev] = { input: [], output: [], ops };\\n        FS.registerDevice(dev, TTY.stream_ops);\\n      },\\n      stream_ops: {\\n        open(stream) {\\n          var tty = TTY.ttys[stream.node.rdev];\\n          if (!tty) {\\n            throw new FS.ErrnoError(43);\\n          }\\n          stream.tty = tty;\\n          stream.seekable = false;\\n        },\\n        close(stream) {\\n          stream.tty.ops.fsync(stream.tty);\\n        },\\n        fsync(stream) {\\n          stream.tty.ops.fsync(stream.tty);\\n        },\\n        read(stream, buffer, offset, length, pos) {\\n          if (!stream.tty || !stream.tty.ops.get_char) {\\n            throw new FS.ErrnoError(60);\\n          }\\n          var bytesRead = 0;\\n          for (var i = 0; i < length; i++) {\\n            var result;\\n            try {\\n              result = stream.tty.ops.get_char(stream.tty);\\n            } catch (e) {\\n              throw new FS.ErrnoError(29);\\n            }\\n            if (result === undefined && bytesRead === 0) {\\n              throw new FS.ErrnoError(6);\\n            }\\n            if (result === null || result === undefined) break;\\n            bytesRead++;\\n            buffer[offset + i] = result;\\n          }\\n          if (bytesRead) {\\n            stream.node.atime = Date.now();\\n          }\\n          return bytesRead;\\n        },\\n        write(stream, buffer, offset, length, pos) {\\n          if (!stream.tty || !stream.tty.ops.put_char) {\\n            throw new FS.ErrnoError(60);\\n          }\\n          try {\\n            for (var i = 0; i < length; i++) {\\n              stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\\n            }\\n          } catch (e) {\\n            throw new FS.ErrnoError(29);\\n          }\\n          if (length) {\\n            stream.node.mtime = stream.node.ctime = Date.now();\\n          }\\n          return i;\\n        },\\n      },\\n      default_tty_ops: {\\n        get_char(tty) {\\n          return FS_stdin_getChar();\\n        },\\n        put_char(tty, val) {\\n          if (val === null || val === 10) {\\n            out(UTF8ArrayToString(tty.output));\\n            tty.output = [];\\n          } else {\\n            if (val != 0) tty.output.push(val);\\n          }\\n        },\\n        fsync(tty) {\\n          if (tty.output?.length > 0) {\\n            out(UTF8ArrayToString(tty.output));\\n            tty.output = [];\\n          }\\n        },\\n        ioctl_tcgets(tty) {\\n          return {\\n            c_iflag: 25856,\\n            c_oflag: 5,\\n            c_cflag: 191,\\n            c_lflag: 35387,\\n            c_cc: [\\n              3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0,\\n              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n            ],\\n          };\\n        },\\n        ioctl_tcsets(tty, optional_actions, data) {\\n          return 0;\\n        },\\n        ioctl_tiocgwinsz(tty) {\\n          return [24, 80];\\n        },\\n      },\\n      default_tty1_ops: {\\n        put_char(tty, val) {\\n          if (val === null || val === 10) {\\n            err(UTF8ArrayToString(tty.output));\\n            tty.output = [];\\n          } else {\\n            if (val != 0) tty.output.push(val);\\n          }\\n        },\\n        fsync(tty) {\\n          if (tty.output?.length > 0) {\\n            err(UTF8ArrayToString(tty.output));\\n            tty.output = [];\\n          }\\n        },\\n      },\\n    };\\n    var zeroMemory = (address, size) => {\\n      HEAPU8.fill(0, address, address + size);\\n    };\\n    var alignMemory = (size, alignment) => {\\n      assert(alignment, \"alignment argument is required\");\\n      return Math.ceil(size / alignment) * alignment;\\n    };\\n    var mmapAlloc = (size) => {\\n      size = alignMemory(size, 65536);\\n      var ptr = _emscripten_builtin_memalign(65536, size);\\n      if (ptr) zeroMemory(ptr, size);\\n      return ptr;\\n    };\\n    var MEMFS = {\\n      ops_table: null,\\n      mount(mount) {\\n        return MEMFS.createNode(null, \"/\", 16895, 0);\\n      },\\n      createNode(parent, name, mode, dev) {\\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\\n          throw new FS.ErrnoError(63);\\n        }\\n        MEMFS.ops_table ||= {\\n          dir: {\\n            node: {\\n              getattr: MEMFS.node_ops.getattr,\\n              setattr: MEMFS.node_ops.setattr,\\n              lookup: MEMFS.node_ops.lookup,\\n              mknod: MEMFS.node_ops.mknod,\\n              rename: MEMFS.node_ops.rename,\\n              unlink: MEMFS.node_ops.unlink,\\n              rmdir: MEMFS.node_ops.rmdir,\\n              readdir: MEMFS.node_ops.readdir,\\n              symlink: MEMFS.node_ops.symlink,\\n            },\\n            stream: { llseek: MEMFS.stream_ops.llseek },\\n          },\\n          file: {\\n            node: {\\n              getattr: MEMFS.node_ops.getattr,\\n              setattr: MEMFS.node_ops.setattr,\\n            },\\n            stream: {\\n              llseek: MEMFS.stream_ops.llseek,\\n              read: MEMFS.stream_ops.read,\\n              write: MEMFS.stream_ops.write,\\n              allocate: MEMFS.stream_ops.allocate,\\n              mmap: MEMFS.stream_ops.mmap,\\n              msync: MEMFS.stream_ops.msync,\\n            },\\n          },\\n          link: {\\n            node: {\\n              getattr: MEMFS.node_ops.getattr,\\n              setattr: MEMFS.node_ops.setattr,\\n              readlink: MEMFS.node_ops.readlink,\\n            },\\n            stream: {},\\n          },\\n          chrdev: {\\n            node: {\\n              getattr: MEMFS.node_ops.getattr,\\n              setattr: MEMFS.node_ops.setattr,\\n            },\\n            stream: FS.chrdev_stream_ops,\\n          },\\n        };\\n        var node = FS.createNode(parent, name, mode, dev);\\n        if (FS.isDir(node.mode)) {\\n          node.node_ops = MEMFS.ops_table.dir.node;\\n          node.stream_ops = MEMFS.ops_table.dir.stream;\\n          node.contents = {};\\n        } else if (FS.isFile(node.mode)) {\\n          node.node_ops = MEMFS.ops_table.file.node;\\n          node.stream_ops = MEMFS.ops_table.file.stream;\\n          node.usedBytes = 0;\\n          node.contents = null;\\n        } else if (FS.isLink(node.mode)) {\\n          node.node_ops = MEMFS.ops_table.link.node;\\n          node.stream_ops = MEMFS.ops_table.link.stream;\\n        } else if (FS.isChrdev(node.mode)) {\\n          node.node_ops = MEMFS.ops_table.chrdev.node;\\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\\n        }\\n        node.atime = node.mtime = node.ctime = Date.now();\\n        if (parent) {\\n          parent.contents[name] = node;\\n          parent.atime = parent.mtime = parent.ctime = node.atime;\\n        }\\n        return node;\\n      },\\n      getFileDataAsTypedArray(node) {\\n        if (!node.contents) return new Uint8Array(0);\\n        if (node.contents.subarray)\\n          return node.contents.subarray(0, node.usedBytes);\\n        return new Uint8Array(node.contents);\\n      },\\n      expandFileStorage(node, newCapacity) {\\n        var prevCapacity = node.contents ? node.contents.length : 0;\\n        if (prevCapacity >= newCapacity) return;\\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\\n        newCapacity = Math.max(\\n          newCapacity,\\n          (prevCapacity *\\n            (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125)) >>>\\n            0,\\n        );\\n        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\\n        var oldContents = node.contents;\\n        node.contents = new Uint8Array(newCapacity);\\n        if (node.usedBytes > 0)\\n          node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\\n      },\\n      resizeFileStorage(node, newSize) {\\n        if (node.usedBytes == newSize) return;\\n        if (newSize == 0) {\\n          node.contents = null;\\n          node.usedBytes = 0;\\n        } else {\\n          var oldContents = node.contents;\\n          node.contents = new Uint8Array(newSize);\\n          if (oldContents) {\\n            node.contents.set(\\n              oldContents.subarray(0, Math.min(newSize, node.usedBytes)),\\n            );\\n          }\\n          node.usedBytes = newSize;\\n        }\\n      },\\n      node_ops: {\\n        getattr(node) {\\n          var attr = {};\\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\\n          attr.ino = node.id;\\n          attr.mode = node.mode;\\n          attr.nlink = 1;\\n          attr.uid = 0;\\n          attr.gid = 0;\\n          attr.rdev = node.rdev;\\n          if (FS.isDir(node.mode)) {\\n            attr.size = 4096;\\n          } else if (FS.isFile(node.mode)) {\\n            attr.size = node.usedBytes;\\n          } else if (FS.isLink(node.mode)) {\\n            attr.size = node.link.length;\\n          } else {\\n            attr.size = 0;\\n          }\\n          attr.atime = new Date(node.atime);\\n          attr.mtime = new Date(node.mtime);\\n          attr.ctime = new Date(node.ctime);\\n          attr.blksize = 4096;\\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\\n          return attr;\\n        },\\n        setattr(node, attr) {\\n          for (const key of [\"mode\", \"atime\", \"mtime\", \"ctime\"]) {\\n            if (attr[key] != null) {\\n              node[key] = attr[key];\\n            }\\n          }\\n          if (attr.size !== undefined) {\\n            MEMFS.resizeFileStorage(node, attr.size);\\n          }\\n        },\\n        lookup(parent, name) {\\n          throw new FS.ErrnoError(44);\\n        },\\n        mknod(parent, name, mode, dev) {\\n          return MEMFS.createNode(parent, name, mode, dev);\\n        },\\n        rename(old_node, new_dir, new_name) {\\n          var new_node;\\n          try {\\n            new_node = FS.lookupNode(new_dir, new_name);\\n          } catch (e) {}\\n          if (new_node) {\\n            if (FS.isDir(old_node.mode)) {\\n              for (var i in new_node.contents) {\\n                throw new FS.ErrnoError(55);\\n              }\\n            }\\n            FS.hashRemoveNode(new_node);\\n          }\\n          delete old_node.parent.contents[old_node.name];\\n          new_dir.contents[new_name] = old_node;\\n          old_node.name = new_name;\\n          new_dir.ctime =\\n            new_dir.mtime =\\n            old_node.parent.ctime =\\n            old_node.parent.mtime =\\n              Date.now();\\n        },\\n        unlink(parent, name) {\\n          delete parent.contents[name];\\n          parent.ctime = parent.mtime = Date.now();\\n        },\\n        rmdir(parent, name) {\\n          var node = FS.lookupNode(parent, name);\\n          for (var i in node.contents) {\\n            throw new FS.ErrnoError(55);\\n          }\\n          delete parent.contents[name];\\n          parent.ctime = parent.mtime = Date.now();\\n        },\\n        readdir(node) {\\n          return [\".\", \"..\", ...Object.keys(node.contents)];\\n        },\\n        symlink(parent, newname, oldpath) {\\n          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\\n          node.link = oldpath;\\n          return node;\\n        },\\n        readlink(node) {\\n          if (!FS.isLink(node.mode)) {\\n            throw new FS.ErrnoError(28);\\n          }\\n          return node.link;\\n        },\\n      },\\n      stream_ops: {\\n        read(stream, buffer, offset, length, position) {\\n          var contents = stream.node.contents;\\n          if (position >= stream.node.usedBytes) return 0;\\n          var size = Math.min(stream.node.usedBytes - position, length);\\n          assert(size >= 0);\\n          if (size > 8 && contents.subarray) {\\n            buffer.set(contents.subarray(position, position + size), offset);\\n          } else {\\n            for (var i = 0; i < size; i++)\\n              buffer[offset + i] = contents[position + i];\\n          }\\n          return size;\\n        },\\n        write(stream, buffer, offset, length, position, canOwn) {\\n          assert(!(buffer instanceof ArrayBuffer));\\n          if (buffer.buffer === HEAP8.buffer) {\\n            canOwn = false;\\n          }\\n          if (!length) return 0;\\n          var node = stream.node;\\n          node.mtime = node.ctime = Date.now();\\n          if (buffer.subarray && (!node.contents || node.contents.subarray)) {\\n            if (canOwn) {\\n              assert(\\n                position === 0,\\n                \"canOwn must imply no weird position inside the file\",\\n              );\\n              node.contents = buffer.subarray(offset, offset + length);\\n              node.usedBytes = length;\\n              return length;\\n            } else if (node.usedBytes === 0 && position === 0) {\\n              node.contents = buffer.slice(offset, offset + length);\\n              node.usedBytes = length;\\n              return length;\\n            } else if (position + length <= node.usedBytes) {\\n              node.contents.set(\\n                buffer.subarray(offset, offset + length),\\n                position,\\n              );\\n              return length;\\n            }\\n          }\\n          MEMFS.expandFileStorage(node, position + length);\\n          if (node.contents.subarray && buffer.subarray) {\\n            node.contents.set(\\n              buffer.subarray(offset, offset + length),\\n              position,\\n            );\\n          } else {\\n            for (var i = 0; i < length; i++) {\\n              node.contents[position + i] = buffer[offset + i];\\n            }\\n          }\\n          node.usedBytes = Math.max(node.usedBytes, position + length);\\n          return length;\\n        },\\n        llseek(stream, offset, whence) {\\n          var position = offset;\\n          if (whence === 1) {\\n            position += stream.position;\\n          } else if (whence === 2) {\\n            if (FS.isFile(stream.node.mode)) {\\n              position += stream.node.usedBytes;\\n            }\\n          }\\n          if (position < 0) {\\n            throw new FS.ErrnoError(28);\\n          }\\n          return position;\\n        },\\n        allocate(stream, offset, length) {\\n          MEMFS.expandFileStorage(stream.node, offset + length);\\n          stream.node.usedBytes = Math.max(\\n            stream.node.usedBytes,\\n            offset + length,\\n          );\\n        },\\n        mmap(stream, length, position, prot, flags) {\\n          if (!FS.isFile(stream.node.mode)) {\\n            throw new FS.ErrnoError(43);\\n          }\\n          var ptr;\\n          var allocated;\\n          var contents = stream.node.contents;\\n          if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {\\n            allocated = false;\\n            ptr = contents.byteOffset;\\n          } else {\\n            allocated = true;\\n            ptr = mmapAlloc(length);\\n            if (!ptr) {\\n              throw new FS.ErrnoError(48);\\n            }\\n            if (contents) {\\n              if (position > 0 || position + length < contents.length) {\\n                if (contents.subarray) {\\n                  contents = contents.subarray(position, position + length);\\n                } else {\\n                  contents = Array.prototype.slice.call(\\n                    contents,\\n                    position,\\n                    position + length,\\n                  );\\n                }\\n              }\\n              HEAP8.set(contents, ptr);\\n            }\\n          }\\n          return { ptr, allocated };\\n        },\\n        msync(stream, buffer, offset, length, mmapFlags) {\\n          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\\n          return 0;\\n        },\\n      },\\n    };\\n    var asyncLoad = async (url) => {\\n      var arrayBuffer = await readAsync(url);\\n      assert(\\n        arrayBuffer,\\n        `Loading data file \"${url}\" failed (no arrayBuffer).`,\\n      );\\n      return new Uint8Array(arrayBuffer);\\n    };\\n    asyncLoad.isAsync = true;\\n    var FS_createDataFile = (\\n      parent,\\n      name,\\n      fileData,\\n      canRead,\\n      canWrite,\\n      canOwn,\\n    ) => {\\n      FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);\\n    };\\n    var preloadPlugins = Module[\"preloadPlugins\"] || [];\\n    var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {\\n      if (typeof Browser != \"undefined\") Browser.init();\\n      var handled = false;\\n      preloadPlugins.forEach((plugin) => {\\n        if (handled) return;\\n        if (plugin[\"canHandle\"](fullname)) {\\n          plugin[\"handle\"](byteArray, fullname, finish, onerror);\\n          handled = true;\\n        }\\n      });\\n      return handled;\\n    };\\n    var FS_createPreloadedFile = (\\n      parent,\\n      name,\\n      url,\\n      canRead,\\n      canWrite,\\n      onload,\\n      onerror,\\n      dontCreateFile,\\n      canOwn,\\n      preFinish,\\n    ) => {\\n      var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\\n      var dep = getUniqueRunDependency(`cp ${fullname}`);\\n      function processData(byteArray) {\\n        function finish(byteArray) {\\n          preFinish?.();\\n          if (!dontCreateFile) {\\n            FS_createDataFile(\\n              parent,\\n              name,\\n              byteArray,\\n              canRead,\\n              canWrite,\\n              canOwn,\\n            );\\n          }\\n          onload?.();\\n          removeRunDependency(dep);\\n        }\\n        if (\\n          FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {\\n            onerror?.();\\n            removeRunDependency(dep);\\n          })\\n        ) {\\n          return;\\n        }\\n        finish(byteArray);\\n      }\\n      addRunDependency(dep);\\n      if (typeof url == \"string\") {\\n        asyncLoad(url).then(processData, onerror);\\n      } else {\\n        processData(url);\\n      }\\n    };\\n    var FS_modeStringToFlags = (str) => {\\n      var flagModes = {\\n        r: 0,\\n        \"r+\": 2,\\n        w: 512 | 64 | 1,\\n        \"w+\": 512 | 64 | 2,\\n        a: 1024 | 64 | 1,\\n        \"a+\": 1024 | 64 | 2,\\n      };\\n      var flags = flagModes[str];\\n      if (typeof flags == \"undefined\") {\\n        throw new Error(`Unknown file open mode: ${str}`);\\n      }\\n      return flags;\\n    };\\n    var FS_getMode = (canRead, canWrite) => {\\n      var mode = 0;\\n      if (canRead) mode |= 292 | 73;\\n      if (canWrite) mode |= 146;\\n      return mode;\\n    };\\n    var strError = (errno) => UTF8ToString(_strerror(errno));\\n    var ERRNO_CODES = {\\n      EPERM: 63,\\n      ENOENT: 44,\\n      ESRCH: 71,\\n      EINTR: 27,\\n      EIO: 29,\\n      ENXIO: 60,\\n      E2BIG: 1,\\n      ENOEXEC: 45,\\n      EBADF: 8,\\n      ECHILD: 12,\\n      EAGAIN: 6,\\n      EWOULDBLOCK: 6,\\n      ENOMEM: 48,\\n      EACCES: 2,\\n      EFAULT: 21,\\n      ENOTBLK: 105,\\n      EBUSY: 10,\\n      EEXIST: 20,\\n      EXDEV: 75,\\n      ENODEV: 43,\\n      ENOTDIR: 54,\\n      EISDIR: 31,\\n      EINVAL: 28,\\n      ENFILE: 41,\\n      EMFILE: 33,\\n      ENOTTY: 59,\\n      ETXTBSY: 74,\\n      EFBIG: 22,\\n      ENOSPC: 51,\\n      ESPIPE: 70,\\n      EROFS: 69,\\n      EMLINK: 34,\\n      EPIPE: 64,\\n      EDOM: 18,\\n      ERANGE: 68,\\n      ENOMSG: 49,\\n      EIDRM: 24,\\n      ECHRNG: 106,\\n      EL2NSYNC: 156,\\n      EL3HLT: 107,\\n      EL3RST: 108,\\n      ELNRNG: 109,\\n      EUNATCH: 110,\\n      ENOCSI: 111,\\n      EL2HLT: 112,\\n      EDEADLK: 16,\\n      ENOLCK: 46,\\n      EBADE: 113,\\n      EBADR: 114,\\n      EXFULL: 115,\\n      ENOANO: 104,\\n      EBADRQC: 103,\\n      EBADSLT: 102,\\n      EDEADLOCK: 16,\\n      EBFONT: 101,\\n      ENOSTR: 100,\\n      ENODATA: 116,\\n      ETIME: 117,\\n      ENOSR: 118,\\n      ENONET: 119,\\n      ENOPKG: 120,\\n      EREMOTE: 121,\\n      ENOLINK: 47,\\n      EADV: 122,\\n      ESRMNT: 123,\\n      ECOMM: 124,\\n      EPROTO: 65,\\n      EMULTIHOP: 36,\\n      EDOTDOT: 125,\\n      EBADMSG: 9,\\n      ENOTUNIQ: 126,\\n      EBADFD: 127,\\n      EREMCHG: 128,\\n      ELIBACC: 129,\\n      ELIBBAD: 130,\\n      ELIBSCN: 131,\\n      ELIBMAX: 132,\\n      ELIBEXEC: 133,\\n      ENOSYS: 52,\\n      ENOTEMPTY: 55,\\n      ENAMETOOLONG: 37,\\n      ELOOP: 32,\\n      EOPNOTSUPP: 138,\\n      EPFNOSUPPORT: 139,\\n      ECONNRESET: 15,\\n      ENOBUFS: 42,\\n      EAFNOSUPPORT: 5,\\n      EPROTOTYPE: 67,\\n      ENOTSOCK: 57,\\n      ENOPROTOOPT: 50,\\n      ESHUTDOWN: 140,\\n      ECONNREFUSED: 14,\\n      EADDRINUSE: 3,\\n      ECONNABORTED: 13,\\n      ENETUNREACH: 40,\\n      ENETDOWN: 38,\\n      ETIMEDOUT: 73,\\n      EHOSTDOWN: 142,\\n      EHOSTUNREACH: 23,\\n      EINPROGRESS: 26,\\n      EALREADY: 7,\\n      EDESTADDRREQ: 17,\\n      EMSGSIZE: 35,\\n      EPROTONOSUPPORT: 66,\\n      ESOCKTNOSUPPORT: 137,\\n      EADDRNOTAVAIL: 4,\\n      ENETRESET: 39,\\n      EISCONN: 30,\\n      ENOTCONN: 53,\\n      ETOOMANYREFS: 141,\\n      EUSERS: 136,\\n      EDQUOT: 19,\\n      ESTALE: 72,\\n      ENOTSUP: 138,\\n      ENOMEDIUM: 148,\\n      EILSEQ: 25,\\n      EOVERFLOW: 61,\\n      ECANCELED: 11,\\n      ENOTRECOVERABLE: 56,\\n      EOWNERDEAD: 62,\\n      ESTRPIPE: 135,\\n    };\\n    var FS = {\\n      root: null,\\n      mounts: [],\\n      devices: {},\\n      streams: [],\\n      nextInode: 1,\\n      nameTable: null,\\n      currentPath: \"/\",\\n      initialized: false,\\n      ignorePermissions: true,\\n      ErrnoError: class extends Error {\\n        name = \"ErrnoError\";\\n        constructor(errno) {\\n          super(runtimeInitialized ? strError(errno) : \"\");\\n          this.errno = errno;\\n          for (var key in ERRNO_CODES) {\\n            if (ERRNO_CODES[key] === errno) {\\n              this.code = key;\\n              break;\\n            }\\n          }\\n        }\\n      },\\n      filesystems: null,\\n      syncFSRequests: 0,\\n      readFiles: {},\\n      FSStream: class {\\n        shared = {};\\n        get object() {\\n          return this.node;\\n        }\\n        set object(val) {\\n          this.node = val;\\n        }\\n        get isRead() {\\n          return (this.flags & 2097155) !== 1;\\n        }\\n        get isWrite() {\\n          return (this.flags & 2097155) !== 0;\\n        }\\n        get isAppend() {\\n          return this.flags & 1024;\\n        }\\n        get flags() {\\n          return this.shared.flags;\\n        }\\n        set flags(val) {\\n          this.shared.flags = val;\\n        }\\n        get position() {\\n          return this.shared.position;\\n        }\\n        set position(val) {\\n          this.shared.position = val;\\n        }\\n      },\\n      FSNode: class {\\n        node_ops = {};\\n        stream_ops = {};\\n        readMode = 292 | 73;\\n        writeMode = 146;\\n        mounted = null;\\n        constructor(parent, name, mode, rdev) {\\n          if (!parent) {\\n            parent = this;\\n          }\\n          this.parent = parent;\\n          this.mount = parent.mount;\\n          this.id = FS.nextInode++;\\n          this.name = name;\\n          this.mode = mode;\\n          this.rdev = rdev;\\n          this.atime = this.mtime = this.ctime = Date.now();\\n        }\\n        get read() {\\n          return (this.mode & this.readMode) === this.readMode;\\n        }\\n        set read(val) {\\n          val ? (this.mode |= this.readMode) : (this.mode &= ~this.readMode);\\n        }\\n        get write() {\\n          return (this.mode & this.writeMode) === this.writeMode;\\n        }\\n        set write(val) {\\n          val ? (this.mode |= this.writeMode) : (this.mode &= ~this.writeMode);\\n        }\\n        get isFolder() {\\n          return FS.isDir(this.mode);\\n        }\\n        get isDevice() {\\n          return FS.isChrdev(this.mode);\\n        }\\n      },\\n      lookupPath(path, opts = {}) {\\n        if (!path) {\\n          throw new FS.ErrnoError(44);\\n        }\\n        opts.follow_mount ??= true;\\n        if (!PATH.isAbs(path)) {\\n          path = FS.cwd() + \"/\" + path;\\n        }\\n        linkloop: for (var nlinks = 0; nlinks < 40; nlinks++) {\\n          var parts = path.split(\"/\").filter((p) => !!p);\\n          var current = FS.root;\\n          var current_path = \"/\";\\n          for (var i = 0; i < parts.length; i++) {\\n            var islast = i === parts.length - 1;\\n            if (islast && opts.parent) {\\n              break;\\n            }\\n            if (parts[i] === \".\") {\\n              continue;\\n            }\\n            if (parts[i] === \"..\") {\\n              current_path = PATH.dirname(current_path);\\n              current = current.parent;\\n              continue;\\n            }\\n            current_path = PATH.join2(current_path, parts[i]);\\n            try {\\n              current = FS.lookupNode(current, parts[i]);\\n            } catch (e) {\\n              if (e?.errno === 44 && islast && opts.noent_okay) {\\n                return { path: current_path };\\n              }\\n              throw e;\\n            }\\n            if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {\\n              current = current.mounted.root;\\n            }\\n            if (FS.isLink(current.mode) && (!islast || opts.follow)) {\\n              if (!current.node_ops.readlink) {\\n                throw new FS.ErrnoError(52);\\n              }\\n              var link = current.node_ops.readlink(current);\\n              if (!PATH.isAbs(link)) {\\n                link = PATH.dirname(current_path) + \"/\" + link;\\n              }\\n              path = link + \"/\" + parts.slice(i + 1).join(\"/\");\\n              continue linkloop;\\n            }\\n          }\\n          return { path: current_path, node: current };\\n        }\\n        throw new FS.ErrnoError(32);\\n      },\\n      getPath(node) {\\n        var path;\\n        while (true) {\\n          if (FS.isRoot(node)) {\\n            var mount = node.mount.mountpoint;\\n            if (!path) return mount;\\n            return mount[mount.length - 1] !== \"/\"\\n              ? `${mount}/${path}`\\n              : mount + path;\\n          }\\n          path = path ? `${node.name}/${path}` : node.name;\\n          node = node.parent;\\n        }\\n      },\\n      hashName(parentid, name) {\\n        var hash = 0;\\n        for (var i = 0; i < name.length; i++) {\\n          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;\\n        }\\n        return ((parentid + hash) >>> 0) % FS.nameTable.length;\\n      },\\n      hashAddNode(node) {\\n        var hash = FS.hashName(node.parent.id, node.name);\\n        node.name_next = FS.nameTable[hash];\\n        FS.nameTable[hash] = node;\\n      },\\n      hashRemoveNode(node) {\\n        var hash = FS.hashName(node.parent.id, node.name);\\n        if (FS.nameTable[hash] === node) {\\n          FS.nameTable[hash] = node.name_next;\\n        } else {\\n          var current = FS.nameTable[hash];\\n          while (current) {\\n            if (current.name_next === node) {\\n              current.name_next = node.name_next;\\n              break;\\n            }\\n            current = current.name_next;\\n          }\\n        }\\n      },\\n      lookupNode(parent, name) {\\n        var errCode = FS.mayLookup(parent);\\n        if (errCode) {\\n          throw new FS.ErrnoError(errCode);\\n        }\\n        var hash = FS.hashName(parent.id, name);\\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\\n          var nodeName = node.name;\\n          if (node.parent.id === parent.id && nodeName === name) {\\n            return node;\\n          }\\n        }\\n        return FS.lookup(parent, name);\\n      },\\n      createNode(parent, name, mode, rdev) {\\n        assert(typeof parent == \"object\");\\n        var node = new FS.FSNode(parent, name, mode, rdev);\\n        FS.hashAddNode(node);\\n        return node;\\n      },\\n      destroyNode(node) {\\n        FS.hashRemoveNode(node);\\n      },\\n      isRoot(node) {\\n        return node === node.parent;\\n      },\\n      isMountpoint(node) {\\n        return !!node.mounted;\\n      },\\n      isFile(mode) {\\n        return (mode & 61440) === 32768;\\n      },\\n      isDir(mode) {\\n        return (mode & 61440) === 16384;\\n      },\\n      isLink(mode) {\\n        return (mode & 61440) === 40960;\\n      },\\n      isChrdev(mode) {\\n        return (mode & 61440) === 8192;\\n      },\\n      isBlkdev(mode) {\\n        return (mode & 61440) === 24576;\\n      },\\n      isFIFO(mode) {\\n        return (mode & 61440) === 4096;\\n      },\\n      isSocket(mode) {\\n        return (mode & 49152) === 49152;\\n      },\\n      flagsToPermissionString(flag) {\\n        var perms = [\"r\", \"w\", \"rw\"][flag & 3];\\n        if (flag & 512) {\\n          perms += \"w\";\\n        }\\n        return perms;\\n      },\\n      nodePermissions(node, perms) {\\n        if (FS.ignorePermissions) {\\n          return 0;\\n        }\\n        if (perms.includes(\"r\") && !(node.mode & 292)) {\\n          return 2;\\n        } else if (perms.includes(\"w\") && !(node.mode & 146)) {\\n          return 2;\\n        } else if (perms.includes(\"x\") && !(node.mode & 73)) {\\n          return 2;\\n        }\\n        return 0;\\n      },\\n      mayLookup(dir) {\\n        if (!FS.isDir(dir.mode)) return 54;\\n        var errCode = FS.nodePermissions(dir, \"x\");\\n        if (errCode) return errCode;\\n        if (!dir.node_ops.lookup) return 2;\\n        return 0;\\n      },\\n      mayCreate(dir, name) {\\n        if (!FS.isDir(dir.mode)) {\\n          return 54;\\n        }\\n        try {\\n          var node = FS.lookupNode(dir, name);\\n          return 20;\\n        } catch (e) {}\\n        return FS.nodePermissions(dir, \"wx\");\\n      },\\n      mayDelete(dir, name, isdir) {\\n        var node;\\n        try {\\n          node = FS.lookupNode(dir, name);\\n        } catch (e) {\\n          return e.errno;\\n        }\\n        var errCode = FS.nodePermissions(dir, \"wx\");\\n        if (errCode) {\\n          return errCode;\\n        }\\n        if (isdir) {\\n          if (!FS.isDir(node.mode)) {\\n            return 54;\\n          }\\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\\n            return 10;\\n          }\\n        } else {\\n          if (FS.isDir(node.mode)) {\\n            return 31;\\n          }\\n        }\\n        return 0;\\n      },\\n      mayOpen(node, flags) {\\n        if (!node) {\\n          return 44;\\n        }\\n        if (FS.isLink(node.mode)) {\\n          return 32;\\n        } else if (FS.isDir(node.mode)) {\\n          if (FS.flagsToPermissionString(flags) !== \"r\" || flags & (512 | 64)) {\\n            return 31;\\n          }\\n        }\\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\\n      },\\n      checkOpExists(op, err) {\\n        if (!op) {\\n          throw new FS.ErrnoError(err);\\n        }\\n        return op;\\n      },\\n      MAX_OPEN_FDS: 4096,\\n      nextfd() {\\n        for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {\\n          if (!FS.streams[fd]) {\\n            return fd;\\n          }\\n        }\\n        throw new FS.ErrnoError(33);\\n      },\\n      getStreamChecked(fd) {\\n        var stream = FS.getStream(fd);\\n        if (!stream) {\\n          throw new FS.ErrnoError(8);\\n        }\\n        return stream;\\n      },\\n      getStream: (fd) => FS.streams[fd],\\n      createStream(stream, fd = -1) {\\n        assert(fd >= -1);\\n        stream = Object.assign(new FS.FSStream(), stream);\\n        if (fd == -1) {\\n          fd = FS.nextfd();\\n        }\\n        stream.fd = fd;\\n        FS.streams[fd] = stream;\\n        return stream;\\n      },\\n      closeStream(fd) {\\n        FS.streams[fd] = null;\\n      },\\n      dupStream(origStream, fd = -1) {\\n        var stream = FS.createStream(origStream, fd);\\n        stream.stream_ops?.dup?.(stream);\\n        return stream;\\n      },\\n      doSetAttr(stream, node, attr) {\\n        var setattr = stream?.stream_ops.setattr;\\n        var arg = setattr ? stream : node;\\n        setattr ??= node.node_ops.setattr;\\n        FS.checkOpExists(setattr, 63);\\n        setattr(arg, attr);\\n      },\\n      chrdev_stream_ops: {\\n        open(stream) {\\n          var device = FS.getDevice(stream.node.rdev);\\n          stream.stream_ops = device.stream_ops;\\n          stream.stream_ops.open?.(stream);\\n        },\\n        llseek() {\\n          throw new FS.ErrnoError(70);\\n        },\\n      },\\n      major: (dev) => dev >> 8,\\n      minor: (dev) => dev & 255,\\n      makedev: (ma, mi) => (ma << 8) | mi,\\n      registerDevice(dev, ops) {\\n        FS.devices[dev] = { stream_ops: ops };\\n      },\\n      getDevice: (dev) => FS.devices[dev],\\n      getMounts(mount) {\\n        var mounts = [];\\n        var check = [mount];\\n        while (check.length) {\\n          var m = check.pop();\\n          mounts.push(m);\\n          check.push(...m.mounts);\\n        }\\n        return mounts;\\n      },\\n      syncfs(populate, callback) {\\n        if (typeof populate == \"function\") {\\n          callback = populate;\\n          populate = false;\\n        }\\n        FS.syncFSRequests++;\\n        if (FS.syncFSRequests > 1) {\\n          err(\\n            `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`,\\n          );\\n        }\\n        var mounts = FS.getMounts(FS.root.mount);\\n        var completed = 0;\\n        function doCallback(errCode) {\\n          assert(FS.syncFSRequests > 0);\\n          FS.syncFSRequests--;\\n          return callback(errCode);\\n        }\\n        function done(errCode) {\\n          if (errCode) {\\n            if (!done.errored) {\\n              done.errored = true;\\n              return doCallback(errCode);\\n            }\\n            return;\\n          }\\n          if (++completed >= mounts.length) {\\n            doCallback(null);\\n          }\\n        }\\n        mounts.forEach((mount) => {\\n          if (!mount.type.syncfs) {\\n            return done(null);\\n          }\\n          mount.type.syncfs(mount, populate, done);\\n        });\\n      },\\n      mount(type, opts, mountpoint) {\\n        if (typeof type == \"string\") {\\n          throw type;\\n        }\\n        var root = mountpoint === \"/\";\\n        var pseudo = !mountpoint;\\n        var node;\\n        if (root && FS.root) {\\n          throw new FS.ErrnoError(10);\\n        } else if (!root && !pseudo) {\\n          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\\n          mountpoint = lookup.path;\\n          node = lookup.node;\\n          if (FS.isMountpoint(node)) {\\n            throw new FS.ErrnoError(10);\\n          }\\n          if (!FS.isDir(node.mode)) {\\n            throw new FS.ErrnoError(54);\\n          }\\n        }\\n        var mount = { type, opts, mountpoint, mounts: [] };\\n        var mountRoot = type.mount(mount);\\n        mountRoot.mount = mount;\\n        mount.root = mountRoot;\\n        if (root) {\\n          FS.root = mountRoot;\\n        } else if (node) {\\n          node.mounted = mount;\\n          if (node.mount) {\\n            node.mount.mounts.push(mount);\\n          }\\n        }\\n        return mountRoot;\\n      },\\n      unmount(mountpoint) {\\n        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\\n        if (!FS.isMountpoint(lookup.node)) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        var node = lookup.node;\\n        var mount = node.mounted;\\n        var mounts = FS.getMounts(mount);\\n        Object.keys(FS.nameTable).forEach((hash) => {\\n          var current = FS.nameTable[hash];\\n          while (current) {\\n            var next = current.name_next;\\n            if (mounts.includes(current.mount)) {\\n              FS.destroyNode(current);\\n            }\\n            current = next;\\n          }\\n        });\\n        node.mounted = null;\\n        var idx = node.mount.mounts.indexOf(mount);\\n        assert(idx !== -1);\\n        node.mount.mounts.splice(idx, 1);\\n      },\\n      lookup(parent, name) {\\n        return parent.node_ops.lookup(parent, name);\\n      },\\n      mknod(path, mode, dev) {\\n        var lookup = FS.lookupPath(path, { parent: true });\\n        var parent = lookup.node;\\n        var name = PATH.basename(path);\\n        if (!name) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        if (name === \".\" || name === \"..\") {\\n          throw new FS.ErrnoError(20);\\n        }\\n        var errCode = FS.mayCreate(parent, name);\\n        if (errCode) {\\n          throw new FS.ErrnoError(errCode);\\n        }\\n        if (!parent.node_ops.mknod) {\\n          throw new FS.ErrnoError(63);\\n        }\\n        return parent.node_ops.mknod(parent, name, mode, dev);\\n      },\\n      statfs(path) {\\n        return FS.statfsNode(FS.lookupPath(path, { follow: true }).node);\\n      },\\n      statfsStream(stream) {\\n        return FS.statfsNode(stream.node);\\n      },\\n      statfsNode(node) {\\n        var rtn = {\\n          bsize: 4096,\\n          frsize: 4096,\\n          blocks: 1e6,\\n          bfree: 5e5,\\n          bavail: 5e5,\\n          files: FS.nextInode,\\n          ffree: FS.nextInode - 1,\\n          fsid: 42,\\n          flags: 2,\\n          namelen: 255,\\n        };\\n        if (node.node_ops.statfs) {\\n          Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));\\n        }\\n        return rtn;\\n      },\\n      create(path, mode = 438) {\\n        mode &= 4095;\\n        mode |= 32768;\\n        return FS.mknod(path, mode, 0);\\n      },\\n      mkdir(path, mode = 511) {\\n        mode &= 511 | 512;\\n        mode |= 16384;\\n        return FS.mknod(path, mode, 0);\\n      },\\n      mkdirTree(path, mode) {\\n        var dirs = path.split(\"/\");\\n        var d = \"\";\\n        for (var i = 0; i < dirs.length; ++i) {\\n          if (!dirs[i]) continue;\\n          d += \"/\" + dirs[i];\\n          try {\\n            FS.mkdir(d, mode);\\n          } catch (e) {\\n            if (e.errno != 20) throw e;\\n          }\\n        }\\n      },\\n      mkdev(path, mode, dev) {\\n        if (typeof dev == \"undefined\") {\\n          dev = mode;\\n          mode = 438;\\n        }\\n        mode |= 8192;\\n        return FS.mknod(path, mode, dev);\\n      },\\n      symlink(oldpath, newpath) {\\n        if (!PATH_FS.resolve(oldpath)) {\\n          throw new FS.ErrnoError(44);\\n        }\\n        var lookup = FS.lookupPath(newpath, { parent: true });\\n        var parent = lookup.node;\\n        if (!parent) {\\n          throw new FS.ErrnoError(44);\\n        }\\n        var newname = PATH.basename(newpath);\\n        var errCode = FS.mayCreate(parent, newname);\\n        if (errCode) {\\n          throw new FS.ErrnoError(errCode);\\n        }\\n        if (!parent.node_ops.symlink) {\\n          throw new FS.ErrnoError(63);\\n        }\\n        return parent.node_ops.symlink(parent, newname, oldpath);\\n      },\\n      rename(old_path, new_path) {\\n        var old_dirname = PATH.dirname(old_path);\\n        var new_dirname = PATH.dirname(new_path);\\n        var old_name = PATH.basename(old_path);\\n        var new_name = PATH.basename(new_path);\\n        var lookup, old_dir, new_dir;\\n        lookup = FS.lookupPath(old_path, { parent: true });\\n        old_dir = lookup.node;\\n        lookup = FS.lookupPath(new_path, { parent: true });\\n        new_dir = lookup.node;\\n        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\\n        if (old_dir.mount !== new_dir.mount) {\\n          throw new FS.ErrnoError(75);\\n        }\\n        var old_node = FS.lookupNode(old_dir, old_name);\\n        var relative = PATH_FS.relative(old_path, new_dirname);\\n        if (relative.charAt(0) !== \".\") {\\n          throw new FS.ErrnoError(28);\\n        }\\n        relative = PATH_FS.relative(new_path, old_dirname);\\n        if (relative.charAt(0) !== \".\") {\\n          throw new FS.ErrnoError(55);\\n        }\\n        var new_node;\\n        try {\\n          new_node = FS.lookupNode(new_dir, new_name);\\n        } catch (e) {}\\n        if (old_node === new_node) {\\n          return;\\n        }\\n        var isdir = FS.isDir(old_node.mode);\\n        var errCode = FS.mayDelete(old_dir, old_name, isdir);\\n        if (errCode) {\\n          throw new FS.ErrnoError(errCode);\\n        }\\n        errCode = new_node\\n          ? FS.mayDelete(new_dir, new_name, isdir)\\n          : FS.mayCreate(new_dir, new_name);\\n        if (errCode) {\\n          throw new FS.ErrnoError(errCode);\\n        }\\n        if (!old_dir.node_ops.rename) {\\n          throw new FS.ErrnoError(63);\\n        }\\n        if (\\n          FS.isMountpoint(old_node) ||\\n          (new_node && FS.isMountpoint(new_node))\\n        ) {\\n          throw new FS.ErrnoError(10);\\n        }\\n        if (new_dir !== old_dir) {\\n          errCode = FS.nodePermissions(old_dir, \"w\");\\n          if (errCode) {\\n            throw new FS.ErrnoError(errCode);\\n          }\\n        }\\n        FS.hashRemoveNode(old_node);\\n        try {\\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\\n          old_node.parent = new_dir;\\n        } catch (e) {\\n          throw e;\\n        } finally {\\n          FS.hashAddNode(old_node);\\n        }\\n      },\\n      rmdir(path) {\\n        var lookup = FS.lookupPath(path, { parent: true });\\n        var parent = lookup.node;\\n        var name = PATH.basename(path);\\n        var node = FS.lookupNode(parent, name);\\n        var errCode = FS.mayDelete(parent, name, true);\\n        if (errCode) {\\n          throw new FS.ErrnoError(errCode);\\n        }\\n        if (!parent.node_ops.rmdir) {\\n          throw new FS.ErrnoError(63);\\n        }\\n        if (FS.isMountpoint(node)) {\\n          throw new FS.ErrnoError(10);\\n        }\\n        parent.node_ops.rmdir(parent, name);\\n        FS.destroyNode(node);\\n      },\\n      readdir(path) {\\n        var lookup = FS.lookupPath(path, { follow: true });\\n        var node = lookup.node;\\n        var readdir = FS.checkOpExists(node.node_ops.readdir, 54);\\n        return readdir(node);\\n      },\\n      unlink(path) {\\n        var lookup = FS.lookupPath(path, { parent: true });\\n        var parent = lookup.node;\\n        if (!parent) {\\n          throw new FS.ErrnoError(44);\\n        }\\n        var name = PATH.basename(path);\\n        var node = FS.lookupNode(parent, name);\\n        var errCode = FS.mayDelete(parent, name, false);\\n        if (errCode) {\\n          throw new FS.ErrnoError(errCode);\\n        }\\n        if (!parent.node_ops.unlink) {\\n          throw new FS.ErrnoError(63);\\n        }\\n        if (FS.isMountpoint(node)) {\\n          throw new FS.ErrnoError(10);\\n        }\\n        parent.node_ops.unlink(parent, name);\\n        FS.destroyNode(node);\\n      },\\n      readlink(path) {\\n        var lookup = FS.lookupPath(path);\\n        var link = lookup.node;\\n        if (!link) {\\n          throw new FS.ErrnoError(44);\\n        }\\n        if (!link.node_ops.readlink) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        return link.node_ops.readlink(link);\\n      },\\n      stat(path, dontFollow) {\\n        var lookup = FS.lookupPath(path, { follow: !dontFollow });\\n        var node = lookup.node;\\n        var getattr = FS.checkOpExists(node.node_ops.getattr, 63);\\n        return getattr(node);\\n      },\\n      fstat(fd) {\\n        var stream = FS.getStreamChecked(fd);\\n        var node = stream.node;\\n        var getattr = stream.stream_ops.getattr;\\n        var arg = getattr ? stream : node;\\n        getattr ??= node.node_ops.getattr;\\n        FS.checkOpExists(getattr, 63);\\n        return getattr(arg);\\n      },\\n      lstat(path) {\\n        return FS.stat(path, true);\\n      },\\n      doChmod(stream, node, mode, dontFollow) {\\n        FS.doSetAttr(stream, node, {\\n          mode: (mode & 4095) | (node.mode & ~4095),\\n          ctime: Date.now(),\\n          dontFollow,\\n        });\\n      },\\n      chmod(path, mode, dontFollow) {\\n        var node;\\n        if (typeof path == \"string\") {\\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\\n          node = lookup.node;\\n        } else {\\n          node = path;\\n        }\\n        FS.doChmod(null, node, mode, dontFollow);\\n      },\\n      lchmod(path, mode) {\\n        FS.chmod(path, mode, true);\\n      },\\n      fchmod(fd, mode) {\\n        var stream = FS.getStreamChecked(fd);\\n        FS.doChmod(stream, stream.node, mode, false);\\n      },\\n      doChown(stream, node, dontFollow) {\\n        FS.doSetAttr(stream, node, { timestamp: Date.now(), dontFollow });\\n      },\\n      chown(path, uid, gid, dontFollow) {\\n        var node;\\n        if (typeof path == \"string\") {\\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\\n          node = lookup.node;\\n        } else {\\n          node = path;\\n        }\\n        FS.doChown(null, node, dontFollow);\\n      },\\n      lchown(path, uid, gid) {\\n        FS.chown(path, uid, gid, true);\\n      },\\n      fchown(fd, uid, gid) {\\n        var stream = FS.getStreamChecked(fd);\\n        FS.doChown(stream, stream.node, false);\\n      },\\n      doTruncate(stream, node, len) {\\n        if (FS.isDir(node.mode)) {\\n          throw new FS.ErrnoError(31);\\n        }\\n        if (!FS.isFile(node.mode)) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        var errCode = FS.nodePermissions(node, \"w\");\\n        if (errCode) {\\n          throw new FS.ErrnoError(errCode);\\n        }\\n        FS.doSetAttr(stream, node, { size: len, timestamp: Date.now() });\\n      },\\n      truncate(path, len) {\\n        if (len < 0) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        var node;\\n        if (typeof path == \"string\") {\\n          var lookup = FS.lookupPath(path, { follow: true });\\n          node = lookup.node;\\n        } else {\\n          node = path;\\n        }\\n        FS.doTruncate(null, node, len);\\n      },\\n      ftruncate(fd, len) {\\n        var stream = FS.getStreamChecked(fd);\\n        if (len < 0 || (stream.flags & 2097155) === 0) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        FS.doTruncate(stream, stream.node, len);\\n      },\\n      utime(path, atime, mtime) {\\n        var lookup = FS.lookupPath(path, { follow: true });\\n        var node = lookup.node;\\n        var setattr = FS.checkOpExists(node.node_ops.setattr, 63);\\n        setattr(node, { atime, mtime });\\n      },\\n      open(path, flags, mode = 438) {\\n        if (path === \"\") {\\n          throw new FS.ErrnoError(44);\\n        }\\n        flags = typeof flags == \"string\" ? FS_modeStringToFlags(flags) : flags;\\n        if (flags & 64) {\\n          mode = (mode & 4095) | 32768;\\n        } else {\\n          mode = 0;\\n        }\\n        var node;\\n        var isDirPath;\\n        if (typeof path == \"object\") {\\n          node = path;\\n        } else {\\n          isDirPath = path.endsWith(\"/\");\\n          var lookup = FS.lookupPath(path, {\\n            follow: !(flags & 131072),\\n            noent_okay: true,\\n          });\\n          node = lookup.node;\\n          path = lookup.path;\\n        }\\n        var created = false;\\n        if (flags & 64) {\\n          if (node) {\\n            if (flags & 128) {\\n              throw new FS.ErrnoError(20);\\n            }\\n          } else if (isDirPath) {\\n            throw new FS.ErrnoError(31);\\n          } else {\\n            node = FS.mknod(path, mode | 511, 0);\\n            created = true;\\n          }\\n        }\\n        if (!node) {\\n          throw new FS.ErrnoError(44);\\n        }\\n        if (FS.isChrdev(node.mode)) {\\n          flags &= ~512;\\n        }\\n        if (flags & 65536 && !FS.isDir(node.mode)) {\\n          throw new FS.ErrnoError(54);\\n        }\\n        if (!created) {\\n          var errCode = FS.mayOpen(node, flags);\\n          if (errCode) {\\n            throw new FS.ErrnoError(errCode);\\n          }\\n        }\\n        if (flags & 512 && !created) {\\n          FS.truncate(node, 0);\\n        }\\n        flags &= ~(128 | 512 | 131072);\\n        var stream = FS.createStream({\\n          node,\\n          path: FS.getPath(node),\\n          flags,\\n          seekable: true,\\n          position: 0,\\n          stream_ops: node.stream_ops,\\n          ungotten: [],\\n          error: false,\\n        });\\n        if (stream.stream_ops.open) {\\n          stream.stream_ops.open(stream);\\n        }\\n        if (created) {\\n          FS.chmod(node, mode & 511);\\n        }\\n        if (Module[\"logReadFiles\"] && !(flags & 1)) {\\n          if (!(path in FS.readFiles)) {\\n            FS.readFiles[path] = 1;\\n          }\\n        }\\n        return stream;\\n      },\\n      close(stream) {\\n        if (FS.isClosed(stream)) {\\n          throw new FS.ErrnoError(8);\\n        }\\n        if (stream.getdents) stream.getdents = null;\\n        try {\\n          if (stream.stream_ops.close) {\\n            stream.stream_ops.close(stream);\\n          }\\n        } catch (e) {\\n          throw e;\\n        } finally {\\n          FS.closeStream(stream.fd);\\n        }\\n        stream.fd = null;\\n      },\\n      isClosed(stream) {\\n        return stream.fd === null;\\n      },\\n      llseek(stream, offset, whence) {\\n        if (FS.isClosed(stream)) {\\n          throw new FS.ErrnoError(8);\\n        }\\n        if (!stream.seekable || !stream.stream_ops.llseek) {\\n          throw new FS.ErrnoError(70);\\n        }\\n        if (whence != 0 && whence != 1 && whence != 2) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\\n        stream.ungotten = [];\\n        return stream.position;\\n      },\\n      read(stream, buffer, offset, length, position) {\\n        assert(offset >= 0);\\n        if (length < 0 || position < 0) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        if (FS.isClosed(stream)) {\\n          throw new FS.ErrnoError(8);\\n        }\\n        if ((stream.flags & 2097155) === 1) {\\n          throw new FS.ErrnoError(8);\\n        }\\n        if (FS.isDir(stream.node.mode)) {\\n          throw new FS.ErrnoError(31);\\n        }\\n        if (!stream.stream_ops.read) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        var seeking = typeof position != \"undefined\";\\n        if (!seeking) {\\n          position = stream.position;\\n        } else if (!stream.seekable) {\\n          throw new FS.ErrnoError(70);\\n        }\\n        var bytesRead = stream.stream_ops.read(\\n          stream,\\n          buffer,\\n          offset,\\n          length,\\n          position,\\n        );\\n        if (!seeking) stream.position += bytesRead;\\n        return bytesRead;\\n      },\\n      write(stream, buffer, offset, length, position, canOwn) {\\n        assert(offset >= 0);\\n        if (length < 0 || position < 0) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        if (FS.isClosed(stream)) {\\n          throw new FS.ErrnoError(8);\\n        }\\n        if ((stream.flags & 2097155) === 0) {\\n          throw new FS.ErrnoError(8);\\n        }\\n        if (FS.isDir(stream.node.mode)) {\\n          throw new FS.ErrnoError(31);\\n        }\\n        if (!stream.stream_ops.write) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        if (stream.seekable && stream.flags & 1024) {\\n          FS.llseek(stream, 0, 2);\\n        }\\n        var seeking = typeof position != \"undefined\";\\n        if (!seeking) {\\n          position = stream.position;\\n        } else if (!stream.seekable) {\\n          throw new FS.ErrnoError(70);\\n        }\\n        var bytesWritten = stream.stream_ops.write(\\n          stream,\\n          buffer,\\n          offset,\\n          length,\\n          position,\\n          canOwn,\\n        );\\n        if (!seeking) stream.position += bytesWritten;\\n        return bytesWritten;\\n      },\\n      allocate(stream, offset, length) {\\n        if (FS.isClosed(stream)) {\\n          throw new FS.ErrnoError(8);\\n        }\\n        if (offset < 0 || length <= 0) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        if ((stream.flags & 2097155) === 0) {\\n          throw new FS.ErrnoError(8);\\n        }\\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\\n          throw new FS.ErrnoError(43);\\n        }\\n        if (!stream.stream_ops.allocate) {\\n          throw new FS.ErrnoError(138);\\n        }\\n        stream.stream_ops.allocate(stream, offset, length);\\n      },\\n      mmap(stream, length, position, prot, flags) {\\n        if (\\n          (prot & 2) !== 0 &&\\n          (flags & 2) === 0 &&\\n          (stream.flags & 2097155) !== 2\\n        ) {\\n          throw new FS.ErrnoError(2);\\n        }\\n        if ((stream.flags & 2097155) === 1) {\\n          throw new FS.ErrnoError(2);\\n        }\\n        if (!stream.stream_ops.mmap) {\\n          throw new FS.ErrnoError(43);\\n        }\\n        if (!length) {\\n          throw new FS.ErrnoError(28);\\n        }\\n        return stream.stream_ops.mmap(stream, length, position, prot, flags);\\n      },\\n      msync(stream, buffer, offset, length, mmapFlags) {\\n        assert(offset >= 0);\\n        if (!stream.stream_ops.msync) {\\n          return 0;\\n        }\\n        return stream.stream_ops.msync(\\n          stream,\\n          buffer,\\n          offset,\\n          length,\\n          mmapFlags,\\n        );\\n      },\\n      ioctl(stream, cmd, arg) {\\n        if (!stream.stream_ops.ioctl) {\\n          throw new FS.ErrnoError(59);\\n        }\\n        return stream.stream_ops.ioctl(stream, cmd, arg);\\n      },\\n      readFile(path, opts = {}) {\\n        opts.flags = opts.flags || 0;\\n        opts.encoding = opts.encoding || \"binary\";\\n        if (opts.encoding !== \"utf8\" && opts.encoding !== \"binary\") {\\n          throw new Error(`Invalid encoding type \"${opts.encoding}\"`);\\n        }\\n        var ret;\\n        var stream = FS.open(path, opts.flags);\\n        var stat = FS.stat(path);\\n        var length = stat.size;\\n        var buf = new Uint8Array(length);\\n        FS.read(stream, buf, 0, length, 0);\\n        if (opts.encoding === \"utf8\") {\\n          ret = UTF8ArrayToString(buf);\\n        } else if (opts.encoding === \"binary\") {\\n          ret = buf;\\n        }\\n        FS.close(stream);\\n        return ret;\\n      },\\n      writeFile(path, data, opts = {}) {\\n        opts.flags = opts.flags || 577;\\n        var stream = FS.open(path, opts.flags, opts.mode);\\n        if (typeof data == \"string\") {\\n          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\\n          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\\n        } else if (ArrayBuffer.isView(data)) {\\n          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\\n        } else {\\n          throw new Error(\"Unsupported data type\");\\n        }\\n        FS.close(stream);\\n      },\\n      cwd: () => FS.currentPath,\\n      chdir(path) {\\n        var lookup = FS.lookupPath(path, { follow: true });\\n        if (lookup.node === null) {\\n          throw new FS.ErrnoError(44);\\n        }\\n        if (!FS.isDir(lookup.node.mode)) {\\n          throw new FS.ErrnoError(54);\\n        }\\n        var errCode = FS.nodePermissions(lookup.node, \"x\");\\n        if (errCode) {\\n          throw new FS.ErrnoError(errCode);\\n        }\\n        FS.currentPath = lookup.path;\\n      },\\n      createDefaultDirectories() {\\n        FS.mkdir(\"/tmp\");\\n        FS.mkdir(\"/home\");\\n        FS.mkdir(\"/home/web_user\");\\n      },\\n      createDefaultDevices() {\\n        FS.mkdir(\"/dev\");\\n        FS.registerDevice(FS.makedev(1, 3), {\\n          read: () => 0,\\n          write: (stream, buffer, offset, length, pos) => length,\\n          llseek: () => 0,\\n        });\\n        FS.mkdev(\"/dev/null\", FS.makedev(1, 3));\\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\\n        FS.mkdev(\"/dev/tty\", FS.makedev(5, 0));\\n        FS.mkdev(\"/dev/tty1\", FS.makedev(6, 0));\\n        var randomBuffer = new Uint8Array(1024),\\n          randomLeft = 0;\\n        var randomByte = () => {\\n          if (randomLeft === 0) {\\n            randomFill(randomBuffer);\\n            randomLeft = randomBuffer.byteLength;\\n          }\\n          return randomBuffer[--randomLeft];\\n        };\\n        FS.createDevice(\"/dev\", \"random\", randomByte);\\n        FS.createDevice(\"/dev\", \"urandom\", randomByte);\\n        FS.mkdir(\"/dev/shm\");\\n        FS.mkdir(\"/dev/shm/tmp\");\\n      },\\n      createSpecialDirectories() {\\n        FS.mkdir(\"/proc\");\\n        var proc_self = FS.mkdir(\"/proc/self\");\\n        FS.mkdir(\"/proc/self/fd\");\\n        FS.mount(\\n          {\\n            mount() {\\n              var node = FS.createNode(proc_self, \"fd\", 16895, 73);\\n              node.stream_ops = { llseek: MEMFS.stream_ops.llseek };\\n              node.node_ops = {\\n                lookup(parent, name) {\\n                  var fd = +name;\\n                  var stream = FS.getStreamChecked(fd);\\n                  var ret = {\\n                    parent: null,\\n                    mount: { mountpoint: \"fake\" },\\n                    node_ops: { readlink: () => stream.path },\\n                    id: fd + 1,\\n                  };\\n                  ret.parent = ret;\\n                  return ret;\\n                },\\n                readdir() {\\n                  return Array.from(FS.streams.entries())\\n                    .filter(([k, v]) => v)\\n                    .map(([k, v]) => k.toString());\\n                },\\n              };\\n              return node;\\n            },\\n          },\\n          {},\\n          \"/proc/self/fd\",\\n        );\\n      },\\n      createStandardStreams(input, output, error) {\\n        if (input) {\\n          FS.createDevice(\"/dev\", \"stdin\", input);\\n        } else {\\n          FS.symlink(\"/dev/tty\", \"/dev/stdin\");\\n        }\\n        if (output) {\\n          FS.createDevice(\"/dev\", \"stdout\", null, output);\\n        } else {\\n          FS.symlink(\"/dev/tty\", \"/dev/stdout\");\\n        }\\n        if (error) {\\n          FS.createDevice(\"/dev\", \"stderr\", null, error);\\n        } else {\\n          FS.symlink(\"/dev/tty1\", \"/dev/stderr\");\\n        }\\n        var stdin = FS.open(\"/dev/stdin\", 0);\\n        var stdout = FS.open(\"/dev/stdout\", 1);\\n        var stderr = FS.open(\"/dev/stderr\", 1);\\n        assert(stdin.fd === 0, `invalid handle for stdin (${stdin.fd})`);\\n        assert(stdout.fd === 1, `invalid handle for stdout (${stdout.fd})`);\\n        assert(stderr.fd === 2, `invalid handle for stderr (${stderr.fd})`);\\n      },\\n      staticInit() {\\n        FS.nameTable = new Array(4096);\\n        FS.mount(MEMFS, {}, \"/\");\\n        FS.createDefaultDirectories();\\n        FS.createDefaultDevices();\\n        FS.createSpecialDirectories();\\n        FS.filesystems = { MEMFS };\\n      },\\n      init(input, output, error) {\\n        assert(\\n          !FS.initialized,\\n          \"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)\",\\n        );\\n        FS.initialized = true;\\n        input ??= Module[\"stdin\"];\\n        output ??= Module[\"stdout\"];\\n        error ??= Module[\"stderr\"];\\n        FS.createStandardStreams(input, output, error);\\n      },\\n      quit() {\\n        FS.initialized = false;\\n        _fflush(0);\\n        for (var i = 0; i < FS.streams.length; i++) {\\n          var stream = FS.streams[i];\\n          if (!stream) {\\n            continue;\\n          }\\n          FS.close(stream);\\n        }\\n      },\\n      findObject(path, dontResolveLastLink) {\\n        var ret = FS.analyzePath(path, dontResolveLastLink);\\n        if (!ret.exists) {\\n          return null;\\n        }\\n        return ret.object;\\n      },\\n      analyzePath(path, dontResolveLastLink) {\\n        try {\\n          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\\n          path = lookup.path;\\n        } catch (e) {}\\n        var ret = {\\n          isRoot: false,\\n          exists: false,\\n          error: 0,\\n          name: null,\\n          path: null,\\n          object: null,\\n          parentExists: false,\\n          parentPath: null,\\n          parentObject: null,\\n        };\\n        try {\\n          var lookup = FS.lookupPath(path, { parent: true });\\n          ret.parentExists = true;\\n          ret.parentPath = lookup.path;\\n          ret.parentObject = lookup.node;\\n          ret.name = PATH.basename(path);\\n          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\\n          ret.exists = true;\\n          ret.path = lookup.path;\\n          ret.object = lookup.node;\\n          ret.name = lookup.node.name;\\n          ret.isRoot = lookup.path === \"/\";\\n        } catch (e) {\\n          ret.error = e.errno;\\n        }\\n        return ret;\\n      },\\n      createPath(parent, path, canRead, canWrite) {\\n        parent = typeof parent == \"string\" ? parent : FS.getPath(parent);\\n        var parts = path.split(\"/\").reverse();\\n        while (parts.length) {\\n          var part = parts.pop();\\n          if (!part) continue;\\n          var current = PATH.join2(parent, part);\\n          try {\\n            FS.mkdir(current);\\n          } catch (e) {}\\n          parent = current;\\n        }\\n        return current;\\n      },\\n      createFile(parent, name, properties, canRead, canWrite) {\\n        var path = PATH.join2(\\n          typeof parent == \"string\" ? parent : FS.getPath(parent),\\n          name,\\n        );\\n        var mode = FS_getMode(canRead, canWrite);\\n        return FS.create(path, mode);\\n      },\\n      createDataFile(parent, name, data, canRead, canWrite, canOwn) {\\n        var path = name;\\n        if (parent) {\\n          parent = typeof parent == \"string\" ? parent : FS.getPath(parent);\\n          path = name ? PATH.join2(parent, name) : parent;\\n        }\\n        var mode = FS_getMode(canRead, canWrite);\\n        var node = FS.create(path, mode);\\n        if (data) {\\n          if (typeof data == \"string\") {\\n            var arr = new Array(data.length);\\n            for (var i = 0, len = data.length; i < len; ++i)\\n              arr[i] = data.charCodeAt(i);\\n            data = arr;\\n          }\\n          FS.chmod(node, mode | 146);\\n          var stream = FS.open(node, 577);\\n          FS.write(stream, data, 0, data.length, 0, canOwn);\\n          FS.close(stream);\\n          FS.chmod(node, mode);\\n        }\\n      },\\n      createDevice(parent, name, input, output) {\\n        var path = PATH.join2(\\n          typeof parent == \"string\" ? parent : FS.getPath(parent),\\n          name,\\n        );\\n        var mode = FS_getMode(!!input, !!output);\\n        FS.createDevice.major ??= 64;\\n        var dev = FS.makedev(FS.createDevice.major++, 0);\\n        FS.registerDevice(dev, {\\n          open(stream) {\\n            stream.seekable = false;\\n          },\\n          close(stream) {\\n            if (output?.buffer?.length) {\\n              output(10);\\n            }\\n          },\\n          read(stream, buffer, offset, length, pos) {\\n            var bytesRead = 0;\\n            for (var i = 0; i < length; i++) {\\n              var result;\\n              try {\\n                result = input();\\n              } catch (e) {\\n                throw new FS.ErrnoError(29);\\n              }\\n              if (result === undefined && bytesRead === 0) {\\n                throw new FS.ErrnoError(6);\\n              }\\n              if (result === null || result === undefined) break;\\n              bytesRead++;\\n              buffer[offset + i] = result;\\n            }\\n            if (bytesRead) {\\n              stream.node.atime = Date.now();\\n            }\\n            return bytesRead;\\n          },\\n          write(stream, buffer, offset, length, pos) {\\n            for (var i = 0; i < length; i++) {\\n              try {\\n                output(buffer[offset + i]);\\n              } catch (e) {\\n                throw new FS.ErrnoError(29);\\n              }\\n            }\\n            if (length) {\\n              stream.node.mtime = stream.node.ctime = Date.now();\\n            }\\n            return i;\\n          },\\n        });\\n        return FS.mkdev(path, mode, dev);\\n      },\\n      forceLoadFile(obj) {\\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents)\\n          return true;\\n        if (typeof XMLHttpRequest != \"undefined\") {\\n          throw new Error(\\n            \"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\",\\n          );\\n        } else {\\n          try {\\n            obj.contents = readBinary(obj.url);\\n            obj.usedBytes = obj.contents.length;\\n          } catch (e) {\\n            throw new FS.ErrnoError(29);\\n          }\\n        }\\n      },\\n      createLazyFile(parent, name, url, canRead, canWrite) {\\n        class LazyUint8Array {\\n          lengthKnown = false;\\n          chunks = [];\\n          get(idx) {\\n            if (idx > this.length - 1 || idx < 0) {\\n              return undefined;\\n            }\\n            var chunkOffset = idx % this.chunkSize;\\n            var chunkNum = (idx / this.chunkSize) | 0;\\n            return this.getter(chunkNum)[chunkOffset];\\n          }\\n          setDataGetter(getter) {\\n            this.getter = getter;\\n          }\\n          cacheLength() {\\n            var xhr = new XMLHttpRequest();\\n            xhr.open(\"HEAD\", url, false);\\n            xhr.send(null);\\n            if (\\n              !((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304)\\n            )\\n              throw new Error(\\n                \"Couldn\\'t load \" + url + \". Status: \" + xhr.status,\\n              );\\n            var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\\n            var header;\\n            var hasByteServing =\\n              (header = xhr.getResponseHeader(\"Accept-Ranges\")) &&\\n              header === \"bytes\";\\n            var usesGzip =\\n              (header = xhr.getResponseHeader(\"Content-Encoding\")) &&\\n              header === \"gzip\";\\n            var chunkSize = 1024 * 1024;\\n            if (!hasByteServing) chunkSize = datalength;\\n            var doXHR = (from, to) => {\\n              if (from > to)\\n                throw new Error(\\n                  \"invalid range (\" +\\n                    from +\\n                    \", \" +\\n                    to +\\n                    \") or no bytes requested!\",\\n                );\\n              if (to > datalength - 1)\\n                throw new Error(\\n                  \"only \" + datalength + \" bytes available! programmer error!\",\\n                );\\n              var xhr = new XMLHttpRequest();\\n              xhr.open(\"GET\", url, false);\\n              if (datalength !== chunkSize)\\n                xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\\n              xhr.responseType = \"arraybuffer\";\\n              if (xhr.overrideMimeType) {\\n                xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\\n              }\\n              xhr.send(null);\\n              if (\\n                !((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304)\\n              )\\n                throw new Error(\\n                  \"Couldn\\'t load \" + url + \". Status: \" + xhr.status,\\n                );\\n              if (xhr.response !== undefined) {\\n                return new Uint8Array(xhr.response || []);\\n              }\\n              return intArrayFromString(xhr.responseText || \"\", true);\\n            };\\n            var lazyArray = this;\\n            lazyArray.setDataGetter((chunkNum) => {\\n              var start = chunkNum * chunkSize;\\n              var end = (chunkNum + 1) * chunkSize - 1;\\n              end = Math.min(end, datalength - 1);\\n              if (typeof lazyArray.chunks[chunkNum] == \"undefined\") {\\n                lazyArray.chunks[chunkNum] = doXHR(start, end);\\n              }\\n              if (typeof lazyArray.chunks[chunkNum] == \"undefined\")\\n                throw new Error(\"doXHR failed!\");\\n              return lazyArray.chunks[chunkNum];\\n            });\\n            if (usesGzip || !datalength) {\\n              chunkSize = datalength = 1;\\n              datalength = this.getter(0).length;\\n              chunkSize = datalength;\\n              out(\\n                \"LazyFiles on gzip forces download of the whole file when length is accessed\",\\n              );\\n            }\\n            this._length = datalength;\\n            this._chunkSize = chunkSize;\\n            this.lengthKnown = true;\\n          }\\n          get length() {\\n            if (!this.lengthKnown) {\\n              this.cacheLength();\\n            }\\n            return this._length;\\n          }\\n          get chunkSize() {\\n            if (!this.lengthKnown) {\\n              this.cacheLength();\\n            }\\n            return this._chunkSize;\\n          }\\n        }\\n        if (typeof XMLHttpRequest != \"undefined\") {\\n          if (!ENVIRONMENT_IS_WORKER)\\n            throw \"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";\\n          var lazyArray = new LazyUint8Array();\\n          var properties = { isDevice: false, contents: lazyArray };\\n        } else {\\n          var properties = { isDevice: false, url };\\n        }\\n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\\n        if (properties.contents) {\\n          node.contents = properties.contents;\\n        } else if (properties.url) {\\n          node.contents = null;\\n          node.url = properties.url;\\n        }\\n        Object.defineProperties(node, {\\n          usedBytes: {\\n            get: function () {\\n              return this.contents.length;\\n            },\\n          },\\n        });\\n        var stream_ops = {};\\n        var keys = Object.keys(node.stream_ops);\\n        keys.forEach((key) => {\\n          var fn = node.stream_ops[key];\\n          stream_ops[key] = (...args) => {\\n            FS.forceLoadFile(node);\\n            return fn(...args);\\n          };\\n        });\\n        function writeChunks(stream, buffer, offset, length, position) {\\n          var contents = stream.node.contents;\\n          if (position >= contents.length) return 0;\\n          var size = Math.min(contents.length - position, length);\\n          assert(size >= 0);\\n          if (contents.slice) {\\n            for (var i = 0; i < size; i++) {\\n              buffer[offset + i] = contents[position + i];\\n            }\\n          } else {\\n            for (var i = 0; i < size; i++) {\\n              buffer[offset + i] = contents.get(position + i);\\n            }\\n          }\\n          return size;\\n        }\\n        stream_ops.read = (stream, buffer, offset, length, position) => {\\n          FS.forceLoadFile(node);\\n          return writeChunks(stream, buffer, offset, length, position);\\n        };\\n        stream_ops.mmap = (stream, length, position, prot, flags) => {\\n          FS.forceLoadFile(node);\\n          var ptr = mmapAlloc(length);\\n          if (!ptr) {\\n            throw new FS.ErrnoError(48);\\n          }\\n          writeChunks(stream, HEAP8, ptr, length, position);\\n          return { ptr, allocated: true };\\n        };\\n        node.stream_ops = stream_ops;\\n        return node;\\n      },\\n      absolutePath() {\\n        abort(\"FS.absolutePath has been removed; use PATH_FS.resolve instead\");\\n      },\\n      createFolder() {\\n        abort(\"FS.createFolder has been removed; use FS.mkdir instead\");\\n      },\\n      createLink() {\\n        abort(\"FS.createLink has been removed; use FS.symlink instead\");\\n      },\\n      joinPath() {\\n        abort(\"FS.joinPath has been removed; use PATH.join instead\");\\n      },\\n      mmapAlloc() {\\n        abort(\\n          \"FS.mmapAlloc has been replaced by the top level function mmapAlloc\",\\n        );\\n      },\\n      standardizePath() {\\n        abort(\\n          \"FS.standardizePath has been removed; use PATH.normalize instead\",\\n        );\\n      },\\n    };\\n    var SYSCALLS = {\\n      DEFAULT_POLLMASK: 5,\\n      calculateAt(dirfd, path, allowEmpty) {\\n        if (PATH.isAbs(path)) {\\n          return path;\\n        }\\n        var dir;\\n        if (dirfd === -100) {\\n          dir = FS.cwd();\\n        } else {\\n          var dirstream = SYSCALLS.getStreamFromFD(dirfd);\\n          dir = dirstream.path;\\n        }\\n        if (path.length == 0) {\\n          if (!allowEmpty) {\\n            throw new FS.ErrnoError(44);\\n          }\\n          return dir;\\n        }\\n        return dir + \"/\" + path;\\n      },\\n      writeStat(buf, stat) {\\n        HEAP32[buf / 4] = stat.dev;\\n        HEAP32[(buf + 4) / 4] = stat.mode;\\n        HEAPU64[(buf + 8) / 8] = BigInt(stat.nlink);\\n        HEAP32[(buf + 16) / 4] = stat.uid;\\n        HEAP32[(buf + 20) / 4] = stat.gid;\\n        HEAP32[(buf + 24) / 4] = stat.rdev;\\n        HEAP64[(buf + 32) / 8] = BigInt(stat.size);\\n        HEAP32[(buf + 40) / 4] = 4096;\\n        HEAP32[(buf + 44) / 4] = stat.blocks;\\n        var atime = stat.atime.getTime();\\n        var mtime = stat.mtime.getTime();\\n        var ctime = stat.ctime.getTime();\\n        HEAP64[(buf + 48) / 8] = BigInt(Math.floor(atime / 1e3));\\n        HEAPU64[(buf + 56) / 8] = BigInt((atime % 1e3) * 1e3 * 1e3);\\n        HEAP64[(buf + 64) / 8] = BigInt(Math.floor(mtime / 1e3));\\n        HEAPU64[(buf + 72) / 8] = BigInt((mtime % 1e3) * 1e3 * 1e3);\\n        HEAP64[(buf + 80) / 8] = BigInt(Math.floor(ctime / 1e3));\\n        HEAPU64[(buf + 88) / 8] = BigInt((ctime % 1e3) * 1e3 * 1e3);\\n        HEAP64[(buf + 96) / 8] = BigInt(stat.ino);\\n        return 0;\\n      },\\n      writeStatFs(buf, stats) {\\n        HEAP32[(buf + 8) / 4] = stats.bsize;\\n        HEAP32[(buf + 56) / 4] = stats.bsize;\\n        HEAP32[(buf + 16) / 4] = stats.blocks;\\n        HEAP32[(buf + 20) / 4] = stats.bfree;\\n        HEAP32[(buf + 24) / 4] = stats.bavail;\\n        HEAP32[(buf + 28) / 4] = stats.files;\\n        HEAP32[(buf + 32) / 4] = stats.ffree;\\n        HEAP32[(buf + 36) / 4] = stats.fsid;\\n        HEAP32[(buf + 64) / 4] = stats.flags;\\n        HEAP32[(buf + 48) / 4] = stats.namelen;\\n      },\\n      doMsync(addr, stream, len, flags, offset) {\\n        if (!FS.isFile(stream.node.mode)) {\\n          throw new FS.ErrnoError(43);\\n        }\\n        if (flags & 2) {\\n          return 0;\\n        }\\n        var buffer = HEAPU8.slice(addr, addr + len);\\n        FS.msync(stream, buffer, offset, len, flags);\\n      },\\n      getStreamFromFD(fd) {\\n        var stream = FS.getStreamChecked(fd);\\n        return stream;\\n      },\\n      varargs: undefined,\\n      getStr(ptr) {\\n        var ret = UTF8ToString(ptr);\\n        return ret;\\n      },\\n    };\\n    function ___syscall_fcntl64(fd, cmd, varargs) {\\n      varargs = bigintToI53Checked(varargs);\\n      SYSCALLS.varargs = varargs;\\n      try {\\n        var stream = SYSCALLS.getStreamFromFD(fd);\\n        switch (cmd) {\\n          case 0: {\\n            var arg = syscallGetVarargI();\\n            if (arg < 0) {\\n              return -28;\\n            }\\n            while (FS.streams[arg]) {\\n              arg++;\\n            }\\n            var newStream;\\n            newStream = FS.dupStream(stream, arg);\\n            return newStream.fd;\\n          }\\n          case 1:\\n          case 2:\\n            return 0;\\n          case 3:\\n            return stream.flags;\\n          case 4: {\\n            var arg = syscallGetVarargI();\\n            stream.flags |= arg;\\n            return 0;\\n          }\\n          case 5: {\\n            var arg = syscallGetVarargP();\\n            var offset = 0;\\n            HEAP16[(arg + offset) / 2] = 2;\\n            return 0;\\n          }\\n          case 6:\\n          case 7:\\n            return 0;\\n        }\\n        return -28;\\n      } catch (e) {\\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\\n        return -e.errno;\\n      }\\n    }\\n    function ___syscall_fstat64(fd, buf) {\\n      buf = bigintToI53Checked(buf);\\n      try {\\n        return SYSCALLS.writeStat(buf, FS.fstat(fd));\\n      } catch (e) {\\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\\n        return -e.errno;\\n      }\\n    }\\n    function ___syscall_ioctl(fd, op, varargs) {\\n      varargs = bigintToI53Checked(varargs);\\n      SYSCALLS.varargs = varargs;\\n      try {\\n        var stream = SYSCALLS.getStreamFromFD(fd);\\n        switch (op) {\\n          case 21509: {\\n            if (!stream.tty) return -59;\\n            return 0;\\n          }\\n          case 21505: {\\n            if (!stream.tty) return -59;\\n            if (stream.tty.ops.ioctl_tcgets) {\\n              var termios = stream.tty.ops.ioctl_tcgets(stream);\\n              var argp = syscallGetVarargP();\\n              HEAP32[argp / 4] = termios.c_iflag || 0;\\n              HEAP32[(argp + 4) / 4] = termios.c_oflag || 0;\\n              HEAP32[(argp + 8) / 4] = termios.c_cflag || 0;\\n              HEAP32[(argp + 12) / 4] = termios.c_lflag || 0;\\n              for (var i = 0; i < 32; i++) {\\n                HEAP8[argp + i + 17] = termios.c_cc[i] || 0;\\n              }\\n              return 0;\\n            }\\n            return 0;\\n          }\\n          case 21510:\\n          case 21511:\\n          case 21512: {\\n            if (!stream.tty) return -59;\\n            return 0;\\n          }\\n          case 21506:\\n          case 21507:\\n          case 21508: {\\n            if (!stream.tty) return -59;\\n            if (stream.tty.ops.ioctl_tcsets) {\\n              var argp = syscallGetVarargP();\\n              var c_iflag = HEAP32[argp / 4];\\n              var c_oflag = HEAP32[(argp + 4) / 4];\\n              var c_cflag = HEAP32[(argp + 8) / 4];\\n              var c_lflag = HEAP32[(argp + 12) / 4];\\n              var c_cc = [];\\n              for (var i = 0; i < 32; i++) {\\n                c_cc.push(HEAP8[argp + i + 17]);\\n              }\\n              return stream.tty.ops.ioctl_tcsets(stream.tty, op, {\\n                c_iflag,\\n                c_oflag,\\n                c_cflag,\\n                c_lflag,\\n                c_cc,\\n              });\\n            }\\n            return 0;\\n          }\\n          case 21519: {\\n            if (!stream.tty) return -59;\\n            var argp = syscallGetVarargP();\\n            HEAP32[argp / 4] = 0;\\n            return 0;\\n          }\\n          case 21520: {\\n            if (!stream.tty) return -59;\\n            return -28;\\n          }\\n          case 21531: {\\n            var argp = syscallGetVarargP();\\n            return FS.ioctl(stream, op, argp);\\n          }\\n          case 21523: {\\n            if (!stream.tty) return -59;\\n            if (stream.tty.ops.ioctl_tiocgwinsz) {\\n              var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);\\n              var argp = syscallGetVarargP();\\n              HEAP16[argp / 2] = winsize[0];\\n              HEAP16[(argp + 2) / 2] = winsize[1];\\n            }\\n            return 0;\\n          }\\n          case 21524: {\\n            if (!stream.tty) return -59;\\n            return 0;\\n          }\\n          case 21515: {\\n            if (!stream.tty) return -59;\\n            return 0;\\n          }\\n          default:\\n            return -28;\\n        }\\n      } catch (e) {\\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\\n        return -e.errno;\\n      }\\n    }\\n    function ___syscall_openat(dirfd, path, flags, varargs) {\\n      path = bigintToI53Checked(path);\\n      varargs = bigintToI53Checked(varargs);\\n      SYSCALLS.varargs = varargs;\\n      try {\\n        path = SYSCALLS.getStr(path);\\n        path = SYSCALLS.calculateAt(dirfd, path);\\n        var mode = varargs ? syscallGetVarargI() : 0;\\n        return FS.open(path, flags, mode).fd;\\n      } catch (e) {\\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\\n        return -e.errno;\\n      }\\n    }\\n    var __abort_js = () => abort(\"native code called abort()\");\\n    var runtimeKeepaliveCounter = 0;\\n    var __emscripten_runtime_keepalive_clear = () => {\\n      noExitRuntime = false;\\n      runtimeKeepaliveCounter = 0;\\n    };\\n    function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {\\n      len = bigintToI53Checked(len);\\n      offset = bigintToI53Checked(offset);\\n      allocated = bigintToI53Checked(allocated);\\n      addr = bigintToI53Checked(addr);\\n      try {\\n        if (isNaN(offset)) return 61;\\n        var stream = SYSCALLS.getStreamFromFD(fd);\\n        var res = FS.mmap(stream, len, offset, prot, flags);\\n        var ptr = res.ptr;\\n        HEAP32[allocated / 4] = res.allocated;\\n        HEAPU64[addr / 8] = BigInt(ptr);\\n        return 0;\\n      } catch (e) {\\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\\n        return -e.errno;\\n      }\\n    }\\n    function __munmap_js(addr, len, prot, flags, fd, offset) {\\n      addr = bigintToI53Checked(addr);\\n      len = bigintToI53Checked(len);\\n      offset = bigintToI53Checked(offset);\\n      try {\\n        var stream = SYSCALLS.getStreamFromFD(fd);\\n        if (prot & 2) {\\n          SYSCALLS.doMsync(addr, stream, len, flags, offset);\\n        }\\n      } catch (e) {\\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\\n        return -e.errno;\\n      }\\n    }\\n    var timers = {};\\n    var handleException = (e) => {\\n      if (e instanceof ExitStatus || e == \"unwind\") {\\n        return EXITSTATUS;\\n      }\\n      checkStackCookie();\\n      if (e instanceof WebAssembly.RuntimeError) {\\n        if (_emscripten_stack_get_current() <= 0) {\\n          err(\\n            \"Stack overflow detected.  You can try increasing -sSTACK_SIZE (currently set to 65536)\",\\n          );\\n        }\\n      }\\n      quit_(1, e);\\n    };\\n    var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;\\n    var _proc_exit = (code) => {\\n      EXITSTATUS = code;\\n      if (!keepRuntimeAlive()) {\\n        Module[\"onExit\"]?.(code);\\n        ABORT = true;\\n      }\\n      quit_(code, new ExitStatus(code));\\n    };\\n    var exitJS = (statusw, implicit) => {\\n      EXITSTATUS = statusw;\\n      checkUnflushedContent();\\n      if (keepRuntimeAlive() && !implicit) {\\n\\n        for (let i = 0; i < instructions.length; i++){\\n          instructions[i]._rowVariant = \\'\\';\\n        }\\n        status.run_program = -1; // program finished\\n        if (statusw !== 0){\\n          reset_disable.value = false;\\n          instruction_disable.value = true;\\n          run_disable.value = true;\\n          stop_disable.value = false;\\n          show_notification(\"Your program has finished with errors.\", \"danger\");\\n        } else {\\n          reset_disable.value = false;\\n          instruction_disable.value = false;\\n          run_disable.value = false;\\n          stop_disable.value = true;\\n          isFinished.value = true;\\n        }\\n        var msg = `program exited (with status: ${statusw}), but keepRuntimeAlive() is set (counter=${runtimeKeepaliveCounter}) due to an async operation, so halting execution but not exiting the runtime or preventing further async execution (you can use emscripten_force_exit, if you want to force a true shutdown)`;\\n        readyPromiseReject(msg);\\n        err(msg);\\n      }\\n      _proc_exit(statusw);\\n    };\\n    var _exit = exitJS;\\n    var maybeExit = () => {\\n      if (!keepRuntimeAlive()) {\\n        try {\\n          _exit(EXITSTATUS);\\n        } catch (e) {\\n          handleException(e);\\n        }\\n      }\\n    };\\n    var callUserCallback = (func) => {\\n      if (ABORT) {\\n        err(\\n          \"user callback triggered after runtime exited or application aborted.  Ignoring.\",\\n        );\\n        return;\\n      }\\n      try {\\n        func();\\n        maybeExit();\\n      } catch (e) {\\n        handleException(e);\\n      }\\n    };\\n    var _emscripten_get_now = () => performance.now();\\n    var __setitimer_js = (which, timeout_ms) => {\\n      if (timers[which]) {\\n        clearTimeout(timers[which].id);\\n        delete timers[which];\\n      }\\n      if (!timeout_ms) return 0;\\n      var id = setTimeout(() => {\\n        assert(which in timers);\\n        delete timers[which];\\n        callUserCallback(() =>\\n          __emscripten_timeout(which, _emscripten_get_now()),\\n        );\\n      }, timeout_ms);\\n      timers[which] = { id, timeout_ms };\\n      return 0;\\n    };\\n    var _emscripten_set_main_loop_timing = (mode, value) => {\\n      MainLoop.timingMode = mode;\\n      MainLoop.timingValue = value;\\n      if (!MainLoop.func) {\\n        err(\\n          \"emscripten_set_main_loop_timing: Cannot set timing mode for main loop since a main loop does not exist! Call emscripten_set_main_loop first to set one up.\",\\n        );\\n        return 1;\\n      }\\n      if (!MainLoop.running) {\\n        MainLoop.running = true;\\n      }\\n      if (mode == 0) {\\n        MainLoop.scheduler = function MainLoop_scheduler_setTimeout() {\\n          var timeUntilNextTick =\\n            Math.max(\\n              0,\\n              MainLoop.tickStartTime + value - _emscripten_get_now(),\\n            ) | 0;\\n          setTimeout(MainLoop.runner, timeUntilNextTick);\\n        };\\n        MainLoop.method = \"timeout\";\\n      } else if (mode == 1) {\\n        MainLoop.scheduler = function MainLoop_scheduler_rAF() {\\n          MainLoop.requestAnimationFrame(MainLoop.runner);\\n        };\\n        MainLoop.method = \"rAF\";\\n      } else if (mode == 2) {\\n        if (typeof MainLoop.setImmediate == \"undefined\") {\\n          if (typeof setImmediate == \"undefined\") {\\n            var setImmediates = [];\\n            var emscriptenMainLoopMessageId = \"setimmediate\";\\n            var MainLoop_setImmediate_messageHandler = (event) => {\\n              if (\\n                event.data === emscriptenMainLoopMessageId ||\\n                event.data.target === emscriptenMainLoopMessageId\\n              ) {\\n                event.stopPropagation();\\n                setImmediates.shift()();\\n              }\\n            };\\n            addEventListener(\\n              \"message\",\\n              MainLoop_setImmediate_messageHandler,\\n              true,\\n            );\\n            MainLoop.setImmediate = (func) => {\\n              setImmediates.push(func);\\n              if (ENVIRONMENT_IS_WORKER) {\\n                Module[\"setImmediates\"] ??= [];\\n                Module[\"setImmediates\"].push(func);\\n                postMessage({ target: emscriptenMainLoopMessageId });\\n              } else postMessage(emscriptenMainLoopMessageId, \"*\");\\n            };\\n          } else {\\n            MainLoop.setImmediate = setImmediate;\\n          }\\n        }\\n        MainLoop.scheduler = function MainLoop_scheduler_setImmediate() {\\n          MainLoop.setImmediate(MainLoop.runner);\\n        };\\n        MainLoop.method = \"immediate\";\\n      }\\n      return 0;\\n    };\\n    var setMainLoop = (\\n      iterFunc,\\n      fps,\\n      simulateInfiniteLoop,\\n      arg,\\n      noSetTiming,\\n    ) => {\\n      assert(\\n        !MainLoop.func,\\n        \"emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters.\",\\n      );\\n      MainLoop.func = iterFunc;\\n      MainLoop.arg = arg;\\n      var thisMainLoopId = MainLoop.currentlyRunningMainloop;\\n      function checkIsRunning() {\\n        if (thisMainLoopId < MainLoop.currentlyRunningMainloop) {\\n          maybeExit();\\n          return false;\\n        }\\n        return true;\\n      }\\n      MainLoop.running = false;\\n      MainLoop.runner = function MainLoop_runner() {\\n        if (ABORT) return;\\n        if (MainLoop.queue.length > 0) {\\n          var start = Date.now();\\n          var blocker = MainLoop.queue.shift();\\n          blocker.func(blocker.arg);\\n          if (MainLoop.remainingBlockers) {\\n            var remaining = MainLoop.remainingBlockers;\\n            var next =\\n              remaining % 1 == 0 ? remaining - 1 : Math.floor(remaining);\\n            if (blocker.counted) {\\n              MainLoop.remainingBlockers = next;\\n            } else {\\n              next = next + 0.5;\\n              MainLoop.remainingBlockers = (8 * remaining + next) / 9;\\n            }\\n          }\\n          MainLoop.updateStatus();\\n          if (!checkIsRunning()) return;\\n          setTimeout(MainLoop.runner, 0);\\n          return;\\n        }\\n        if (!checkIsRunning()) return;\\n        MainLoop.currentFrameNumber = (MainLoop.currentFrameNumber + 1) | 0;\\n        if (\\n          MainLoop.timingMode == 1 &&\\n          MainLoop.timingValue > 1 &&\\n          MainLoop.currentFrameNumber % MainLoop.timingValue != 0\\n        ) {\\n          MainLoop.scheduler();\\n          return;\\n        } else if (MainLoop.timingMode == 0) {\\n          MainLoop.tickStartTime = _emscripten_get_now();\\n        }\\n        if (MainLoop.method === \"timeout\" && Module[\"ctx\"]) {\\n          warnOnce(\\n            \"Looks like you are rendering without using requestAnimationFrame for the main loop. You should use 0 for the frame rate in emscripten_set_main_loop in order to use requestAnimationFrame, as that can greatly improve your frame rates!\",\\n          );\\n          MainLoop.method = \"\";\\n        }\\n        MainLoop.runIter(iterFunc);\\n        if (!checkIsRunning()) return;\\n        MainLoop.scheduler();\\n      };\\n      if (!noSetTiming) {\\n        if (fps > 0) {\\n          _emscripten_set_main_loop_timing(0, 1e3 / fps);\\n        } else {\\n          _emscripten_set_main_loop_timing(1, 1);\\n        }\\n        MainLoop.scheduler();\\n      }\\n      if (simulateInfiniteLoop) {\\n        throw \"unwind\";\\n      }\\n    };\\n    var MainLoop = {\\n      running: false,\\n      scheduler: null,\\n      method: \"\",\\n      currentlyRunningMainloop: 0,\\n      func: null,\\n      arg: 0,\\n      timingMode: 0,\\n      timingValue: 0,\\n      currentFrameNumber: 0,\\n      queue: [],\\n      preMainLoop: [],\\n      postMainLoop: [],\\n      pause() {\\n        MainLoop.scheduler = null;\\n        MainLoop.currentlyRunningMainloop++;\\n      },\\n      resume() {\\n        MainLoop.currentlyRunningMainloop++;\\n        var timingMode = MainLoop.timingMode;\\n        var timingValue = MainLoop.timingValue;\\n        var func = MainLoop.func;\\n        MainLoop.func = null;\\n        setMainLoop(func, 0, false, MainLoop.arg, true);\\n        _emscripten_set_main_loop_timing(timingMode, timingValue);\\n        MainLoop.scheduler();\\n      },\\n      updateStatus() {\\n        if (Module[\"setStatus\"]) {\\n          var message = Module[\"statusMessage\"] || \"Please wait...\";\\n          var remaining = MainLoop.remainingBlockers ?? 0;\\n          var expected = MainLoop.expectedBlockers ?? 0;\\n          if (remaining) {\\n            if (remaining < expected) {\\n              Module[\"setStatus\"](\\n                `{message} ({expected - remaining}/{expected})`,\\n              );\\n            } else {\\n              Module[\"setStatus\"](message);\\n            }\\n          } else {\\n            Module[\"setStatus\"](\"\");\\n          }\\n        }\\n      },\\n      init() {\\n        Module[\"preMainLoop\"] &&\\n          MainLoop.preMainLoop.push(Module[\"preMainLoop\"]);\\n        Module[\"postMainLoop\"] &&\\n          MainLoop.postMainLoop.push(Module[\"postMainLoop\"]);\\n      },\\n      runIter(func) {\\n        if (ABORT) return;\\n        for (var pre of MainLoop.preMainLoop) {\\n          if (pre() === false) {\\n            return;\\n          }\\n        }\\n        callUserCallback(func);\\n        for (var post of MainLoop.postMainLoop) {\\n          post();\\n        }\\n        checkStackCookie();\\n      },\\n      nextRAF: 0,\\n      fakeRequestAnimationFrame(func) {\\n        var now = Date.now();\\n        if (MainLoop.nextRAF === 0) {\\n          MainLoop.nextRAF = now + 1e3 / 60;\\n        } else {\\n          while (now + 2 >= MainLoop.nextRAF) {\\n            MainLoop.nextRAF += 1e3 / 60;\\n          }\\n        }\\n        var delay = Math.max(MainLoop.nextRAF - now, 0);\\n        setTimeout(func, delay);\\n      },\\n      requestAnimationFrame(func) {\\n        if (typeof requestAnimationFrame == \"function\") {\\n          requestAnimationFrame(func);\\n          return;\\n        }\\n        var RAF = MainLoop.fakeRequestAnimationFrame;\\n        RAF(func);\\n      },\\n    };\\n    var _emscripten_date_now = () => Date.now();\\n    var getHeapMax = () => 2147483648;\\n    var growMemory = (size) => {\\n      var b = wasmMemory.buffer;\\n      var pages = ((size - b.byteLength + 65535) / 65536) | 0;\\n      try {\\n        wasmMemory.grow(BigInt(pages));\\n        updateMemoryViews();\\n        return 1;\\n      } catch (e) {\\n        err(\\n          `growMemory: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`,\\n        );\\n      }\\n    };\\n    function _emscripten_resize_heap(requestedSize) {\\n      requestedSize = bigintToI53Checked(requestedSize);\\n      var oldSize = HEAPU8.length;\\n      assert(requestedSize > oldSize);\\n      var maxHeapSize = getHeapMax();\\n      if (requestedSize > maxHeapSize) {\\n        err(\\n          `Cannot enlarge memory, requested ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`,\\n        );\\n        return false;\\n      }\\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\\n        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\\n        overGrownHeapSize = Math.min(\\n          overGrownHeapSize,\\n          requestedSize + 100663296,\\n        );\\n        var newSize = Math.min(\\n          maxHeapSize,\\n          alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536),\\n        );\\n        var replacement = growMemory(newSize);\\n        if (replacement) {\\n          return true;\\n        }\\n      }\\n      err(\\n        `Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`,\\n      );\\n      return false;\\n    }\\n    function _emscripten_run_script_int(ptr) {\\n      ptr = bigintToI53Checked(ptr);\\n      return eval(UTF8ToString(ptr)) | 0;\\n    }\\n    var safeSetTimeout = (func, timeout) =>\\n      setTimeout(() => {\\n        callUserCallback(func);\\n      }, timeout);\\n    var _emscripten_sleep = (ms) =>\\n      Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));\\n    _emscripten_sleep.isAsync = true;\\n    function _fd_close(fd) {\\n      try {\\n        var stream = SYSCALLS.getStreamFromFD(fd);\\n        FS.close(stream);\\n        return 0;\\n      } catch (e) {\\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\\n        return e.errno;\\n      }\\n    }\\n    var doReadv = (stream, iov, iovcnt, offset) => {\\n      var ret = 0;\\n      for (var i = 0; i < iovcnt; i++) {\\n        var ptr = Number(HEAPU64[iov / 8]);\\n        var len = Number(HEAPU64[(iov + 8) / 8]);\\n        iov += 16;\\n        var curr = FS.read(stream, HEAP8, ptr, len, offset);\\n        if (curr < 0) return -1;\\n        ret += curr;\\n        if (curr < len) break;\\n        if (typeof offset != \"undefined\") {\\n          offset += curr;\\n        }\\n      }\\n      return ret;\\n    };\\n    function _fd_read(fd, iov, iovcnt, pnum) {\\n      iov = bigintToI53Checked(iov);\\n      iovcnt = bigintToI53Checked(iovcnt);\\n      pnum = bigintToI53Checked(pnum);\\n      try {\\n        var stream = SYSCALLS.getStreamFromFD(fd);\\n        var num = doReadv(stream, iov, iovcnt);\\n        HEAPU64[pnum / 8] = BigInt(num);\\n        return 0;\\n      } catch (e) {\\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\\n        return e.errno;\\n      }\\n    }\\n    function _fd_seek(fd, offset, whence, newOffset) {\\n      offset = bigintToI53Checked(offset);\\n      newOffset = bigintToI53Checked(newOffset);\\n      try {\\n        if (isNaN(offset)) return 61;\\n        var stream = SYSCALLS.getStreamFromFD(fd);\\n        FS.llseek(stream, offset, whence);\\n        HEAP64[newOffset / 8] = BigInt(stream.position);\\n        if (stream.getdents && offset === 0 && whence === 0)\\n          stream.getdents = null;\\n        return 0;\\n      } catch (e) {\\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\\n        return e.errno;\\n      }\\n    }\\n    var doWritev = (stream, iov, iovcnt, offset) => {\\n      var ret = 0;\\n      for (var i = 0; i < iovcnt; i++) {\\n        var ptr = Number(HEAPU64[iov / 8]);\\n        var len = Number(HEAPU64[(iov + 8) / 8]);\\n        iov += 16;\\n        var curr = FS.write(stream, HEAP8, ptr, len, offset);\\n        if (curr < 0) return -1;\\n        ret += curr;\\n        if (curr < len) {\\n          break;\\n        }\\n        if (typeof offset != \"undefined\") {\\n          offset += curr;\\n        }\\n      }\\n      return ret;\\n    };\\n    function _fd_write(fd, iov, iovcnt, pnum) {\\n      iov = bigintToI53Checked(iov);\\n      iovcnt = bigintToI53Checked(iovcnt);\\n      pnum = bigintToI53Checked(pnum);\\n      try {\\n        var stream = SYSCALLS.getStreamFromFD(fd);\\n        var num = doWritev(stream, iov, iovcnt);\\n        HEAPU64[pnum / 8] = BigInt(num);\\n        return 0;\\n      } catch (e) {\\n        if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\\n        return e.errno;\\n      }\\n    }\\n    var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {\\n      assert(\\n        typeof maxBytesToWrite == \"number\",\\n        \"stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\",\\n      );\\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\\n    };\\n    var stackAlloc = (sz) => __emscripten_stack_alloc(sz);\\n    var stringToUTF8OnStack = (str) => {\\n      var size = lengthBytesUTF8(str) + 1;\\n      var ret = stackAlloc(size);\\n      stringToUTF8(str, ret, size);\\n      return ret;\\n    };\\n    var runAndAbortIfError = (func) => {\\n      try {\\n        return func();\\n      } catch (e) {\\n        abort(e);\\n      }\\n    };\\n    var runtimeKeepalivePush = () => {\\n      runtimeKeepaliveCounter += 1;\\n    };\\n    var runtimeKeepalivePop = () => {\\n      assert(runtimeKeepaliveCounter > 0);\\n      runtimeKeepaliveCounter -= 1;\\n    };\\n    var Asyncify = {\\n      rewindArguments: {},\\n      instrumentWasmImports(imports) {\\n        var importPattern = /^(invoke_.*|__asyncjs__.*)$/;\\n        for (let [x, original] of Object.entries(imports)) {\\n          if (typeof original == \"function\") {\\n            let isAsyncifyImport = original.isAsync || importPattern.test(x);\\n            imports[x] = (...args) => {\\n              var originalAsyncifyState = Asyncify.state;\\n              try {\\n                return original(...args);\\n              } finally {\\n                var changedToDisabled =\\n                  originalAsyncifyState === Asyncify.State.Normal &&\\n                  Asyncify.state === Asyncify.State.Disabled;\\n                var ignoredInvoke = x.startsWith(\"invoke_\") && true;\\n                if (\\n                  Asyncify.state !== originalAsyncifyState &&\\n                  !isAsyncifyImport &&\\n                  !changedToDisabled &&\\n                  !ignoredInvoke\\n                ) {\\n                  throw new Error(\\n                    `import ${x} was not in ASYNCIFY_IMPORTS, but changed the state`,\\n                  );\\n                }\\n              }\\n            };\\n          }\\n        }\\n      },\\n      saveRewindArguments(funcName, passedArguments) {\\n        return (Asyncify.rewindArguments[funcName] =\\n          Array.from(passedArguments));\\n      },\\n      restoreRewindArguments(funcName) {\\n        return Asyncify.rewindArguments[funcName] || [];\\n      },\\n      instrumentWasmExports(exports) {\\n        var ret = {};\\n        for (let [x, original] of Object.entries(exports)) {\\n          if (typeof original == \"function\") {\\n            ret[x] = (...args) => {\\n              Asyncify.exportCallStack.push(x);\\n              try {\\n                Asyncify.saveRewindArguments(x, args);\\n                return original(...args);\\n              } finally {\\n                if (!ABORT) {\\n                  var y = Asyncify.exportCallStack.pop();\\n                  assert(y === x);\\n                  Asyncify.maybeStopUnwind();\\n                }\\n              }\\n            };\\n          } else {\\n            ret[x] = original;\\n          }\\n        }\\n        return ret;\\n      },\\n      State: { Normal: 0, Unwinding: 1, Rewinding: 2, Disabled: 3 },\\n      state: 0,\\n      StackSize: 4096,\\n      currData: null,\\n      handleSleepReturnValue: 0,\\n      exportCallStack: [],\\n      callStackNameToId: {},\\n      callStackIdToName: {},\\n      callStackId: 0,\\n      asyncPromiseHandlers: null,\\n      sleepCallbacks: [],\\n      getCallStackId(funcName) {\\n        var id = Asyncify.callStackNameToId[funcName];\\n        if (id === undefined) {\\n          id = Asyncify.callStackId++;\\n          Asyncify.callStackNameToId[funcName] = id;\\n          Asyncify.callStackIdToName[id] = funcName;\\n        }\\n        return id;\\n      },\\n      maybeStopUnwind() {\\n        if (\\n          Asyncify.currData &&\\n          Asyncify.state === Asyncify.State.Unwinding &&\\n          Asyncify.exportCallStack.length === 0\\n        ) {\\n          Asyncify.state = Asyncify.State.Normal;\\n          runAndAbortIfError(_asyncify_stop_unwind);\\n          if (typeof Fibers != \"undefined\") {\\n            Fibers.trampoline();\\n          }\\n        }\\n      },\\n      whenDone() {\\n        assert(\\n          Asyncify.currData,\\n          \"Tried to wait for an async operation when none is in progress.\",\\n        );\\n        assert(\\n          !Asyncify.asyncPromiseHandlers,\\n          \"Cannot have multiple async operations in flight at once\",\\n        );\\n        return new Promise((resolve, reject) => {\\n          Asyncify.asyncPromiseHandlers = { resolve, reject };\\n        });\\n      },\\n      allocateData() {\\n        var ptr = _malloc(24 + Asyncify.StackSize);\\n        Asyncify.setDataHeader(ptr, ptr + 24, Asyncify.StackSize);\\n        Asyncify.setDataRewindFunc(ptr);\\n        return ptr;\\n      },\\n      setDataHeader(ptr, stack, stackSize) {\\n        HEAPU64[ptr / 8] = BigInt(stack);\\n        HEAPU64[(ptr + 8) / 8] = BigInt(stack + stackSize);\\n      },\\n      setDataRewindFunc(ptr) {\\n        var bottomOfCallStack = Asyncify.exportCallStack[0];\\n        var rewindId = Asyncify.getCallStackId(bottomOfCallStack);\\n        HEAP32[(ptr + 16) / 4] = rewindId;\\n      },\\n      getDataRewindFuncName(ptr) {\\n        var id = HEAP32[(ptr + 16) / 4];\\n        var name = Asyncify.callStackIdToName[id];\\n        return name;\\n      },\\n      getDataRewindFunc(name) {\\n        var func = wasmExports[name];\\n        return func;\\n      },\\n      doRewind(ptr) {\\n        var name = Asyncify.getDataRewindFuncName(ptr);\\n        var func = Asyncify.getDataRewindFunc(name);\\n        return func(...Asyncify.restoreRewindArguments(name));\\n      },\\n      handleSleep(startAsync) {\\n        assert(\\n          Asyncify.state !== Asyncify.State.Disabled,\\n          \"Asyncify cannot be done during or after the runtime exits\",\\n        );\\n        if (ABORT) return;\\n        if (Asyncify.state === Asyncify.State.Normal) {\\n          var reachedCallback = false;\\n          var reachedAfterCallback = false;\\n          startAsync((handleSleepReturnValue = 0) => {\\n            assert(\\n              !handleSleepReturnValue ||\\n                typeof handleSleepReturnValue == \"number\" ||\\n                typeof handleSleepReturnValue == \"boolean\",\\n            );\\n            if (ABORT) return;\\n            Asyncify.handleSleepReturnValue = handleSleepReturnValue;\\n            reachedCallback = true;\\n            if (!reachedAfterCallback) {\\n              return;\\n            }\\n            assert(\\n              !Asyncify.exportCallStack.length,\\n              \"Waking up (starting to rewind) must be done from JS, without compiled code on the stack.\",\\n            );\\n            Asyncify.state = Asyncify.State.Rewinding;\\n            runAndAbortIfError(() => _asyncify_start_rewind(Asyncify.currData));\\n            if (typeof MainLoop != \"undefined\" && MainLoop.func) {\\n              MainLoop.resume();\\n            }\\n            var asyncWasmReturnValue,\\n              isError = false;\\n            try {\\n              asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);\\n            } catch (err) {\\n              asyncWasmReturnValue = err;\\n              isError = true;\\n            }\\n            var handled = false;\\n            if (!Asyncify.currData) {\\n              var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;\\n              if (asyncPromiseHandlers) {\\n                Asyncify.asyncPromiseHandlers = null;\\n                (isError\\n                  ? asyncPromiseHandlers.reject\\n                  : asyncPromiseHandlers.resolve)(asyncWasmReturnValue);\\n                handled = true;\\n              }\\n            }\\n            if (isError && !handled) {\\n              throw asyncWasmReturnValue;\\n            }\\n          });\\n          reachedAfterCallback = true;\\n          if (!reachedCallback) {\\n            Asyncify.state = Asyncify.State.Unwinding;\\n            Asyncify.currData = Asyncify.allocateData();\\n            if (typeof MainLoop != \"undefined\" && MainLoop.func) {\\n              MainLoop.pause();\\n            }\\n            runAndAbortIfError(() => _asyncify_start_unwind(Asyncify.currData));\\n          }\\n        } else if (Asyncify.state === Asyncify.State.Rewinding) {\\n          Asyncify.state = Asyncify.State.Normal;\\n          runAndAbortIfError(_asyncify_stop_rewind);\\n          _free(Asyncify.currData);\\n          Asyncify.currData = null;\\n          Asyncify.sleepCallbacks.forEach(callUserCallback);\\n        } else {\\n          abort(`invalid state: ${Asyncify.state}`);\\n        }\\n        return Asyncify.handleSleepReturnValue;\\n      },\\n      handleAsync(startAsync) {\\n        return Asyncify.handleSleep((wakeUp) => {\\n          startAsync().then(wakeUp);\\n        });\\n      },\\n    };\\n    var getCFunc = (ident) => {\\n      var func = Module[\"_\" + ident];\\n      assert(\\n        func,\\n        \"Cannot call unknown function \" + ident + \", make sure it is exported\",\\n      );\\n      return func;\\n    };\\n    var writeArrayToMemory = (array, buffer) => {\\n      assert(\\n        array.length >= 0,\\n        \"writeArrayToMemory array must have a length (should be an array or typed array)\",\\n      );\\n      HEAP8.set(array, buffer);\\n    };\\n    var ccall = (ident, returnType, argTypes, args, opts) => {\\n      var toC = {\\n        pointer: (p) => BigInt(p),\\n        string: (str) => {\\n          var ret = 0;\\n          if (str !== null && str !== undefined && str !== 0) {\\n            ret = stringToUTF8OnStack(str);\\n          }\\n          return BigInt(ret);\\n        },\\n        array: (arr) => {\\n          var ret = stackAlloc(arr.length);\\n          writeArrayToMemory(arr, ret);\\n          return BigInt(ret);\\n        },\\n      };\\n      function convertReturnValue(ret) {\\n        if (returnType === \"string\") {\\n          return UTF8ToString(Number(ret));\\n        }\\n        if (returnType === \"pointer\") return Number(ret);\\n        if (returnType === \"boolean\") return Boolean(ret);\\n        return ret;\\n      }\\n      var func = getCFunc(ident);\\n      var cArgs = [];\\n      var stack = 0;\\n      assert(returnType !== \"array\", \\'Return type should not be \"array\".\\');\\n      if (args) {\\n        for (var i = 0; i < args.length; i++) {\\n          var converter = toC[argTypes[i]];\\n          if (converter) {\\n            if (stack === 0) stack = stackSave();\\n            cArgs[i] = converter(args[i]);\\n          } else {\\n            cArgs[i] = args[i];\\n          }\\n        }\\n      }\\n      var previousAsync = Asyncify.currData;\\n      var ret = func(...cArgs);\\n      function onDone(ret) {\\n        runtimeKeepalivePop();\\n        if (stack !== 0) stackRestore(stack);\\n        return convertReturnValue(ret);\\n      }\\n      var asyncMode = opts?.async;\\n      runtimeKeepalivePush();\\n      if (Asyncify.currData != previousAsync) {\\n        assert(\\n          !(previousAsync && Asyncify.currData),\\n          \"We cannot start an async operation when one is already flight\",\\n        );\\n        assert(\\n          !(previousAsync && !Asyncify.currData),\\n          \"We cannot stop an async operation in flight\",\\n        );\\n        assert(\\n          asyncMode,\\n          \"The call to \" +\\n            ident +\\n            \" is running asynchronously. If this was intended, add the async option to the ccall/cwrap call.\",\\n        );\\n        return Asyncify.whenDone().then(onDone);\\n      }\\n      ret = onDone(ret);\\n      if (asyncMode) return Promise.resolve(ret);\\n      return ret;\\n    };\\n    FS.createPreloadedFile = FS_createPreloadedFile;\\n    FS.staticInit();\\n    Module[\"requestAnimationFrame\"] = MainLoop.requestAnimationFrame;\\n    Module[\"pauseMainLoop\"] = MainLoop.pause;\\n    Module[\"resumeMainLoop\"] = MainLoop.resume;\\n    MainLoop.init();\\n    function checkIncomingModuleAPI() {\\n      ignoredModuleProp(\"fetchSettings\");\\n    }\\n    var wasmImports = {\\n      __assert_fail: ___assert_fail,\\n      __syscall_fcntl64: ___syscall_fcntl64,\\n      __syscall_fstat64: ___syscall_fstat64,\\n      __syscall_ioctl: ___syscall_ioctl,\\n      __syscall_openat: ___syscall_openat,\\n      _abort_js: __abort_js,\\n      _emscripten_runtime_keepalive_clear: __emscripten_runtime_keepalive_clear,\\n      _mmap_js: __mmap_js,\\n      _munmap_js: __munmap_js,\\n      _setitimer_js: __setitimer_js,\\n      emscripten_date_now: _emscripten_date_now,\\n      emscripten_resize_heap: _emscripten_resize_heap,\\n      emscripten_run_script_int: _emscripten_run_script_int,\\n      emscripten_sleep: _emscripten_sleep,\\n      exit: _exit,\\n      fd_close: _fd_close,\\n      fd_read: _fd_read,\\n      fd_seek: _fd_seek,\\n      fd_write: _fd_write,\\n      proc_exit: _proc_exit,\\n    };\\n    var wasmExports = await createWasm();\\n    var ___wasm_call_ctors = createExportWrapper(\"__wasm_call_ctors\", 0);\\n    var _malloc = (Module[\"_malloc\"] = createExportWrapper(\"malloc\", 1));\\n    var _free = (Module[\"_free\"] = createExportWrapper(\"free\", 1));\\n    var _send_int_to_C = (Module[\"_send_int_to_C\"] = createExportWrapper(\\n      \"send_int_to_C\",\\n      1,\\n    ));\\n    var _send_float_to_C = (Module[\"_send_float_to_C\"] = createExportWrapper(\\n      \"send_float_to_C\",\\n      1,\\n    ));\\n    var _send_double_to_C = (Module[\"_send_double_to_C\"] = createExportWrapper(\\n      \"send_double_to_C\",\\n      1,\\n    ));\\n    var _send_char_to_C = (Module[\"_send_char_to_C\"] = createExportWrapper(\\n      \"send_char_to_C\",\\n      1,\\n    ));\\n    var _send_string_to_C = (Module[\"_send_string_to_C\"] = createExportWrapper(\\n      \"send_string_to_C\",\\n      1,\\n    ));\\n    var _reanudar_ejecucion = (Module[\"_reanudar_ejecucion\"] =\\n      createExportWrapper(\"reanudar_ejecucion\", 1));\\n    var _strerror = createExportWrapper(\"strerror\", 1);\\n    var _fflush = createExportWrapper(\"fflush\", 1);\\n    var _main = (Module[\"_main\"] = createExportWrapper(\"__main_argc_argv\", 2));\\n    var _emscripten_builtin_memalign = createExportWrapper(\\n      \"emscripten_builtin_memalign\",\\n      2,\\n    );\\n    var __emscripten_timeout = createExportWrapper(\"_emscripten_timeout\", 2);\\n    var _emscripten_stack_init = wasmExports[\"emscripten_stack_init\"];\\n    var _emscripten_stack_get_free = wasmExports[\"emscripten_stack_get_free\"];\\n    var _emscripten_stack_get_base = wasmExports[\"emscripten_stack_get_base\"];\\n    var _emscripten_stack_get_end = wasmExports[\"emscripten_stack_get_end\"];\\n    var __emscripten_stack_restore = wasmExports[\"_emscripten_stack_restore\"];\\n    var __emscripten_stack_alloc = wasmExports[\"_emscripten_stack_alloc\"];\\n    var _emscripten_stack_get_current =\\n      wasmExports[\"emscripten_stack_get_current\"];\\n    var ___cxa_increment_exception_refcount = createExportWrapper(\\n      \"__cxa_increment_exception_refcount\",\\n      1,\\n    );\\n    var dynCall_jj = (Module[\"dynCall_jj\"] = createExportWrapper(\\n      \"dynCall_jj\",\\n      2,\\n    ));\\n    var dynCall_jjjj = (Module[\"dynCall_jjjj\"] = createExportWrapper(\\n      \"dynCall_jjjj\",\\n      4,\\n    ));\\n    var dynCall_vjj = (Module[\"dynCall_vjj\"] = createExportWrapper(\\n      \"dynCall_vjj\",\\n      3,\\n    ));\\n    var dynCall_ijjj = (Module[\"dynCall_ijjj\"] = createExportWrapper(\\n      \"dynCall_ijjj\",\\n      4,\\n    ));\\n    var dynCall_ijii = (Module[\"dynCall_ijii\"] = createExportWrapper(\\n      \"dynCall_ijii\",\\n      4,\\n    ));\\n    var dynCall_ij = (Module[\"dynCall_ij\"] = createExportWrapper(\\n      \"dynCall_ij\",\\n      2,\\n    ));\\n    var dynCall_jjii = (Module[\"dynCall_jjii\"] = createExportWrapper(\\n      \"dynCall_jjii\",\\n      4,\\n    ));\\n    var dynCall_jjji = (Module[\"dynCall_jjji\"] = createExportWrapper(\\n      \"dynCall_jjji\",\\n      4,\\n    ));\\n    var dynCall_ijdiiii = (Module[\"dynCall_ijdiiii\"] = createExportWrapper(\\n      \"dynCall_ijdiiii\",\\n      7,\\n    ));\\n    var dynCall_v = (Module[\"dynCall_v\"] = createExportWrapper(\"dynCall_v\", 1));\\n    var dynCall_vi = (Module[\"dynCall_vi\"] = createExportWrapper(\\n      \"dynCall_vi\",\\n      2,\\n    ));\\n    var _asyncify_start_unwind = createExportWrapper(\\n      \"asyncify_start_unwind\",\\n      1,\\n    );\\n    var _asyncify_stop_unwind = createExportWrapper(\"asyncify_stop_unwind\", 0);\\n    var _asyncify_start_rewind = createExportWrapper(\\n      \"asyncify_start_rewind\",\\n      1,\\n    );\\n    var _asyncify_stop_rewind = createExportWrapper(\"asyncify_stop_rewind\", 0);\\n    function applySignatureConversions(wasmExports) {\\n      wasmExports = Object.assign({}, wasmExports);\\n      var makeWrapper_pp = (f) => (a0) => Number(f(BigInt(a0)));\\n      var makeWrapper__p = (f) => (a0) => f(BigInt(a0));\\n      var makeWrapper_p_ = (f) => (a0) => Number(f(a0));\\n      var makeWrapper___PP = (f) => (a0, a1, a2) =>\\n        f(a0, BigInt(a1 ? a1 : 0), BigInt(a2 ? a2 : 0));\\n      var makeWrapper_ppp = (f) => (a0, a1) =>\\n        Number(f(BigInt(a0), BigInt(a1)));\\n      var makeWrapper_p = (f) => () => Number(f());\\n      var makeWrapper__p_ = (f) => (a0, a1) => f(BigInt(a0), a1);\\n      var makeWrapper__p___ = (f) => (a0, a1, a2, a3) =>\\n        f(BigInt(a0), a1, a2, a3);\\n      var makeWrapper__p__ = (f) => (a0, a1, a2) => f(BigInt(a0), a1, a2);\\n      var makeWrapper__p______ = (f) => (a0, a1, a2, a3, a4, a5, a6) =>\\n        f(BigInt(a0), a1, a2, a3, a4, a5, a6);\\n      wasmExports[\"malloc\"] = makeWrapper_pp(wasmExports[\"malloc\"]);\\n      wasmExports[\"free\"] = makeWrapper__p(wasmExports[\"free\"]);\\n      wasmExports[\"strerror\"] = makeWrapper_p_(wasmExports[\"strerror\"]);\\n      wasmExports[\"fflush\"] = makeWrapper__p(wasmExports[\"fflush\"]);\\n      wasmExports[\"__main_argc_argv\"] = makeWrapper___PP(\\n        wasmExports[\"__main_argc_argv\"],\\n      );\\n      wasmExports[\"emscripten_builtin_memalign\"] = makeWrapper_ppp(\\n        wasmExports[\"emscripten_builtin_memalign\"],\\n      );\\n      wasmExports[\"emscripten_stack_get_base\"] = makeWrapper_p(\\n        wasmExports[\"emscripten_stack_get_base\"],\\n      );\\n      wasmExports[\"emscripten_stack_get_end\"] = makeWrapper_p(\\n        wasmExports[\"emscripten_stack_get_end\"],\\n      );\\n      wasmExports[\"_emscripten_stack_restore\"] = makeWrapper__p(\\n        wasmExports[\"_emscripten_stack_restore\"],\\n      );\\n      wasmExports[\"_emscripten_stack_alloc\"] = makeWrapper_pp(\\n        wasmExports[\"_emscripten_stack_alloc\"],\\n      );\\n      wasmExports[\"emscripten_stack_get_current\"] = makeWrapper_p(\\n        wasmExports[\"emscripten_stack_get_current\"],\\n      );\\n      wasmExports[\"__cxa_increment_exception_refcount\"] = makeWrapper__p(\\n        wasmExports[\"__cxa_increment_exception_refcount\"],\\n      );\\n      wasmExports[\"dynCall_jj\"] = makeWrapper__p_(wasmExports[\"dynCall_jj\"]);\\n      wasmExports[\"dynCall_jjjj\"] = makeWrapper__p___(\\n        wasmExports[\"dynCall_jjjj\"],\\n      );\\n      wasmExports[\"dynCall_vjj\"] = makeWrapper__p__(wasmExports[\"dynCall_vjj\"]);\\n      wasmExports[\"dynCall_ijjj\"] = makeWrapper__p___(\\n        wasmExports[\"dynCall_ijjj\"],\\n      );\\n      wasmExports[\"dynCall_ijii\"] = makeWrapper__p___(\\n        wasmExports[\"dynCall_ijii\"],\\n      );\\n      wasmExports[\"dynCall_ij\"] = makeWrapper__p_(wasmExports[\"dynCall_ij\"]);\\n      wasmExports[\"dynCall_jjii\"] = makeWrapper__p___(\\n        wasmExports[\"dynCall_jjii\"],\\n      );\\n      wasmExports[\"dynCall_jjji\"] = makeWrapper__p___(\\n        wasmExports[\"dynCall_jjji\"],\\n      );\\n      wasmExports[\"dynCall_ijdiiii\"] = makeWrapper__p______(\\n        wasmExports[\"dynCall_ijdiiii\"],\\n      );\\n      wasmExports[\"dynCall_v\"] = makeWrapper__p(wasmExports[\"dynCall_v\"]);\\n      wasmExports[\"dynCall_vi\"] = makeWrapper__p_(wasmExports[\"dynCall_vi\"]);\\n      wasmExports[\"asyncify_start_unwind\"] = makeWrapper__p(\\n        wasmExports[\"asyncify_start_unwind\"],\\n      );\\n      wasmExports[\"asyncify_start_rewind\"] = makeWrapper__p(\\n        wasmExports[\"asyncify_start_rewind\"],\\n      );\\n      return wasmExports;\\n    }\\n    Module[\"run\"] = run;\\n    Module[\"callMain\"] = callMain;\\n    Module[\"ccall\"] = ccall;\\n    Module[\"stringToUTF8\"] = stringToUTF8;\\n    Module[\"lengthBytesUTF8\"] = lengthBytesUTF8;\\n    var missingLibrarySymbols = [\\n      \"writeI53ToI64\",\\n      \"writeI53ToI64Clamped\",\\n      \"writeI53ToI64Signaling\",\\n      \"writeI53ToU64Clamped\",\\n      \"writeI53ToU64Signaling\",\\n      \"readI53FromI64\",\\n      \"readI53FromU64\",\\n      \"convertI32PairToI53\",\\n      \"convertI32PairToI53Checked\",\\n      \"convertU32PairToI53\",\\n      \"getTempRet0\",\\n      \"setTempRet0\",\\n      \"inetPton4\",\\n      \"inetNtop4\",\\n      \"inetPton6\",\\n      \"inetNtop6\",\\n      \"readSockaddr\",\\n      \"writeSockaddr\",\\n      \"emscriptenLog\",\\n      \"readEmAsmArgs\",\\n      \"jstoi_q\",\\n      \"getExecutableName\",\\n      \"listenOnce\",\\n      \"autoResumeAudioContext\",\\n      \"dynCallLegacy\",\\n      \"getDynCaller\",\\n      \"dynCall\",\\n      \"asmjsMangle\",\\n      \"HandleAllocator\",\\n      \"getNativeTypeSize\",\\n      \"addOnInit\",\\n      \"addOnPostCtor\",\\n      \"addOnPreMain\",\\n      \"addOnExit\",\\n      \"STACK_SIZE\",\\n      \"STACK_ALIGN\",\\n      \"POINTER_SIZE\",\\n      \"ASSERTIONS\",\\n      \"cwrap\",\\n      \"uleb128Encode\",\\n      \"generateFuncType\",\\n      \"convertJsFunctionToWasm\",\\n      \"getEmptyTableSlot\",\\n      \"updateTableMap\",\\n      \"getFunctionAddress\",\\n      \"addFunction\",\\n      \"removeFunction\",\\n      \"reallyNegative\",\\n      \"unSign\",\\n      \"strLen\",\\n      \"reSign\",\\n      \"formatString\",\\n      \"intArrayToString\",\\n      \"AsciiToString\",\\n      \"stringToAscii\",\\n      \"UTF16ToString\",\\n      \"stringToUTF16\",\\n      \"lengthBytesUTF16\",\\n      \"UTF32ToString\",\\n      \"stringToUTF32\",\\n      \"lengthBytesUTF32\",\\n      \"stringToNewUTF8\",\\n      \"registerKeyEventCallback\",\\n      \"maybeCStringToJsString\",\\n      \"findEventTarget\",\\n      \"getBoundingClientRect\",\\n      \"fillMouseEventData\",\\n      \"registerMouseEventCallback\",\\n      \"registerWheelEventCallback\",\\n      \"registerUiEventCallback\",\\n      \"registerFocusEventCallback\",\\n      \"fillDeviceOrientationEventData\",\\n      \"registerDeviceOrientationEventCallback\",\\n      \"fillDeviceMotionEventData\",\\n      \"registerDeviceMotionEventCallback\",\\n      \"screenOrientation\",\\n      \"fillOrientationChangeEventData\",\\n      \"registerOrientationChangeEventCallback\",\\n      \"fillFullscreenChangeEventData\",\\n      \"registerFullscreenChangeEventCallback\",\\n      \"JSEvents_requestFullscreen\",\\n      \"JSEvents_resizeCanvasForFullscreen\",\\n      \"registerRestoreOldStyle\",\\n      \"hideEverythingExceptGivenElement\",\\n      \"restoreHiddenElements\",\\n      \"setLetterbox\",\\n      \"softFullscreenResizeWebGLRenderTarget\",\\n      \"doRequestFullscreen\",\\n      \"fillPointerlockChangeEventData\",\\n      \"registerPointerlockChangeEventCallback\",\\n      \"registerPointerlockErrorEventCallback\",\\n      \"requestPointerLock\",\\n      \"fillVisibilityChangeEventData\",\\n      \"registerVisibilityChangeEventCallback\",\\n      \"registerTouchEventCallback\",\\n      \"fillGamepadEventData\",\\n      \"registerGamepadEventCallback\",\\n      \"registerBeforeUnloadEventCallback\",\\n      \"fillBatteryEventData\",\\n      \"battery\",\\n      \"registerBatteryEventCallback\",\\n      \"setCanvasElementSize\",\\n      \"getCanvasElementSize\",\\n      \"jsStackTrace\",\\n      \"getCallstack\",\\n      \"convertPCtoSourceLocation\",\\n      \"getEnvStrings\",\\n      \"checkWasiClock\",\\n      \"wasiRightsToMuslOFlags\",\\n      \"wasiOFlagsToMuslOFlags\",\\n      \"setImmediateWrapped\",\\n      \"safeRequestAnimationFrame\",\\n      \"clearImmediateWrapped\",\\n      \"registerPostMainLoop\",\\n      \"registerPreMainLoop\",\\n      \"getPromise\",\\n      \"makePromise\",\\n      \"idsToPromises\",\\n      \"makePromiseCallback\",\\n      \"ExceptionInfo\",\\n      \"findMatchingCatch\",\\n      \"Browser_asyncPrepareDataCounter\",\\n      \"isLeapYear\",\\n      \"ydayFromDate\",\\n      \"arraySum\",\\n      \"addDays\",\\n      \"getSocketFromFD\",\\n      \"getSocketAddress\",\\n      \"FS_unlink\",\\n      \"FS_mkdirTree\",\\n      \"_setNetworkCallback\",\\n      \"heapObjectForWebGLType\",\\n      \"toTypedArrayIndex\",\\n      \"webgl_enable_ANGLE_instanced_arrays\",\\n      \"webgl_enable_OES_vertex_array_object\",\\n      \"webgl_enable_WEBGL_draw_buffers\",\\n      \"webgl_enable_WEBGL_multi_draw\",\\n      \"webgl_enable_EXT_polygon_offset_clamp\",\\n      \"webgl_enable_EXT_clip_control\",\\n      \"webgl_enable_WEBGL_polygon_mode\",\\n      \"emscriptenWebGLGet\",\\n      \"computeUnpackAlignedImageSize\",\\n      \"colorChannelsInGlTextureFormat\",\\n      \"emscriptenWebGLGetTexPixelData\",\\n      \"emscriptenWebGLGetUniform\",\\n      \"webglGetUniformLocation\",\\n      \"webglPrepareUniformLocationsBeforeFirstUse\",\\n      \"webglGetLeftBracePos\",\\n      \"emscriptenWebGLGetVertexAttrib\",\\n      \"__glGetActiveAttribOrUniform\",\\n      \"writeGLArray\",\\n      \"registerWebGlEventCallback\",\\n      \"ALLOC_NORMAL\",\\n      \"ALLOC_STACK\",\\n      \"allocate\",\\n      \"writeStringToMemory\",\\n      \"writeAsciiToMemory\",\\n      \"setErrNo\",\\n      \"demangle\",\\n      \"stackTrace\",\\n    ];\\n    missingLibrarySymbols.forEach(missingLibrarySymbol);\\n    var unexportedSymbols = [\\n      \"addRunDependency\",\\n      \"removeRunDependency\",\\n      \"out\",\\n      \"err\",\\n      \"abort\",\\n      \"wasmMemory\",\\n      \"wasmExports\",\\n      \"writeStackCookie\",\\n      \"checkStackCookie\",\\n      \"INT53_MAX\",\\n      \"INT53_MIN\",\\n      \"bigintToI53Checked\",\\n      \"stackSave\",\\n      \"stackRestore\",\\n      \"stackAlloc\",\\n      \"ptrToString\",\\n      \"zeroMemory\",\\n      \"exitJS\",\\n      \"getHeapMax\",\\n      \"growMemory\",\\n      \"ENV\",\\n      \"ERRNO_CODES\",\\n      \"strError\",\\n      \"DNS\",\\n      \"Protocols\",\\n      \"Sockets\",\\n      \"timers\",\\n      \"warnOnce\",\\n      \"readEmAsmArgsArray\",\\n      \"jstoi_s\",\\n      \"handleException\",\\n      \"keepRuntimeAlive\",\\n      \"runtimeKeepalivePush\",\\n      \"runtimeKeepalivePop\",\\n      \"callUserCallback\",\\n      \"maybeExit\",\\n      \"asyncLoad\",\\n      \"alignMemory\",\\n      \"mmapAlloc\",\\n      \"wasmTable\",\\n      \"noExitRuntime\",\\n      \"addOnPreRun\",\\n      \"addOnPostRun\",\\n      \"getCFunc\",\\n      \"sigToWasmTypes\",\\n      \"freeTableIndexes\",\\n      \"functionsInTableMap\",\\n      \"setValue\",\\n      \"getValue\",\\n      \"PATH\",\\n      \"PATH_FS\",\\n      \"UTF8Decoder\",\\n      \"UTF8ArrayToString\",\\n      \"UTF8ToString\",\\n      \"stringToUTF8Array\",\\n      \"intArrayFromString\",\\n      \"UTF16Decoder\",\\n      \"stringToUTF8OnStack\",\\n      \"writeArrayToMemory\",\\n      \"JSEvents\",\\n      \"specialHTMLTargets\",\\n      \"findCanvasEventTarget\",\\n      \"currentFullscreenStrategy\",\\n      \"restoreOldWindowedStyle\",\\n      \"UNWIND_CACHE\",\\n      \"ExitStatus\",\\n      \"doReadv\",\\n      \"doWritev\",\\n      \"initRandomFill\",\\n      \"randomFill\",\\n      \"safeSetTimeout\",\\n      \"emSetImmediate\",\\n      \"emClearImmediate_deps\",\\n      \"emClearImmediate\",\\n      \"promiseMap\",\\n      \"uncaughtExceptionCount\",\\n      \"exceptionLast\",\\n      \"exceptionCaught\",\\n      \"Browser\",\\n      \"getPreloadedImageData__data\",\\n      \"wget\",\\n      \"MONTH_DAYS_REGULAR\",\\n      \"MONTH_DAYS_LEAP\",\\n      \"MONTH_DAYS_REGULAR_CUMULATIVE\",\\n      \"MONTH_DAYS_LEAP_CUMULATIVE\",\\n      \"SYSCALLS\",\\n      \"preloadPlugins\",\\n      \"FS_createPreloadedFile\",\\n      \"FS_modeStringToFlags\",\\n      \"FS_getMode\",\\n      \"FS_stdin_getChar_buffer\",\\n      \"FS_stdin_getChar\",\\n      \"FS_createPath\",\\n      \"FS_createDevice\",\\n      \"FS_readFile\",\\n      \"FS\",\\n      \"FS_createDataFile\",\\n      \"FS_createLazyFile\",\\n      \"MEMFS\",\\n      \"TTY\",\\n      \"PIPEFS\",\\n      \"SOCKFS\",\\n      \"tempFixedLengthArray\",\\n      \"miniTempWebGLFloatBuffers\",\\n      \"miniTempWebGLIntBuffers\",\\n      \"GL\",\\n      \"AL\",\\n      \"GLUT\",\\n      \"EGL\",\\n      \"GLEW\",\\n      \"IDBStore\",\\n      \"runAndAbortIfError\",\\n      \"Asyncify\",\\n      \"Fibers\",\\n      \"SDL\",\\n      \"SDL_gfx\",\\n      \"allocateUTF8\",\\n      \"allocateUTF8OnStack\",\\n      \"print\",\\n      \"printErr\",\\n    ];\\n    unexportedSymbols.forEach(unexportedRuntimeSymbol);\\n    var calledRun;\\n    function callMain(args = []) {\\n      assert(\\n        runDependencies == 0,\\n        \\'cannot call main when async dependencies remain! (listen on Module[\"onRuntimeInitialized\"])\\',\\n      );\\n      assert(\\n        typeof onPreRuns === \"undefined\" || onPreRuns.length == 0,\\n        \"cannot call main when preRun functions remain to be called\",\\n      );\\n      var entryFunction = _main;\\n      args.unshift(thisProgram);\\n      var argc = args.length;\\n      var argv = stackAlloc((argc + 1) * 8);\\n      var argv_ptr = argv;\\n      args.forEach((arg) => {\\n        HEAPU64[argv_ptr / 8] = BigInt(stringToUTF8OnStack(arg));\\n        argv_ptr += 8;\\n      });\\n      HEAPU64[argv_ptr / 8] = BigInt(0);\\n      try {\\n        var ret = entryFunction(argc, BigInt(argv));\\n        exitJS(ret, true);\\n        return ret;\\n      } catch (e) {\\n        return handleException(e);\\n      }\\n    }\\n    function stackCheckInit() {\\n      _emscripten_stack_init();\\n      writeStackCookie();\\n    }\\n    function run(args = arguments_) {\\n      if (runDependencies > 0) {\\n        // dependenciesFulfilled = run;\\n        return;\\n      }\\n      stackCheckInit();\\n      preRun();\\n      if (runDependencies > 0) {\\n        // dependenciesFulfilled = run;\\n        return;\\n      }\\n      function doRun() {\\n        assert(!calledRun);\\n        calledRun = true;\\n        Module[\"calledRun\"] = true;\\n        if (ABORT) return;\\n        initRuntime();\\n        FS.writeFile(\"output.elf\", args[0]);\\n        args.shift();\\n        preMain();\\n        readyPromiseResolve(Module);\\n        Module[\"onRuntimeInitialized\"]?.();\\n        var noInitialRun = Module[\"noInitialRun\"];\\n        legacyModuleProp(\"noInitialRun\", \"noInitialRun\");\\n        callMain(args);\\n        postRun();\\n      }\\n      if (Module[\"setStatus\"]) {\\n        Module[\"setStatus\"](\"Running...\");\\n        setTimeout(() => {\\n          setTimeout(() => Module[\"setStatus\"](\"\"), 1);\\n          doRun();\\n        }, 1);\\n      } else {\\n        doRun();\\n      }\\n      checkStackCookie();\\n    }\\n    function checkUnflushedContent() {\\n      var oldOut = out;\\n      var oldErr = err;\\n      var has = false;\\n      out = err = (x) => {\\n        has = true;\\n      };\\n      try {\\n        _fflush(0);\\n        [\"stdout\", \"stderr\"].forEach((name) => {\\n          var info = FS.analyzePath(\"/dev/\" + name);\\n          if (!info) return;\\n          var stream = info.object;\\n          var rdev = stream.rdev;\\n          var tty = TTY.ttys[rdev];\\n          if (tty?.output?.length) {\\n            has = true;\\n          }\\n        });\\n      } catch (e) {}\\n      out = oldOut;\\n      err = oldErr;\\n      if (has) {\\n        warnOnce(\\n          \"stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.\",\\n        );\\n      }\\n    }\\n    if (Module[\"preInit\"]) {\\n      if (typeof Module[\"preInit\"] == \"function\")\\n        Module[\"preInit\"] = [Module[\"preInit\"]];\\n      while (Module[\"preInit\"].length > 0) {\\n        Module[\"preInit\"].pop()();\\n      }\\n    }\\n    // run();\\n    moduleRtn = readyPromise;\\n    for (const prop of Object.keys(Module)) {\\n      if (!(prop in moduleArg)) {\\n        Object.defineProperty(moduleArg, prop, {\\n          configurable: true,\\n          get() {\\n            abort(\\n              `Access to module property (\\'${prop}\\') is no longer possible via the module constructor argument; Instead, use the result of the module constructor.`,\\n            );\\n          },\\n        });\\n      }\\n    }\\n    readyPromiseResolve(Module);\\n    return moduleRtn;\\n  };\\n})();\\n(() => {\\n  // Create a small, never-async wrapper around Module which\\n  // checks for callers incorrectly using it with `new`.\\n  var real_Module = Module;\\n  Module = function (arg) {\\n    if (new.target)\\n      throw new Error(\"Module() should not be called with `new Module()`\");\\n    return real_Module(arg);\\n  };\\n})();\\nexport default Module;\\n';"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAI,CAAC;AACxB,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC;AAE5BE,MAAM,CAACC,OAAO,GAAG,SAASC,WAAWA,CAACC,IAAI,EAAEC,GAAG,EAAE;EAC/C,MAAMC,MAAM,GAAGF,IAAI,CAACE,MAAM;;EAE1B;EACA,MAAMC,OAAO,GAAG,CACd,uBAAuB,EACvB,0CAA0C,EAC1C,8CAA8C,CAC/C;EAED,MAAMC,eAAe,GAAGD,OAAO,CAACE,KAAK,CAAEC,CAAC,IAAKJ,MAAM,CAACK,QAAQ,CAACD,CAAC,CAAC,CAAC;EAChE,IAAI,CAACF,eAAe,EAAE,OAAOF,MAAM;;EAEnC;EACA,MAAMM,WAAW,GAAGZ,IAAI,CAACa,IAAI,CAACC,OAAO,CAACC,GAAG,CAAC,CAAC,EAAE,YAAY,CAAC;EAC1D,IAAIjB,EAAE,CAACkB,UAAU,CAACJ,WAAW,CAAC,EAAE;IAC9B,OAAOd,EAAE,CAACmB,YAAY,CAACL,WAAW,EAAE,MAAM,CAAC;EAC7C;;EAEA;EACA,OAAOM,eAAe;AACxB,CAAC;AAED,MAAMA,eAAe,GAAG,ywuMAAywuM","ignoreList":[]}},"mtime":1769770760833}}